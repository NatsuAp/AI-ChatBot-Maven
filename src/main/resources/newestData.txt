Question: 1 ### 1.  Which of the following pairs of declarations will cause an error message?  I. double x = 14.7;
int y = x;
  II. double x = 14.7;
int y = (int) x;
  III. int x = 14;
double y = x;
 ### A. None  B. I only  C. II only  D. III only  E. I and III only ### Correct Answer:  B ### Explanation: ### When  x  is converted to an integer, as in segment I, information is lost. Java requires that an explicit cast to an  int  be made, as in segment II. Note that segment II will cause  x  to be truncated: The value stored in  y  is  14 . By requiring the explicit cast, Java doesnât let you do this accidentally. In segment III,  y  will contain the value  14.0 . No explicit cast to a  double  is required since no information is lost. ### 
#########################################################
Question: 2 ### 2.  What output will be produced by the following?   System.out.print("\\* This is not\n a comment *\\"); ### A.  * This is not a comment *   B.  \* This is not a comment *\   C. * This is not
comment
  D. * This is not
a comment *\
  E. * This is not
a comment *
 ### Correct Answer:  E ### Explanation: ### The string argument contains two escape sequences: â \\ â, which means print a backslash ( \ ), and â \n â, which means go to a new line. Choice E is the only choice that does both of these. ### 
#########################################################
Question: 3 ### 3.  Consider the following code segment.  if (n != 0 && x / n > 100)
statement1;
else
statement2;
  If  n  is of type  int  and has a value of  0  when the segment is executed, what will happen? ### A. An  ArithmeticException  will be thrown.  B. A syntax error will occur.  C.   statement1  , but not   statement2  , will be executed.  D.   statement2  , but not   statement1  , will be executed.  E. Neither   statement1   nor   statement2   will be executed; control will pass to the first statement following the  if  statement. ### Correct Answer:  D ### Explanation: ### Short-circuit evaluation of the boolean expression will occur. The expression  (n != 0)  will evaluate to  false , which makes the entire boolean expression  false . Therefore the expression  (x / n &gt; 100)  will not be evaluated. Hence no division by zero will occur, which would have caused an  ArithmeticException  to be thrown. When the boolean expression has a value of  false , only the  else  part of the statement,   statement2  , will be executed. ### 
#########################################################
Question: 4 ### 4.  Refer to the following code fragment.   double answer = 13 / 5;    System.out.println("13 / 5 = " + answer);   The output is   13 / 5 = 2.0   The programmer intends the output to be   13 / 5 = 2.6   Which of the following replacements for the first line of code will not fix the problem? ### A.  double answer = (double) 13 / 5;   B.  double answer = 13 / (double) 5;   C.  double answer = 13.0 / 5;   D.  double answer = 13 / 5.0;   E.  double answer = (double) (13 / 5); ### Correct Answer:  E ### Explanation: ### For this choice, the integer division  13/5  will be evaluated to  2 , which will then be cast to  2.0 . The output will be  13/5 = 2.0 . The compiler needs a way to recognize that real-valued division is required. All the other options provide a way. ### 
#########################################################
Question: 5 ### 5.  What value is stored in  result  if   int result = 13 - 3 * 6 / 4 % 3; ### A. -5  B. 0  C. 13  D. -1  E. 12 ### Correct Answer:  E ### Explanation: ### The operators  *, / , and  %  have equal precedence, all higher than  - , and must be performed first, from left to right.  13 - 3 * 6 / 4 % 3
= 13 - 18 / 4 % 3
= 13 - 4 % 3
=
13 - 1
=
12
 ### 
#########################################################
Question: 6 ### 6.  Suppose that addition and subtraction had higher precedence than multiplication and division. Then the expression   2 + 3 * 12 / 7 - 4 + 8   would evaluate to which of the following? ### A. 11  B. 12  C. 5  D. 9  E. -4 ### Correct Answer:  C ### Explanation: ### The expression must be evaluated as if parenthesized like this:   (2 + 3) * 12 / (7 - 4 + 8)   This becomes  5 * 12 / 11 = 60 / 11 = 5 . ### 
#########################################################
Question: 7 ### 7.  Which is true of the following boolean expression, given that  x  is a variable of type  double ?   3.0 == x * (3.0 / x) ### A. It will always evaluate to false.  B. It may evaluate to false for some values of  x .  C. It will evaluate to false only when  x  is zero.  D. It will evaluate to false only when  x  is very large or very close to zero.  E. It will always evaluate to true. ### Correct Answer:  B ### Explanation: ### Although the expression is always algebraically true for nonzero  x , the expression may evaluate to false. This could occur because of round-off error in performing the division and multiplication operations. Whether the right-hand side of the expression evaluates to exactly 3.0 depends on the value of  x . Note that if  x  is zero, the expression will be evaluated to  false  because the right-hand side will be assigned a value of  Infinity . ### 
#########################################################
Question: 8 ### 8.  Let  x  be a variable of type  double  that is positive. A program contains the boolean expression  (Math.pow(x,0.5) == Math.sqrt(x)) . Even though  x  1/2  is mathematically equivalent to <img  src="https://img.crackap.com/ap/computer-science-a/br23/rootx.jpg">, the above expression returns the value  false  in a studentâs program. Which of the following is the most likely reason?  ### A.  Math.pow  returns an  int , while  Math.sqrt  returns a  double .  B.  x  was imprecisely calculated in a previous program statement.  C. The computer stores floating-point numbers with 32-bit words.  D. There is round-off error in calculating the  pow  and  sqrt  functions.  E. There is overflow error in calculating the  pow  function. ### Correct Answer:  D ### Explanation: ### Any time arithmetic operations are done with floating-point numbers, round-off error may occur. The  Math  class methods such as  pow  and  sqrt  use various approximations to generate their answers to the required accuracy. Since they do different internal arithmetic, however, the round-off will usually not result in exactly the same answers. Note that choice A is not correct because both  Math.pow  and  Math.sqrt  return type  double . Choice B is wrong because no matter how  x  was previously calculated, the same  x  is input to  pow  and  sqrt . Choice C is wrong since round-off error occurs no matter how many bits are used to represent numbers. Choice E is wrong because if  x  is representable on the machine (i.e., hasnât overflowed), then its square root,  x  1/2 , will not overflow. ### 
#########################################################
Question: 9 ### 9.  What will the output be for the following poorly formatted program segment, if the input value for  num  is  22 ?  int num = call to a method that reads an integer;
if (num > 0)
if (num % 5 == 0)
System. out. println(num) ;
else System. out . println (num + " is negative");
 ### A.  22   B.  4   C.  2 is negative   D.  22 is negative   E. Nothing will be output. ### Correct Answer:  D ### Explanation: ### Each  else  gets paired with the nearest unpaired  if . Thus when the test  (22 % 5 == 0)  fails, the  else  part indicating that  22 is negative  will be executed. This is clearly not the intent of the fragment, which can be fixed using delimiters:  int num = call to a method that reads an integer ;
if (num > 0)
if (num % 5 == 0)
System.out.println(num) ;
}
else
System. out. println (num + " is negative") ;
 ### 
#########################################################
Question: 10 ### 10.  What values are stored in  x  and  y  after execution of the following program segment?  int x = 30, y = 40;
if (x>= 0)
{
if (x <= 100)
{
y= x * 3;
if (y < 50)
x /= 10;
}
else
y= x * 2;
else
y = - x;
 ### A.  x = 30 y = 90   B.  x = 30 y = -30   C.  x = 30 y = 60   D.  x = 3 y = -3   E.  x = 30 y = 40 ### Correct Answer:  A ### Explanation: ### Since the first test  (x &gt;= 0)  is  true , the matching  else  part,  y = -x , will not be executed. Since  (x &lt;= 100)  is  true , the matching  else  part,  y = x * 2 , will not be executed. The variable  y  will be set to  x * 3  (i.e., 90) and will now fail the test  y &lt; 50 . Thus,  x  will never be altered in this algorithm. Final values are  x = 30  and  y = 90 . ### 
#########################################################
Question: 11 ### 11.  Which of the following will evaluate to true only if boolean expressions  A, B,  and  C  are all false? ### A.  !A &amp;&amp; !(B &amp;&amp; !C)   B.  !A || !B || !C   C.  !(A || B || C)   D.  !(A &amp;&amp; B &amp;&amp; C)   E.  !A || !(B || !C) ### Correct Answer:  C ### Explanation: ### In order for  !(A || B || C)  to be true,  (A || B || C)  must evaluate to false. This will happen only if  A, B , and  C  are  all  false. Choice A evaluates to true when  A  and  B  are false and  C  is true. In choice B, if any  one  of  A, B , or  C  is false, the boolean expression evaluates to true. In choice D, if any one of  A, B , or  C  is false, the boolean expression evaluates to true since we have  !(false) . All thatâs required for choice E to evaluate to true is for  A  to be false. Since  true||(any)  evaluates to true, both  B  and  C  can be either true or false. ### 
#########################################################
Question: 12 ### 12.  Assume that  a  and  b  are integers. The boolean expression   !(a &lt;= b) &amp;&amp; (a * b &gt; 0)   will always evaluate to  true  given that ### A.  a = b .  B.  a &gt; b .  C.  a &lt; b .  D.  a &gt; b  and  b &gt; 0 .  E.  a &gt; b  and  b &lt; 0 . ### Correct Answer:  D ### Explanation: ### To evaluate to  true , the expression must reduce to  true &amp;&amp; true . We therefore need  !(false) &amp;&amp; true . Choice D is the only condition that guarantees this:  a &gt; b  provides  !(false)  for the left-hand expression, and  a &gt; b  and  b &gt; 0  implies both  a  and  b  positive, which leads to  true  for the right-hand expression. Choice E, for example, will provide  true  for the right-hand expression only if  a &lt; 0 . You have no information about  a  and canât make assumptions about it. ### 
#########################################################
Question: 13 ### 1.  Given that  a, b , and  c  are integers, consider the boolean expression   (a &lt; b) || !((c == a * b) &amp;&amp; (c &lt; a))   Which of the following will guarantee that the expression is  true ? ### A.  c &lt; a  is  false .  B.  c &lt; a  is  true .  C.  a &lt; b  is  false .  D.  c == a * b  is  true .  E.  c == a * b  is  true , and  c &lt; a  is  true . ### Correct Answer:  A ### Explanation: ### If  (c &lt; a)  is  false, ((c == a*b) &amp;&amp; (c &lt; a))  evaluates to  false  irrespective of the value of  c == a*b . In this case,  !(c == a*b &amp;&amp; c &lt; a)  evaluates to  true . Then  (a &lt; b) || true  evaluates to  true  irrespective of the value of the test  (a &lt; b) . In all the other choices, the given expression  may  be  true . There is not enough information given to guarantee this, however. ### 
#########################################################
Question: 14 ### 2.  In the following code segment, you may assume that  a, b , and  n  are all type  int .  if (a != b && n / (a - b) > 90)
{
/* statement 1 */
else
{
/* statement 2 */
/* statement3 */
  What will happen if  a == b  is false? ### A.  /*    statement 1    */  will be executed.  B.  /*    statement 2    */  will be executed.  C. Either  /*    statement 1    */  or  /*    statement 2    */  will be executed.  D. A compile-time error will occur.  E. An exception will be thrown. ### Correct Answer:  C ### Explanation: ### If  a == b  is false, then  a != b  is true. Thus, the second piece of the compound test must be evaluated before the value of the whole test is known. Since  a == b  is false,  a - b  is not equal to zero. Thus, there is no division by zero, and no exception will be thrown. Also, since the relative values of  a, b , and  n  are unknown, the value of the test  n / (a - b) &gt; 90  is unknown, and there is insufficient information to determine whether the compound test is true or false. Thus, either  /*    statement 1    */  or  /*    statement 2    */  will be executed. ### 
#########################################################
Question: 15 ### 3.  Given that  n  and  count  are both of type  int , which statement is true about the following code segments?  I. for (count = 1; count <= n; count++)
System. out. println(count) ;
  II. count = 1;
while (count <= n)
System. out . println(count) ;
count++;
 ### A. I and II are exactly equivalent for all input values  n .  B. I and II are exactly equivalent for all input values  n â¥ 1 , but differ when  n â¤ 0 .  C. I and II are exactly equivalent only when  n  =  0 .  D. I and II are exactly equivalent only when  n  is even.  E. I and II are not equivalent for any input values of  n . ### Correct Answer:  A ### Explanation: ### If  n â¥ 1 , both segments will print out the integers from  1  through  n . If  n â¤ 0 , both segments will fail the test immediately and do nothing. ### 
#########################################################
Question: 16 ### 4.  The following fragment intends that a user will enter a list of positive integers at the keyboard and terminate the list with a sentinel.  int value = 0;
final int SENTINEL = - 999;
while (value != SENTINEL)
{
/ / code to process value
. . .
value = ...;
/ /read user input
}
  The fragment is not correct. Which is a true statement? ### A. The sentinel gets processed.  B. The last nonsentinel value entered in the list fails to get processed.  C. A poor choice of  SENTINEL  value causes the loop to terminate before all values have been processed.  D. The code will always process a value that is not on the list.  E. Entering the  SENTINEL  value as the first value causes a run-time error. ### Correct Answer:  D ### Explanation: ### The  (value != SENTINEL)  test occurs before a value has been read from the list. This will cause  0  to be processed, which may cause an error. The code must be fixed by reading the first value before doing the test:  final int SENTINEL = - 999;
int value = ...;
//read user input
while (value != SENTINEL)
{
/ / code to process value
value = ...;
/ /read user input
 ### 
#########################################################
Question: 17 ### 5.  Consider this code segment.  int x = 10, y = 0;
while (x> 5)
{
y = 3;
while (y ‹ x)
{
y *= 2;
if (y % x == 1)
y += x;
}
x -= 3;
}
System. out . println(x + " " + y) ;
  What will be output after execution of this code segment? ### A. did not see any text  B. 7
12  C.   D. did not see any text  E. did not see any text ### Correct Answer:  D ### Explanation: ### Here is a trace of the values of  x  and  y  during execution. Note that the condition  (y % x == 1)  is never  true  in this example.  10
7
4
y
3
6
12
3
6
12
  The  while  loop terminates when  x  is  4  since the test  while (x &gt; 5)  fails. ### 
#########################################################
Question: 18 ### 6.  Which of the following values of  num  will result in  valid  having a value of  true ? ### A.  6143   B.  6144   C.  6145   D.  6146   E.  6147 ### Correct Answer:  B ### Explanation: ### The algorithm finds the remainder when the sum of the first three digits of  n  is divided by 7. If this remainder is equal to the fourth digit,  checkDigit , the method returns  true , otherwise  false . Note that  (6+1+4) % 7  equals  4 . Thus, only choice B is a valid number. ### 
#########################################################
Question: 19 ### 7.  What is the purpose of the local variable  nRemaining ? ### A. It is not possible to separate  n  into digits without the help of a temporary variable.  B.  nRemaining  prevents the parameter  n  from being altered.  C.  nRemaining  enhances the readability of the algorithm.  D. On exiting the method, the value of  nRemaining  may be reused.  E.  nRemaining  is needed as the left-hand side operand for integer division. ### Correct Answer:  C ### Explanation: ### As  n  gets broken down into its digits,  nRemaining  is the part of  n  that remains after each digit is stripped off. Thus,  nRemaining  is a self-documenting name that helps describe what is happening. Choice A is false because every digit can be stripped off using some sequence of integer division and mod. Choice B is false because  num  is passed by value and therefore will not be altered when the method is exited. Eliminate choice D: When the method is exited, all local variables are destroyed. Choice E is nonsense. ### 
#########################################################
Question: 20 ### 8.  For ticket-selling purposes, there are three categories at a certain theater. <div class="table-responsive"><table class="table table-bordered"><tr><td> <span class="underline">Category  </td></tr><tr><td> 65 or above </td><td> Senior </td></tr><tr><td> From 18 to 64 inclusive </td><td> Adult </td></tr><tr><td> Below 18 </td><td> Child </td></tr></table>  Which of the following code segments will assign the correct string to  category  for a given integer age?  I. if (age >= 65)
category = "Senior";
if (age >= 18)
category = "Adult";
else
category = "Child";
  II. if (age >= 65)
category = "Senior"
if (18 <= age <= 64)
category = "Adult";
else
category = "Child";
  III. if (age >= 65)
category = "Senior";
else if (age >= 18)
category = "Adult";
else
category = "Child";
 ### A. I only  B. II only  C. III only  D. II and III only  E. I, II, and III ### Correct Answer:  C ### Explanation: ### Segment III works because if you enter an age of 90, say,  category  will correctly be assigned  "Senior" , and none of the other  else  pieces of code will be executed. Similarly, if you enter an age corresponding to an adult or a child, only the correct assignment is made. Segment I fails because if you enter an age of 90,  category  will be assigned  "Senior" , but then will be changed to  "Adult"  when the age passes the second test. Segment II uses incorrect syntax. The segment will work if you change the second test to   if (age &gt;= 18 &amp;&amp; age &lt;= 64) ### 
#########################################################
Question: 21 ### 9.  What output will be produced by this code segment? (Ignore spacing.)  for (int i = 5; i >= 1; i -- )
for (int j = i; j >= 1; j -- )
System.out.print(2 * j - 1);
System.out.println();
 ### A. 9
7
5
3
1
9
7
5
3
9
7
5
9
7
9
  B. 9
7
5
3
1
7
5
3
1
5
3
1
3
1
1
  C. 9
7
5
3
1
7
5
3
1 -1
5
3
1 -1 -3
3
1 -1 -3 -5
1 -1 -3 -5 -7
  D. 1
1
3
1
3
5
1
3
5
7
1
3
5
7 9
  E. 1
3
5
7
1
3
5
7
1
3
5
1
3
1
 ### Correct Answer:  B ### Explanation: ### The outer loop produces five rows of output. Each pass through the inner loop goes from  i  down to 1. Thus five odd numbers starting at 9 are printed in the first row, four odd numbers starting at 7 in the second row, and so on. You can picture what is happening in a chart.  <div class="table-responsive"><table class="table table-bordered"><tr><td>  i  </td><td>  j  </td><td class="black"> Steps </td></tr><tr><td>  5  </td><td>  5    4    3    2    1  </td><td> Print 5 odd numbers starting at 9:   9 7 5 3 1  </td></tr><tr><td>  4  </td><td>  4    3    2    1  </td><td> Print 4 odd numbers starting at 7:   7 5 3 1   Stop here! Answermust be B! </td></tr><tr><td class="border-r">  3  </td><td class="border-r">  3    .    .    .  </td><td>   </td></tr></table> ### 
#########################################################
Question: 22 ### 10.  Which of the following program fragments will produce this output? (Ignore spacing.)  2
- 4
1
1
1
6
-
8
-
10 -
1
1
- 12
1
  I. for (int i = 1; i <= 6; i++)
{
for (int k = 1; k <= 6; k++)
if (k == i)
System.out.print (2 * k) ;
else
System. out.print ("-") ;
System.out. println();
  II. for (int i = 1; i <= 6; i++)
for (int k = 1; k <= i - 1; k++)
System.out. print ("-") ;
System.out.print(2 * i);
for (int k = 1; k <= 6 - i; k++)
System.out. print ("-") ;
System.out.println();
}
  III. for (int i = 1; i <= 6; i++)
for (int k = 1; k <= i - 1; k++)
System. out. print ("-") ;
System.out.print(2 * i);
for (int k = i + 1; k <= 6; k++)
System.out.print ("-") ;
System.out.println();
}
 ### A. I only  B. II only  C. III only  D. I and II only  E. I, II, and III ### Correct Answer:  E ### Explanation: ### All three algorithms produce the given output. The outer  for (int i â¦)  loop produces six rows, and the inner  for (int k â¦)  loops produce the symbols in each row. ### 
#########################################################
Question: 23 ### 11.  Consider this program segment.  int newNum = 0, temp;
int num = k;
//k is some predefined integer value ≥ 0
while (num > 10)
{
temp = num % 10;
num /= 10;
newNum = newNum * 10 + temp;
}
System. out . print (newNum) ;
  Which is a true statement about the segment?  I. If  100 â¤ num â¤ 1000  initially, the final value of  newNum  must be in the range  10 â¤ newNum â¤ 100 .  II. There is no initial value of  num  that will cause an infinite  while  loop.  III. If  num â¤ 10  initially,  newNum  will have a final value of  0 . ### A. I only  B. II only  C. III only  D. II and III only  E. I, II, and III ### Correct Answer:  D ### Explanation: ### Statement I is false, since if  100 â¤ num â¤ 109 , the body of the  while  loop will be executed just once. (After this single pass through the loop, the value of  num  will be  10 , and the test  if (num &gt; 10)  will fail.) With just one pass,  newNum  will be a one-digit number, equal to  temp  (which was the original  num % 10) . Note that statement II is true: There cannot be an infinite loop since  num /= 10  guarantees termination of the loop. Statement III is true because if  num â¤ 10 , the loop will be skipped, and  newNum  will keep its original value of  0 . ### 
#########################################################
Question: 24 ### 12.  Consider the method  reverse .  **
Returns n with its digits reversed.
*
- Example: If n = 234, method reverse returns 432
Precondition: n > 0.
*/
int reverse (int n)
{
int rem, revNum = 0;
/* code segment */
return revNum;
7
  Which of the following replacements for  /*    code segment    */  would cause the method to work as intended?  I. for (int i = 0; i <= n; i++)
rem = n % 10;
revNum = revNum * 10 + rem;
n /= 10;
  II. while (n != 0)
{
rem = n % 10;
revNum = revNum * 10 + rem;
n /= 10;
  III. for (int i = n; i != 0; i /= 10)
}
rem = i % 10;
revNum = revNum * 10 + rem;
7
 ### A. I only  B. II only  C. I and II only  D. II and III only  E. I and III only ### Correct Answer:  D ### Explanation: ### The algorithm works by stripping off the rightmost digit of  n  (stored in  rem ), multiplying the current value of  revNum  by  10 , and adding that rightmost digit. When  n  has been stripped down to no digits (i.e.,  n == 0  is  true ),  revNum  is complete. Both segments II and III work. Segment I fails to produce the right output whenever the input value  n  has a first digit less than (number of digits ? 1). For these cases, the output has the first digit of the original number missing from the end of the returned number. ### 
#########################################################
Question: 25 ### 1.  Which of the following is a false statement about the methods? ### A.  equals, lessThan , and  toString  are all accessor methods.  B.  increment  is a mutator method.  C.  Time()  is the no-argument constructor.  D. The  Time  class has three constructors.  E. There are no static methods in this class. ### Correct Answer:  D ### Explanation: ### There are just two constructors. Constructors are recognizable by having the same name as the class, and no return type. ### 
#########################################################
Question: 26 ### 2.  Which of the following represents correct   implementation code   for the constructor with parameters? ### A. hrs = 0;
mins = 0;
secs = 0;
  B. hrs = h;
mins = m;
secs = S;
  C.  resetTime(hrs, mins, secs);   D. h = hrs;
m = mins;
s = secs ;
  E.  Time = new Time(h, m, s); ### Correct Answer:  B ### Explanation: ### Each of the private instance variables should be assigned the value of the matching parameter. Choice B is the only choice that does this. Choice D confuses the order of the assignment statements. Choice A gives the code for the  no-argument  constructor, ignoring the parameters. Choice C would be correct if it were  resetTime(h, m, s) . As written, it doesnât assign the parameter values  h, m , and  s  to  hrs, mins , and  secs . Choice E is wrong because the keyword  new  should be used to create a new object, not to implement the constructor! ### 
#########################################################
Question: 27 ### 3.  A client class has a  display  method that writes the time represented by its parameter:  **
Outputs time t in the form hrs : mins: secs.
*/
public void display (Time t)
}
/* method body */
  Which of the following are correct replacements for  /*    method body    */ ?  I. Time T = new Time (h, m, s) ;
System. out. println(T) ;
  II.  System.out.println(t.hrs + ":" + t.mins + ":" + t.secs);   III.  System.out.println(t); ### A. I only  B. II only  C. III only  D. II and III only  E. I, II, and III ### Correct Answer:  C ### Explanation: ### Replacement III will automatically print time  t  in the required form since a  toString  method was defined for the  Time  class. Replacement I is wrong because it doesnât refer to the parameter,  t , of the method. Replacement II is wrong because a client program may not access private data of the class. ### 
#########################################################
Question: 28 ### 4.  Which statement about parameters is false? ### A. The scope of parameters is the method in which they are defined.  B. Static methods have no implicit parameter  this .  C. Two overloaded methods in the same class must have parameters with different names.  D. All parameters in Java are passed by value.  E. Two different constructors in a given class can have the same number of parameters. ### Correct Answer:  C ### Explanation: ### The parameter names can be the sameâthe  signatures  must be different. For example,  public void print (int x)
/ /prints x
public void print (double x)
//prints x
  The signatures (method name plus parameter types) here are  print(int)  and  print(double) , respectively. The parameter name  x  is irrelevant. Choice A is true: All local variables and parameters go out of scope (are erased) when the method is exited. Choice B is true: Static methods apply to the whole class. Only instance methods have an implicit  this  parameter. Choice D is true even for object parameters: Their references are passed by value. Note that choice E is true because itâs possible to have two different constructors with different signatures but the same number of parameters (e.g., one for an  int  argument and one for a  double ). ### 
#########################################################
Question: 29 ### 5.  Which of the following correctly constructs a  Date  object in a client class? ### A.  Date d = new (2, 13, 1947);   B.  Date d = new Date(2, 13, 1947);   C. Date d;
d = new (2, 13, 1947) ;
  D. Date d;
d = Date (2, 13, 1947) :
  E.  Date d = Date(2, 13, 1947); ### Correct Answer:  B ### Explanation: ### Constructing an object requires the keyword  new  and a constructor of the  Date  class. Eliminate choices D and E since they omit  new . The class name  Date  should appear on the right-hand side of the assignment statement, immediately following the keyword  new . This eliminates choices A and C. ### 
#########################################################
Question: 30 ### 6.  Which of the following will cause an error message?  I. Date d1 = new Date(8, 2, 1947)
Date d2 = d1;
  II. Date d1 = null;
Date d2 = d1;
  III. Date d = null;
int x = d. year () ;
 ### A. I only  B. II only  C. III only  D. II and III only  E. I, II, and III ### Correct Answer:  C ### Explanation: ### Segment III will cause a  NullPointerException  to be thrown since  d  is a null reference. You cannot invoke a method for a null reference. Segment II has the effect of assigning  null  to both  d1  and  d2 âobscure but not incorrect. Segment I creates the object reference  d1  and then declares a second reference  d2  that refers to the same object as  d1 . ### 
#########################################################
Question: 31 ### 7.  A client program creates a  Date  object as follows.   Date d = new Date(1, 13, 2002);   Which of the following subsequent code segments will cause an error? ### A.  String s = d.toString();   B.  int x = d.day();   C.  Date e = d;   D.  Date e = new Date(1, 13, 2002);   E.  int y = d.year; ### Correct Answer:  E ### Explanation: ### A client program cannot access a private instance variable. ### 
#########################################################
Question: 32 ### 8.  Consider the implementation of a  write()  method that is added to the  Date  class.  / **
Write the date in the form m/d/y, for example 2/17/1948. * /
public void write()
}
/* implementation code */
  Which of the following could be used as  /*    implementation code    */ ?  I.  System.out.println(month + "/" + day + "/" + year);   II.  System.out.println(month() + "/" + day() + "/" + year());   III.  System.out.println(this); ### A. I only  B. II only  C. III only  D. II and III only  E. I, II, and III ### Correct Answer:  E ### Explanation: ### All are correct. Since  write()  is a  Date  instance method, it is OK to use the private data members in its implementation code. Segment III prints  this , the current  Date  object. This usage is correct since  write()  is part of the  Date  class. The  toString()  method guarantees that the date will be printed in the required format. ### 
#########################################################
Question: 33 ### 9.  Here is a client program that uses  Date  objects:  public class BirthdayStuff
{
public static Date findBirthdate()
{
/* code to get birthDate */
return birthDate;
}
public static void main(String[] args)
{
Date d = findBirthdate() ;
. ..
}
}
  Which of the following is a correct replacement for  /*    code to get    birthDate */ ?  I. System. out . println ("Enter birthdate: mo, day, yr: ") ;
int m = ...;
//read user input
int d = ...;
//read user input
int y = ...;
//read user input
Date birthDate = new Date(m, d, y) ;
  II. System. out . println ( "Enter birthdate: mo, day, yr: ") ;
int birthDate.month() = ...;
//read user input
int birthDate.day() = ...;
//read user input
int birthDate.year() = ...;
//read user input
Date birthDate = new Date(birthDate. month(), birthDate. day (),
birthDate.year()) ;
  III. System. out . println ( "Enter birthdate: mo, day, yr: ") ;
int birthDate.month = ...;
//read user input
int birthDate.day = ...;
//read user input
int birthDate.year = ...;
//read user input
Date birthDate = new Date(birthDate. month, birthDate. day,
birthDate. year) ;
 ### A. I only  B. II only  C. III only  D. I and II only  E. I and III only ### Correct Answer:  A ### Explanation: ### The idea here is to read in three separate variables for month, day, and year and then to construct the required date using  new  and the  Date  class constructor with three parameters. Code segment II wonât work because  month(), day() , and  year()  are accessor methods that access existing values and may not be used to read new values into  bDate . Segment III is wrong because it tries to access private instance variables from a client program. ### 
#########################################################
Question: 34 ### 10.  A method in a client program for the  Date  class has the following declaration.   Date d1 = new Date(mo, da, yr);   Here,  mo, da , and  yr  are previously defined integer variables. The same method now creates a second  Date  object  d2  that is an exact copy of the object  d1  refers to. Which of the following code segments will not do this correctly?  I.  Date d2 = d1;   II.  Date d2 = new Date(mo, da, yr);   III.  Date d2 = new Date(d1.month(), d1.day(), d1.year()); ### A. I only  B. II only  C. III only  D. II and III only  E. I, II, and III ### Correct Answer:  A ### Explanation: ### Segment I will not create a second object. It will simply cause  d2  to refer to the  same  object as  d1 , which is not what was required. The keyword  new   must  be used to create a new object. ### 
#########################################################
Question: 35 ### 11.  The  Date  class is modified by adding the following mutator method:  public void addYears (int n)
//add n years to date
  Here is part of a poorly coded client program that uses the  Date  class:  public static void addCentury (Date recent, Date old)
{
old.addYears(100);
recent = old;
}
public static void main(String[] args)
{
Date oldDate = new Date(1, 13, 1900);
Date recentDate = null;
addCentury(recentDate, oldDate) ;
  Which will be true after executing this code? ### A. A  NullPointerException  is thrown.  B. The  oldDate  object remains unchanged.  C.  recentDate  is a null reference.  D.  recentDate  refers to the same object as  oldDate .  E.  recentDate  refers to a separate object whose contents are the same as those of  oldDate . ### Correct Answer:  C ### Explanation: ### When  recentDate  is declared in  main() , its value is null. Recall that a method is not able to replace an object reference, so  recentDate  remains null. Note that the intent of the program is to change  recentDate  to refer to the updated  oldDate  object. The code, however, doesnât do this. Choice A is false: No methods are invoked with a null reference. Choice B is false because  addYears()  is a mutator method. Even though a method doesnât change the address of its object parameter, it can change the contents of the object, which is what happens here. Choices D and E are wrong because the  addCentury()  method cannot change the value of its  recentDate  argument. ### 
#########################################################
Question: 36 ### 1.  Here are the private instance variables for a  Frog  object:  public class Frog
{
private String species;
private int age;
private double weight;
private Position position;
//position (x,y) in pond
private boolean amAlive;
  Which of the following methods in the  Frog  class is the best candidate for being a static method? ### A. swim
//frog swims to new position in pond
  B. get PondTemperature
//returns temperature of pond
  C. eat
//frog eats and gains weight
  D. getWeight
//returns weight of frog
  E. die
//frog dies with some probability based
/ /on frog's age and pond temperature
 ### Correct Answer:  B ### Explanation: ### The method  getPondTemperature  is the only method that applies to more than one frog. It should therefore be static. All of the other methods relate directly to one particular  Frog  object. So  f.swim(), f.die(), f.getWeight() , and  f.eat()  are all reasonable methods for a single instance  f  of a  Frog . On the other hand, it doesnât make sense to say  f.getPondTemperature() . It makes more sense to say  Frog.getPondTemperature() , since the same value will apply to all frogs in the class. ### 
#########################################################
Question: 37 ### 2.  What output will be produced by this program?  public class Mystery
{
public static void strangeMethod(int x, int y)
{
x += y;
y *= x;
System.out.println(x +"" + y);
}
public static void main(String[] args)
{
int a = 6, b = 3;
strangeMethod(a, b) ;
System. out. println(a + " " + b);
}
 ### A. 36
9  B. 3
6
9  C. 9 27
9 27  D. 6 3
9 27  E. 9 27
6 3 ### Correct Answer:  E ### Explanation: ### Here are the memory slots at the start of  strangeMethod(a, b) :  a
b
6
3
x
y
6
3
  Before exiting  strangeMethod(a, b) :  a
b
6
3
X
y
9
27
  Note that  9 27  is output before exiting. After exiting  strangeMethod(a, b) , the memory slots are  a
b
6
3
  The next step outputs  6 3 . ### 
#########################################################
Question: 38 ### 3.  The method  reduce()  is not a public method because ### A. methods whose return type is  void  cannot be public.  B. methods that change  this  cannot be public.  C. the  reduce()  method is not intended for use by objects outside the  Rational  class.  D. the  reduce()  method is intended for use only by objects outside the  Rational  class.  E. the  reduce()  method uses only the private data fields of the  Rational  class. ### Correct Answer:  C ### Explanation: ### The  reduce()  method will be used only in the implementation of the instance methods of the  Rational  class. Itâs a private helper method. ### 
#########################################################
Question: 39 ### 4.  The constructors in the  Rational  class allow initialization of  Rational  objects in several different ways. Which of the following will cause an error? ### A.  Rational r1 = new Rational();   B.  Rational r2 = r1;   C.  Rational r3 = new Rational(2,-3);   D.  Rational r4 = new Rational(3.5);   E.  Rational r5 = new Rational(10); ### Correct Answer:  D ### Explanation: ### None of the constructors in the  Rational  class takes a real-valued parameter. Thus, the real-valued parameter in choice D will need to be converted to an integer. Since in general truncating a real value to an integer involves a loss of precision, it is not done automaticallyâyou have to do it explicitly with a cast. Omitting the cast causes a compile-time error. ### 
#########################################################
Question: 40 ### 5.  Here is the implementation code for the  plus  method:  / ** Returns (this + r) . Leaves this unchanged.
*/
public Rational plus(Rational r)
{
fixSigns ();
r.fixSigns ();
int denom = denominator * r.denominator;
int numer = numerator * r.denominator
+ r.numerator * denominator;
/* more code */
ـد
  Which of the following is a correct replacement for  /*    more code    */ ? ### A. Rational rat (numer, denom)
rat.reduce () ;
return rat;
  B.  return new Rational(numer, denom);   C. reduce () ;
Rational rat = new Rational (numer, denom) ;
return rat;
  D. Rational rat = new Rational (numer, denom) ;
Rational.reduce () ;
return rat;
  E. Rational rat = new Rational (numer, denom) ;
rat . reduce () ;
return rat ;
 ### Correct Answer:  E ### Explanation: ### A new  Rational  object must be created using the newly calculated  numer  and  denom . Then it must be reduced before being returned. Choice A is wrong because it doesnât correctly create the new object. Choice B returns a correctly constructed object, but one that has not been reduced. Choice C reduces the current object,  this , instead of the new object,  rat . Choice D is wrong because it invokes  reduce()  for the  Rational  class instead of the specific  rat  object. ### 
#########################################################
Question: 41 ### 6.  Assume these declarations:  Rational a = new Rational () ;
Rational r = new Rational (numer, denom) ;
int n = value;
/ /numer, denom, and value are valid integer values
  Which of the following will cause a compile-time error? ### A.  r = a.plus(r);   B.  a = r.plus(new Rational(n));   C.  r = r.plus(r);   D.  a = n.plus(r);   E.  r = r.plus(new Rational(n)); ### Correct Answer:  D ### Explanation: ### The  plus  method of the  Rational  class can only be invoked by  Rational  objects. Since  n  is an  int , the statement in choice D will cause an error. ### 
#########################################################
Question: 42 ### 7.  A client method contains this code segment:  Temperature t1 = new Temperature (40, "C") ;
Temperature t2 = t1;
Temperature t3 = t2.lower(20) ;
Temperature t4 = t1. toFahrenheit ();
  Which statement is true following execution of this segment? ### A.  t1, t2, t3 , and  t4  all represent the identical temperature, in degrees Celsius.  B.  t1, t2, t3 , and  t4  all represent the identical temperature, in degrees Fahrenheit.  C.  t4  represents a Fahrenheit temperature, while  t1, t2 , and  t3  all represent degrees Celsius.  D.  t1  and  t2  refer to the same  Temperature  object;  t3  refers to a  Temperature  object that is 20 degrees lower than  t1  and  t2 , while  t4  refers to an object that is  t1  converted to Fahrenheit.  E. A  NullPointerException  was thrown. ### Correct Answer:  B ### Explanation: ### This is an example of  aliasing . The keyword  new  is used just once, which means that just one object is constructed. Here are the memory slots after each declaration:  Temperature
t1
Temperature
t1
scale
"C"
"C"
t2
scale
degrees
40
degrees
40
After declaration for t 1
After declaration for t2
t1
t1
Temperature
t2
Temperature
t2
scale
t3
scale
"F"
t3
degrees
20
degrees
68
t4
After declaration for t3
After declaration for t4
After
ifort4
 ### 
#########################################################
Question: 43 ### 8.  Consider the following code.  public class TempTest
{
public static void main(String[] args)
{
System. out. println ("Enter temperature scale: ");
String tempScale = ...;
//read user input
System. out. println("Enter number of degrees: ");
double tempDegrees = . . . ;
//read user input
/* code to construct a valid temperature from user input */
}
  Which is the best replacement for  /*    code to constructâ¦    */ ? ### A.  Temperature t = new Temperature(tempDegrees, tempScale);   B. Temperature t = new Temperature (tempDegrees, tempScale);
if (Temperature. isNotValidTemp(tempDegrees, tempScale))
/* error message and exit program */
  C. Temperature t = new Temperature (tempDegrees, tempScale)
if (!t. isValidTemp(tempDegrees, tempScale))
/* error message and exit program */
  D. if (isValidTemp (tempDegrees, tempScale) )
Temperature t = new Temperature (tempDegrees, tempScale) ;
else
/* error message and exit program */
  E. if (Temperature. isValidTemp (tempDegrees, tempScale) )
Temperature t = new Temperature (tempDegrees, tempScale)
else
/* error message and exit program */
 ### Correct Answer:  E ### Explanation: ### Notice that  isValidTemp  is a static method for the  Temperature  class, which means that it should be invoked with the class name,  Temperature , as in choice E. The method should not be invoked with  t , a  Temperature  object, as is done in choice C. (Even though  t.isValidTemp  may work, its use is discouraged. A good compiler will give you a warning.) Choice A is not a good choice because it is not robust: It allows the program to proceed with data that may be invalid. Choice B fails because it uses  isNotValidTemp , a method that is not in the program. Choice D fails because  isValidTemp  is not a method of the  TempTest  class. ### 
#########################################################
Question: 44 ### 9.  The formula to convert degrees Celsius  C  to Fahrenheit  F  is  F = 1.8C + 32  For example, 30 Â°  C is equivalent to 86 Â°  F.  An  inFahrenheit()  accessor method is added to the  Temperature  class. Here is its implementation:  ** Returns an equivalent temperature in degrees Fahrenheit.
*
Precondition: The temperature is a valid temperature
in degrees Celsius.
Postcondition:
- An equivalent temperature in degrees Fahrenheit has been
returned.
- Original temperature remains unchanged.
*/
public Temperature inFahrenheit ()
{
Temperature result;
/* more code */
return result;
  Which of the following correctly replaces  /*    more code    */  so that the postcondition is achieved?  I.  result = new Temperature(degrees * 1.8 + 32, "F");   II. result = new Temperature (degrees * 1.8, "F");
result = result.raise(32) ;
  III. degrees *= 1.8;
this = this.raise(32);
result = new Temperature(degrees, "F") ;
 ### A. I only  B. II only  C. III only  D. I and II only  E. I, II, and III ### Correct Answer:  D ### Explanation: ### A new  Temperature  object must be constructed to prevent the current  Temperature  from being changed. Segment I, which applies the conversion formula directly to  degrees , is the best way to do this. Segment II, while not the best algorithm, does work. The statement   result = result.raise(32);   has the effect of raising the  result  temperature by 32 degrees, and completing the conversion. Segment III fails because   degrees *= 1.8;   alters the  degrees  instance variable of the current object, as does   this = this.raise(32);   To be correct, these operations must be applied to the  result  object. ### 
#########################################################
Question: 45 ### 10.  Consider this program.  public class CountStuff
{
public static void doSomething()
{
int count = 0;
/ /code to do something - no screen output produced
count++;
3
public static void main(String[] args)
{
int count = 0;
System. out . println ("How many iterations?");
int n = ...;
//read user input
for (int i = 1; i <= n; i++)
{
doSomething();
System. out. println(count);
}
}
  If the input value for  n  is  3 , what screen output will this program subsequently produce? ### A. did not see any text  B. did not see any text  C. 3
3  D. did not see any text<br/>where  ?  is some undefined value.  E. No output will be produced. ### Correct Answer:  A ### Explanation: ### This is a question about the scope of variables. The scope of the  count  variable that is declared in  main()  extends up to the closing brace of  main() . In  doSomething(), count  is a local variable. After the method call in the  for  loop, the local variable  count  goes out of scope, and the value thatâs being printed is the value of the  count  in  main() , which is unchanged from  0 . ### 
#########################################################
Question: 46 ### 11.  This question refers to the following class.  public class IntObject
{
private int num;
public IntObject ()
/ / constructor
{ num = 0; }
public IntObject (int n) //constructor
{ num = n; }
public void increment () //increment by 1
{ num++; }
  Here is a client program that uses this class:  public class IntObjectTest
{
public static IntObject someMethod(IntObject obj)
{
IntObject ans = obj;
ans.increment ();
return ans;
}
public static void main(String[] args)
{
IntObject x = new IntObject(2);
IntObject y = new IntObject(7);
IntObject a = y;
x= someMethod(y) ;
a = someMethod(x) ;
}
}
  Just before exiting this program, what are the object values of  x, y , and  a , respectively? ### A.  9, 9, 9   B.  2, 9, 9   C.  2, 8, 9   D.  3, 8, 9   E.  7, 8, 9 ### Correct Answer:  A ### Explanation: ### Here are the memory slots before the first  someMethod  call:  y
x
IntObject
IntObject
num
2
a
num
7
  Just before exiting  x = someMethod(y) :  y
a
IntObject
IntObject
x
num
obj
2
num
8
>
ans
  After exiting   x = someMethod(y);    x  has been reassigned, so the object with  num = 2  has been recycled:  y
IntObject
a
num
8
X
  After exiting  a = someMethod(x) :  y
IntObject
a
num
9
X
 ### 
#########################################################
Question: 47 ### 12.  Consider the following program.  public class Tester
{
public void someMethod(int a, int b)
int temp = a;
a = b;
b = temp;
}
}
public class TesterMain
{
public static void main(String[] args)
{
int x= 6, y = 8;
Tester tester = new Tester();
tester. someMethod(x, y) ;
}
  Just before the end of execution of this program, what are the values of  x, y , and  temp , respectively? ### A.  6, 8, 6   B.  8, 6, 6   C.  6, 8, ? , where  ?  means undefined  D.  8, 6, ? , where  ?  means undefined  E.  8, 6, 8 ### Correct Answer:  C ### Explanation: ### Recall that when primitive types are passed as parameters, copies are made of the actual arguments. All manipulations in the method are performed on the copies, and the arguments remain unchanged. Thus  x  and  y  retain their values of  6  and  8 . The local variable  temp  goes out of scope as soon as  someMethod  is exited and is therefore undefined just before the end of execution of the program. ### 
#########################################################
Question: 48 ### 1.  Of the methods shown, how many different nonconstructor methods can be invoked by a  SavingsAccount  object? ### A. 1  B. 2  C. 3  D. 4  E. 5 ### Correct Answer:  D ### Explanation: ### The methods are  deposit, withdraw , and  getBalance , all inherited from the  BankAccount  class, plus  addInterest , which was defined just for the class  SavingsAccount . ### 
#########################################################
Question: 49 ### 2.  Which of the following correctly implements the no-argument constructor of the  SavingsAccount  class?  I. interestRate = 0;
super () ;
  II. super () ;
interestRate = 0;
  III.  super(); ### A. II only  B. I and II only  C. II and III only  D. III only  E. I, II, and III ### Correct Answer:  C ### Explanation: ### Implementation I fails because  super()   must  be the first line of the implementation whenever it is used in a constructor. Implementation III may appear to be incorrect because it doesnât initialize  interestRate . Since  interestRate , however, is a primitive typeâ double âthe compiler will provide a default initialization of  0 , which was required. ### 
#########################################################
Question: 50 ### 3.  Which is a correct implementation of the constructor with parameters in the  SavingsAccount  class? ### A. balance = acctBalance
interestRate = rate;
  B. getBalance () = acctBalance;
interestRate = rate;
  C. super () ;
interestRate = rate;
  D. super (acct Balance) ;
interestRate = rate;
  E.  super(acctBalance, rate); ### Correct Answer:  D ### Explanation: ### First, the statement  super(acctBalance)  initializes the inherited private variable  balance  as for the  BankAccount  superclass. Then the statement  interestRate = rate  initializes  interestRate , which belongs uniquely to the  SavingsAccount  class. Choice E fails because  interestRate  does not belong to the  BankAccount  class and therefore cannot be initialized by a  super  method. Choice A is wrong because the  SavingsAccount  class cannot directly access the private instance variables of its superclass. Choice B assigns a value to an accessor method, which is meaningless. Choice C is incorrect because  super()  invokes the no-argument constructor of the superclass. This will cause  balance  of the  SavingsAccount  object to be initialized to  0 , rather than  acctBalance , the parameter value. ### 
#########################################################
Question: 51 ### 4.  Which is a correct implementation of the  CheckingAccount  constructor?  I.  super(acctBalance);   II. super () ;
deposit (acctBalance) ;
  III.  deposit(acctBalance); ### A. I only  B. II only  C. III only  D. II and III only  E. I, II, and III ### Correct Answer:  E ### Explanation: ### The constructor must initialize the inherited instance variable  balance  to the value of the  acctBalance  parameter. All three segments achieve this. Implementation I does it by invoking  super(acctBalance) , the constructor in the superclass. Implementation II first initializes  balance  to  0  by invoking the no-argument constructor of the superclass. Then it calls the inherited  deposit  method of the superclass to add  acctBalance  to the account. Implementation III works because  super()  is automatically called as the first line of the constructor code if there is no explicit call to  super . ### 
#########################################################
Question: 52 ### 5.  Which is correct implementation code for the  withdraw  method in the  CheckingAccount  class? ### A. super . withdraw (amount) ;
if (balance < MIN_BALANCE)
super. withdraw(FEE) ;
  B. withdraw (amount) ;
if (balance < MIN_BALANCE)
withdraw(FEE) ;
  C. super . withdraw (amount) ;
if (getBalance () < MIN_BALANCE)
super. withdraw(FEE) ;
  D. withdraw (amount) ;
if (getBalance() < MIN_BALANCE)
withdraw(FEE) ;
  E. balance -= amount ;
if (balance < MIN_BALANCE)
balance -= FEE;
 ### Correct Answer:  C ### Explanation: ### First the  withdraw  method of the  BankAccount  superclass is used to withdraw  amount . A prefix of  super  must be used to invoke this method, which eliminates choices B and D. Then the balance must be tested using the accessor method  getBalance , which is inherited. You canât test  balance  directly since it is private to the  BankAccount  class. This eliminates choices A and E, and provides another reason for eliminating choice B. ### 
#########################################################
Question: 53 ### 6.  Redefining the  withdraw  method in the  CheckingAccount  class is an example of ### A. method overloading.  B. method overriding.  C. downcasting.  D. dynamic binding (late binding).  E. static binding (early binding). ### Correct Answer:  B ### Explanation: ### When a superclass method is redefined in a subclass, the process is called  method overriding . Which method to call is determined at run time. This is called  dynamic binding  (p. 147).  Method overloading  is two or more methods with different signatures in the same class (p. 106). The compiler recognizes at compile time which method to call. This is  early binding . The process of  downcasting  is unrelated to these principles (p. 150). ### 
#########################################################
Question: 54 ### 7.  A program to test the  BankAccount, SavingsAccount , and  CheckingAccount  classes has these declarations:   BankAccount b = new BankAccount(1400);    BankAccount s = new SavingsAccount(1000, 0.04);    BankAccount c = new CheckingAccount(500);   Which method call will cause an error? ### A.  b.deposit(200);   B.  s.withdraw(500);   C.  c.withdraw(500);   D.  s.deposit(10000);   E.  s.addInterest(); ### Correct Answer:  E ### Explanation: ### The  addInterest  method is defined only in the  SavingsAccount  class. It therefore cannot be invoked by a  BankAccount  object. The error can be fixed by casting  s  to the correct type:   ((SavingsAccount) s).addInterest();   The other method calls do not cause a problem because  withdraw  and  deposit  are both methods of the  BankAccount  class. ### 
#########################################################
Question: 55 ### 8.  A program to test the  BankAccount, SavingsAccount , and  CheckingAccount  classes has these declarations:   BankAccount b = new BankAccount(1400);    BankAccount s = new SavingsAccount(1000, 0.04);    BankAccount c = new CheckingAccount(500);   In order to test polymorphism, which method must be used in the program? ### A. Either a  SavingsAccount  constructor or a  CheckingAccount  constructor  B.  addInterest   C.  deposit   D.  withdraw   E.  getBalance ### Correct Answer:  D ### Explanation: ### The  withdraw  method is the only method that has one implementation in the superclass and a  different  implementation in a subclass. Polymorphism is the mechanism of selecting the correct method from the different possibilities in the class hierarchy. Notice that the  deposit  method, for example, is available to objects of all three bank account classes, but itâs the  same  code in all three cases. So polymorphism isnât tested. ### 
#########################################################
Question: 56 ### 9.  A new method is added to the  BankAccount  class.  ** Transfer amount from this BankAccount to another BankAccount
* Precondition: balance > amount
* @param another a different BankAccount object
*
@param amount the amount to be transferred
*/
public void transfer (BankAccount another, double amount)
{
withdraw(amount) ;
another.deposit (amount) ;
  A program has these declarations:   BankAccount b = new BankAccount(650);    SavingsAccount timsSavings = new SavingsAccount(1500, 0.03);    CheckingAccount daynasChecking = new CheckingAccount(2000);   Which of the following will transfer money from one account to another without error?  I.  b.transfer(timsSavings, 50);   II.  timsSavings.transfer(daynasChecking, 30);   III.  daynasChecking.transfer(b, 55); ### A. I only  B. II only  C. III only  D. I, II, and III  E. None ### Correct Answer:  D ### Explanation: ### It is OK to use  timsSavings  and  daynasChecking  as parameters since each of these  is-a   BankAccount  object. It is also OK for  timsSavings  and  daynasChecking  to call the  transfer  method (statements II and III), since they inherit this method from the  BankAccount  superclass. ### 
#########################################################
Question: 57 ### 10.  Consider these class declarations.  public class Person
.. .
}
public class Teacher extends Person
. . .
  Which is a true statement?  I.  Teacher  inherits the constructors of  Person .  II.  Teacher  can add new methods and private instance variables.  III.  Teacher  can override existing private methods of  Person . ### A. I only  B. II only  C. III only  D. I and II only  E. II and III only ### Correct Answer:  B ### Explanation: ### Statement I is false: A subclass must specify its own constructors. Otherwise the compiler will generate a default constructor that calls the no-argument constructor of the superclass. Note that statement III is false: Private instance methods cannot be overridden. ### 
#########################################################
Question: 58 ### 1.  Which statement about subclass methods is false? ### A. Writing two subclass methods with the same name but different parameters is called method overriding.  B. A public method in a subclass that is not in its superclass is not accessible by the superclass.  C. A private method in a superclass is not inherited by its subclass.  D. Two different subclasses of the same superclass inherit the same methods of the superclass.  E. If  Class1  is a superclass of  Class2 , and  Class2  is a superclass of  Class3 , and  Class2  has no overridden methods,  Class3  inherits all the public methods of  Class1 . ### Correct Answer:  A ### Explanation: ### What is described in choice A is an example of overloaded methods. A key point is that one method is in the same class as the other method, and therefore cannot be an overridden method. An overridden method in a subclass has the same header as a method in its superclass, but different implementation. ### 
#########################################################
Question: 59 ### 2.  Consider a program to manipulate digital images. The inheritance hierarchy is as follows.  DigitalPicture
Picture
Landscape
Portrait
  You may assume that  DigitalPicture  and  Picture  have no-argument constructors, but that  Landscape  and  Portrait  do not have any constructors. Which of the following declarations will compile?  I.  DigitalPicture p = new Portrait();   II.  Landscape p = new Picture();   III.  DigitalPicture p = new DigitalPicture(); ### A. I only  B. II only  C. III only  D. I and II only  E. I and III only ### Correct Answer:  E ### Explanation: ### Declaration I works because a  Portrait   is-a   DigitalPicture , and the compiler will generate a default constructor from  Picture , its superclass. Declaration II fails because a  Picture  is  not  a  Landscape . Declaration III works because  DigitalPicture   is-a   DigitalPicture . ### 
#########################################################
Question: 60 ### 3.  Consider the following hierarchy of classes.  Bird
Parrot
Owl
Parakeet
  A program is written to print data about various birds:  public class BirdStuff
{
public static void printName(Bird b)
{ /* implementation not shown */ }
public static void printBirdCall (Parrot p)
{ /* implementation not shown */ }
//several more Bird methods
public static void main(String[] args)
{
Bird bird1 = new Bird();
Bird bird2 = new Parrot();
Parrot parrot1 = new Parrot();
Parrot parrot2 = new Parakeet () ;
/* more code */
}
7
  Assuming that all of the given classes have no-argument constructors, which of the following segments of  /*    more code    */  will cause an error? ### A.  printBirdCall(bird2);   B.  printName(parrot2);   C.  printName(bird2);   D.  printBirdCall(parrot2);   E.  printBirdCall(parrot1); ### Correct Answer:  A ### Explanation: ### There is a quick test you can do to find the answer to this question: Test the  is-a  relationshipânamely, the parameter for  printName   is-a   Bird ? and the parameter for  printBirdCall   is-a   Parrot ? Note that to get the type of the actual parameter, you must look at its left-hand-side declaration. Choice A fails the test:  bird2   is-a   Parrot ? The variable  bird2  is declared a  Bird , which is not necessarily a  Parrot . Each other choice passes the test: Choice B:  parrot2   is-a   Bird . Choice C:  bird2   is-a   Bird . Choice D:  parrot2   is-a   Parrot . Choice E:  parrot1   is-a   Parrot . ### 
#########################################################
Question: 61 ### 4.  The  method1  method in  ClassB  is an example of ### A. method overloading.  B. method overriding.  C. polymorphism.  D. data encapsulation.  E. procedural abstraction. ### Correct Answer:  B ### Explanation: ### Method overriding occurs whenever a method in a superclass is redefined in a subclass. Method overloading is a method in the same class that has the same name but different parameter types. Polymorphism is when the correct overridden method is called for a particular subclass object during run time. Data encapsulation is when data and methods of an object are combined in a class so that the data can be hidden. Procedural abstraction is using separate methods to encapsulate each task in a class. ### 
#########################################################
Question: 62 ### 5.  Consider the following declarations in a client class.   ClassA ob1 = new ClassA();    ClassA ob2 = new ClassB();    ClassB ob3 = new ClassB();   Which of the following method calls will cause an error?  I.  ob1.method3();   II.  ob2.method3();   III.  ob3.method2(); ### A. I only  B. II only  C. III only  D. I and II only  E. I, II, and III ### Correct Answer:  D ### Explanation: ### Both method calls I and II will cause errors.  I: An object of a superclass does not have access to a new method of its subclass.  II:  ob2  is declared to be of type  ClassA , so a compile-time error will occur with a message indicating that there is no  method2  in  ClassA . Casting  ob2  to  ClassB  would correct the problem. (Note: Class casting is no longer included in the AP Java subset.)  III is correct because a subclass inherits all the public methods of its superclass. ### 
#########################################################
Question: 63 ### 6.  A program that tests these classes has the following declarations and assignments:   Solid s1, s2, s3, s4;    s1 = new Solid("blob");    s2 = new Sphere("sphere", 3.8);    s3 = new RectangularPrism("box", 2, 4, 6.5);    s4 = null;   How many of the above lines of code are incorrect? ### A. 0  B. 1  C. 2  D. 3  E. 4 ### Correct Answer:  A ### Explanation: ### All are correct! They all pass the  is-a  test: (a  Solid   is-a   Solid , a  Sphere   is-a   Solid , a  RectangularPrism   is-a   Solid) ; and the parameters all match the constructors. Note that the default value for  s4  is  null , so the assignment  s4 = null  is redundant (but correct). ### 
#########################################################
Question: 64 ### 7.  Here is a program that prints the volume of a solid:  public class SolidMain
{
/ ** Output volume of Solid s. * /
public static void print Volume(Solid s)
{
System. out . println ("Volume = " + s. volume () +
" cubic units");
}
public static void main(String[] args)
Solid sol;
Solid sph = new Sphere("sphere", 4) ;
Solid rec = new RectangularPrism("box", 3, 6, 9);
int flipCoin = (int) (Math.random()*2);
//0 or 1
if (flipCoin == 0)
sol = sph;
else
sol = rec;
print Volume(sol) ;
}
  Which is a true statement about this program? ### A. It will output the volume of the sphere or box, as intended.  B. It will output the volume of the default  Solid s , which is neither a sphere nor a box.  C. It will randomly print the volume of a sphere or a box.  D. A run-time error will occur because it is not specified whether  s  is a sphere or a box.  E. A run-time error will occur because of parameter type mismatch in the method call  printVolume(sol) . ### Correct Answer:  A ### Explanation: ### This is an example of polymorphism: The correct  volume  method is selected at run time. The parameter expected for  printVolume  is a  Solid  reference, which is what it gets in  main() . The reference  sol  will refer either to a  Sphere  or a  RectangularPrism  object depending on the outcome of the coin flip. Since a  Sphere  is a  Solid  and a  RectangularPrism  is a  Solid , there will be no type mismatch when these are the actual parameters in the  printVolume  method. (Note: The  Math.random  method is discussed in Chapter 5.) ### 
#########################################################
Question: 65 ### 8.  Consider these class declarations.  public class Player
{
public Player ()
{ /* implementation not shown */ }
public int getMove()
{ /* implementation not shown */ }
//Other constructors and methods not shown
}
public class ExpertPlayer extends Player
public int compareTo (ExpertPlayer expert)
{ /* implementation not shown */ }
//Constructors and other methods not shown.
ـلـ
  Which code segment in a client program will cause an error?  I. Player p1 = new ExpertPlayer ();
int x1 = p1.getMove();
  II. int x;
ExpertPlayer c1 = new ExpertPlayer () ;
ExpertPlayer c2 = new ExpertPlayer();
if (c1.compareTo(c2) < 0)
x = c1. getMove () ;
else
x = c2.getMove ();
  III. int x;
Player h1 = new ExpertPlayer ();
Player h2 = new ExpertPlayer () ;
if (h1.compareTo(h2) < 0)
x = h1.getMove();
else
x = h2. getMove ();
 ### A. I only  B. II only  C. III only  D. I and II only  E. I, II, and III ### Correct Answer:  C ### Explanation: ### Segment III wonât work because  Player  doesnât have a  compareTo  method. The method call  h1.compareToâ¦  will cause a compile-time error. Also, the  compareTo  method requires an  ExpertPlayer  parameter, but  h2  is a  Player , which isnât necessarily an  ExpertPlayer . Segment II avoids both of these pitfalls. Segment I works because the  Player  class has a  getMove  method. ### 
#########################################################
Question: 66 ### 9.  Consider the following class definitions.  public class Animal
{
private String type;
public Animal (String theType)
{
type = theType;
}
public String getType()
{
return type;
}
public class Dog extends Animal
{
public Dog(String theType)
{
super (theType) ;
}
}
  The following code segment appears in a class other than  Animal  or  Dog .  Animal d1 = new Animal ("poodle") ;
Animal d2 = new Dog("shnauzer") ;
Dog d3 = new Dog("yorkie") ;
public static void display(Animal a)
{
System. out. println("This dog is a " + a. getType () ; )
}
  Which of the following method calls will compile without error?  I.  display(d1);   II.  display(d2);   III.  display(d3); ### A. I only  B. II only  C. III only  D. I and II only  E. I, II, and III ### Correct Answer:  E ### Explanation: ### All compile without error. For the method call  display(arg) , the compiler checks that the parameter  arg   is-a   Animal , the type in the methodâs signature. Each of the objects  d1, d2 , and  d3  passes the  is-a  test. ### 
#########################################################
Question: 67 ### 10.  Consider the following class definitions.  public class StrStuff1
{
public void printSub(String str)
{
String s = str.substring(2) ;
System.out.print (s) ;
}
}
public class StrStuff2 extends StrStuff1
{
public void printSub(String str)
{
String s = str.substring(1) ;
super.printSub(s);
System.out.print (s);
}
  The following code segment appears in a class other than  StrStuff1  and  StrStuff2 .   StrStuff1 p = new StrStuff2();    p.printSub("crab");   What is printed as a result of executing the code segment? ### A.  crabab   B.  brab   C.  rabb   D.  abb   E.  ab ### Correct Answer:  B ### Explanation: ### Since the actual type of  p  is  StrStuff2 , the  printSub  method of  StrStuff2 , the subclass, will be called first. This is polymorphism, which calls the method of the actual object during run time. The  String s  is set equal to  "rab" , and the  printSub  method of the superclass,  StrStuff1 , will be called, namely  printSub("rab") . This gets the substring of  "rab"  starting at position 2, which is  "b" . Then  "b"  is printed. At this point, only  "b"  has been printed. But recall that execution of the subclass method was halted for  super.printSub(s) , so this method must now be completed by executing  System.out.print("rab") .  Whew!  To recap, here is the order of execution of the statements:  â  Set local  String s  to  "rab" .  â  Call the superclass  printSub("rab") .  â  Set local  s  variable in superclass method to  "b" .  â  Print  "b" .  â  Print the value of  s  in the subclass methodânamely,  "rab" .  â  So, the output is  "brab" . ### 
#########################################################
Question: 68 ### 11.  Consider the following class definitions.  public class Class1
{
public void doSomething(int n)
n -= 4;
System.out.print (n) ;
}
}
public class Class2 extends Class1
public void doSomething(int n)
{
super.doSomething(n + 3);
n *= 2;
System.out.print (n);
}
}
  The following code segment appears in a class other than  Class1  and  Class2 .   Class1 c = new Class2();    c.doSomething(8);   What is printed as a result of executing the code segment? ### A.  416   B.  422   C.  714   D.  716   E.  722 ### Correct Answer:  D ### Explanation: ### As in the previous question, the method in the subclass will be executed first. Here is the order of execution of the statements:  â   super.doSomething(11)   â   n  is set equal to  7 .  â  Print  7 .  â  Go back to finish  doSomething  in  Class2 . (Note that the parameter in this method is  8 .)  â   n  is set equal to  16 .  â  Print  16 .  Therefore, what gets printed is  716 . ### 
#########################################################
Question: 69 ### 1.  Consider the following declarations in a program to find the quantity  base exp  .  double base = < a double value >
double exp = < a double value>
/* code to find power, which equals baseexp
*
  Which is a correct replacement for   /*    code to find    power ,   which equals    base exp  */?   I. double power;
Math m = new Math();
power = m. pow (base, exp) ;
  II. double power;
power = Math. pow (base, exp) ;
  III. int power;
power = Math. pow (base, exp) ;
 ### A. I only  B. II only  C. III only  D. I and II only  E. I and III only ### Correct Answer:  B ### Explanation: ### All the  Math  class methods are static methods, which means you canât use a  Math  object that calls the method. The method is invoked using the class name,  Math , followed by the dot operator. Thus segment II is correct, and segment I is incorrect. Segment III will cause an error: Since the parameters of  pow  are of type  double , the result should be stored in a  double . ### 
#########################################################
Question: 70 ### 2.  Consider the  squareRoot  method defined below.  **
Returns a Double whose value is the square root
*
of the value represented by d.
*/
public Double squareRoot (Double d)
{
/* implementation code */
  Which  /*    implementation code    */  satisfies the postcondition?  I. double x = d;
x = Math.sqrt (x);
return x;
  II.  return new Double(Math.sqrt(d.doubleValue()));   III.  return Double(Math.sqrt(d.doubleValue())); ### A. I only  B. I and II only  C. I and III only  D. II and III only  E. I, II, and III ### Correct Answer:  B ### Explanation: ### The  Math.sqrt  method must be invoked on a primitive type  double , but auto-unboxing takes care of that in the line   double x = d;   The return type of the method is  Double , and autoboxing takes care of that in the statement   return x;   Segment III fails because you canât use the  Double  constructor to create a new object without using the keyword  new . ### 
#########################################################
Question: 71 ### 3.  Here are some examples of negative numbers rounded to the nearest integer: <div class="table-responsive"><table class="table table-bordered"><tr><td> <span class="underline">Negative real number  </td><td> <span class="underline">Rounded to nearest integer  </td></tr><tr><td> -3.5 </td><td> -4 </td></tr><tr><td> -8.97 </td><td> -9 </td></tr><tr><td> -5.0 </td><td> -5 </td></tr><tr><td> -2.487 </td><td> -2 </td></tr><tr><td> -0.2 </td><td> 0 </td></tr></table>  Refer to the following declaration.   double d = -4.67;   Which of the following correctly rounds  d  to the nearest integer? ### A.  int rounded = Math.abs(d);   B.  int rounded = (int) (Math.random() * d);   C.  int rounded = (int) (d - 0.5);   D.  int rounded = (int) (d + 0.5);   E.  int rounded = Math.abs((int) (d - 0.5)); ### Correct Answer:  C ### Explanation: ### The value -4.67 must be rounded to -5. Subtracting 0.5 gives a value of -5.17. Casting to  int  truncates the number (chops off the decimal part) and leaves a value of -5. None of the other choices produces -5. Choice A gives the absolute value of  d : 4.67. Choice B is an incorrect use of  Random . The parameter for  nextInt  should be an integer  n, n  â¥ 2. The method then returns a random  int   k , where 0 â¤  k  &lt;  n . Choice D is the way to round a  positive  real number to the nearest integer. In the actual case it produces -4. Choice E gives the absolute value of -5ânamely, 5. ### 
#########################################################
Question: 72 ### 4.  A program is to simulate plant life under harsh conditions. In the program, plants die randomly according to some probability. Here is part of a  Plant  class defined in the program:  public class Plant
{
/ ** Probability that plant dies is a real number between 0 and 1. * /
private double probDeath;
public Plant (double plantProbDeath, < other parameters >)
{
probDeath = plantProbDeath;
< initialization of other instance variables >
/ ** Plant lives or dies. * /
public void liveOrDie()
{
/* statement to generate random number */
if (/* test to determine if plant dies */)
< code to implement plant's death >
else
< code to make plant continue living >
}
//Other variables and methods are not shown.
  Which of the following are correct replacements for  (1)  /*    statement to generate random number    */  and  (2)  /*    test to determine if plant dies    */ ? ### A. (1) double x = Math. random ();
(2) x == probDeath
  B. (1) double x = (int) (Math. random ()) ;
(2) x > probDeath
  C. (1) double x = Math. random () ;
(2) x < probDeath
  D. (1) int x = (int) (Math.random() * 100) ;
(2) x < (int) probDeath
  E. (1) int x = (int) (Math. random() * 100) + 1;
(2) x == (int) probDeath
 ### Correct Answer:  C ### Explanation: ### The statement  double x = Math.random();  generates a random  double  in the range 0 â¤  x  &lt; 1. Suppose  probDeath  is 0.67, or 67%. Assuming that random doubles are uniformly distributed in the interval, one can expect that 67% of the time  x  will be in the range 0 â¤  x  &lt; 0.67. You can therefore simulate the probability of death by testing if  x  is between 0 and 0.67, that is, if  x  &lt; 0.67. Thus,  x &lt; probDeath  is the desired condition for plant death, eliminating choices A and B. Choices D and E fail because  (int) probDeath  truncates  probDeath  to 0. The test  x &lt; 0  will always be false, and the test  x == 0  will only be true if the random number generator returned exactly 0, an extremely unlikely occurrence! Neither of these choices correctly simulates the probability of death. ### 
#########################################################
Question: 73 ### 5.  A program simulates 50 slips of paper, numbered 1 through 50, placed in a bowl for a raffle drawing. Which of the following statements stores in  winner  a random integer from 1 to 50? ### A.  int winner = (int) (Math.random() * 50) + 1;   B.  int winner = (int) (Math.random() * 50);   C.  int winner = (int) (Math.random() * 51);   D.  int winner = (int) (Math.random() * 51) + 1;   E.  int winner = (int) (1 + Math.random() * 49); ### Correct Answer:  A ### Explanation: ### The expression   (int) (Math.random() * 50);   returns an  int  from 0 to 49. Therefore, adding 1 shifts the range to be 1 to 50, which was required. ### 
#########################################################
Question: 74 ### 6.  Consider the following code segment.   Integer i = new Integer(20);    /*    more code    */   Which of the following replacements for  /*    more code    */  correctly sets  i  to have an  Integer  value of  25 ?  I.  i = new Integer(25);   II.  i.intValue() = 25;   III. Integer j = new Integer (25);
i = j;
 ### A. I only  B. II only  C. III only  D. I and III only  E. II and III only ### Correct Answer:  D ### Explanation: ### The  Integer  class has no methods that can change the contents of  i . However,  i  can be reassigned so that it refers to another object. This happens in both segments I and III. Segment II is wrong because  intValue  is an  accessor âit cannot be used to change the value of object  i . ### 
#########################################################
Question: 75 ### 7.  Refer to these declarations.   Integer k = new Integer(8);    Integer m = new Integer(4);   Which test(s) will generate a compile-time error?  I.  if (k == m)â¦   II.  if (k.intValue() == m.intValue())â¦   III.  if ((k.intValue()).equals(m.intValue()))â¦ ### A. I only  B. II only  C. III only  D. I and II only  E. II and III only ### Correct Answer:  C ### Explanation: ### Tests I and II both get past the compiler. Test I compiles because  ==  tests the  references  for equality. To test the values, use  intValue , which Test II does correctly. Test III fails because you canât invoke a method (in this case  equals ) with an  int . ### 
#########################################################
Question: 76 ### 8.  Consider the following code fragment.   Object intObj = new Integer(9);    System.out.println(intObj);   You may assume that the  Integer  class has a  toString  method. What will be output as a result of running the fragment? ### A. No output. A  StringIndexOutOfBoundsException  will be thrown.  B. No output. An  ArithmeticException  will be thrown.  C.  9   D.  "9"   E. An address in memory of the reference  IntObj ### Correct Answer:  C ### Explanation: ### The  toString  method of the  Integer  class is invoked, which returns a string representing the value of  intObj :  System. out. println(intObj.toString ());
//outputs
 ### 
#########################################################
Question: 77 ### 9.  Consider these declarations.   String s1 = "crab";    String s2 = new String("crab");    String s3 = s1;   Which expression involving these strings evaluates to  true ?  I.  s1 == s2   II.  s1.equals(s2)   III.  s3.equals(s2) ### A. I only  B. II only  C. II and III only  D. I and II only  E. I, II, and III ### Correct Answer:  C ### Explanation: ### Here are the memory slots:  s1
String
String
s2
s3
"crab"
"crab"
  Statements II and III are true because the contents of  s1  and  s2  are the same, and the contents of  s3  and  s2  are the same. Statement I is false because  s1  and  s2  are not the same reference. Note that the expression  s1 == s3  would be true since  s1  and  s3   are  the same reference. ### 
#########################################################
Question: 78 ### 1.  Suppose that  strA = "TOMATO", strB = "tomato" , and  strC = "tom" . Given that  "A"  comes before  "a"  in dictionary order, which is true? ### A.  strA.compareTo(strB) &lt; 0 &amp;&amp; strB.compareTo(strC) &lt; 0   B.  strB.compareTo(strA) &lt; 0 || strC.compareTo(strA) &lt; 0   C.  strC.compareTo(strA) &lt; 0 &amp;&amp; strA.compareTo(strB) &lt; 0   D.  !(strA.equals(strB)) &amp;&amp; strC.compareTo(strB) &lt; 0   E.  !(strA.equals(strB)) &amp;&amp; strC.compareTo(strA) &lt; 0 ### Correct Answer:  D ### Explanation: ### Note that  "TOMATO"  precedes both  "tomato"  and  "tom" , since  "T"  precedes  "t" . Also,  "tom"  precedes  "tomato"  since the length of  "tom"  is less than the length of  "tomato" . Therefore each of the following is true:   strA.compareTo(strB) &lt; 0    strA.compareTo(strC) &lt; 0    strC.compareTo(strB) &lt; 0   So  Choice A is T and F, which evaluates to F.  Choice B is F or F, which evaluates to F.  Choice C is F and T, which evaluates to F.  Choice D is T and T, which evaluates to T.  Choice E is T and F, which evaluates to F. ### 
#########################################################
Question: 79 ### 2.  This question refers to the following declaration.  String line = "Some more silly stuff on strings! ";
/ /the words are separated by a single space
  What string will  str  refer to after execution of the following?  int x = line. indexOf ("m") ;
String str = line. substring(10, 15) + line. substring(25, 25 + x);
 ### A.  "sillyst"   B.  "sillystr"   C.  "silly st"   D.  "silly str"   E.  "sillystrin" ### Correct Answer:  A ### Explanation: ### x  contains the index of the first occurrence of  "m"  in  line ânamely,  2 . (Remember that  "S"  is at index  0 .) The method call  line.substring(10,15)  returns  "silly" , the substring starting at index 10 and extending though index 14. The method call  line.substring(25,27)  returns  "st"  (donât include the character at index 27!). The concatenation operator,  + , joins these. ### 
#########################################################
Question: 80 ### 3.  A program has a  String  variable  fullName  that stores a first name, followed by a space, followed by a last name. There are no spaces in either the first or last names. Here are some examples of  fullName  values:  "Anthony Coppola", "Jimmy Carroll" , and  "Tom DeWire" . Consider this code segment that extracts the last name from a  fullName  variable, and stores it in  lastName  with no surrounding blanks:  int k = fullName. indexOf (" ") ;
//find index of blank
String lastName = /* expression */
  Which is a correct replacement for  /*    expression    */ ?  I.  fullName.substring(k);   II.  fullName.substring(k + 1);   III.  fullName.substring(k + 1, fullName.length()); ### A. I only  B. II only  C. III only  D. II and III only  E. I and III only ### Correct Answer:  D ### Explanation: ### The first character of the last name starts at the first character after the space. Thus,  startIndex  for  substring  must be  k+1 . This eliminates expression I. Expression II takes all the characters from position  k+1  to the end of the  fullName  string, which is correct. Expression III takes all the characters from position  k+1  to position  fullName.length()-1 , which is also correct. ### 
#########################################################
Question: 81 ### 4.  One of the rules for converting English to Pig Latin states: If a word begins with a consonant, move the consonant to the end of the word and add "ay". Thus "dog" becomes "ogday," and "crisp" becomes "rispcay". Suppose  s  is a  String  containing an English word that begins with a consonant. Which of the following creates the correct corresponding word in Pig Latin? Assume the declarations   String ayString = "ay";    String pigString; ### A. pigString = s. substring(0, s. length()) + s. substring(0,1)
+ ayString;
  B. pigString = s. substring(1, s. length()) + s. substring (0,0)
+ ayString;
  C. pigString = s. substring(0, s. length()-1) + s. substring (0,1)
+ ayString;
  D. pigString = s. substring(1, s. length()-1) + s. substring (0,0)
+ ayString;
  E. pigString = s. substring(1, s. length()) + s. substring (0,1)
+ ayString;
 ### Correct Answer:  E ### Explanation: ### Suppose  s  contains  "cat" . You want  pigString = "at" + "c" + "ay" . Now the string  "at"  is the substring of  s  starting at position 1 and ending at position  s.length()-1 . The correct substring call for this piece of the word is  s.substring(1,s.length()) , which eliminates choices A, C, and D. (Recall that the first parameter is the starting position, and the second parameter is one position past the last index of the substring.) The first letter of the wordâ "c"  in the exampleâstarts at position 0 and ends at position 0. The correct expression is  s.substring(0,1) , which eliminates choice B. ### 
#########################################################
Question: 82 ### 5.  This question refers to the  getString  method shown below.  public static String getString(String s1, String s2)
{
int index = s1.indexOf(s2);
return s1.substring(index, index + s2.length());
7
  Which is true about  getString ? It may return a string that  I. Is equal to  s2 .  II. Has no characters in common with  s2 .  III. Is equal to  s1 . ### A. I and III only  B. II and III only  C. I and II only  D. I, II, and III  E. None is true. ### Correct Answer:  A ### Explanation: ### Statement I is true whenever  s2  occurs in  s1 . For example, if strings  s1 = "catastrophe"  and  s2 = "cat" , then  getString  returns  "cat" . Statement II will never happen. If  s2  is not contained in  s1 , the  indexOf  call will return  -1 . Using a negative integer as the first parameter of  substring  will cause a  StringIndexOutOfBoundsException . Statement III will be true whenever  s1  equals  s2 . ### 
#########################################################
Question: 83 ### 6.  Consider this method.  public static String doSomething (String s)
{
final String BLANK = " ";
/ /BLANK contains a single space
String str = "";
//empty string
String temp;
for (int i = 0; i < s.length(); i++)
{
temp= s.substring(i, i+ 1);
if (!(temp.equals(BLANK)))
str += temp;
}
return str;
  Which of the following is the most precise description of what  doSomething  does? ### A. It returns  s  unchanged.  B. It returns  s  with all its blanks removed.  C. It returns a  String  that is equivalent to  s  with all its blanks removed.  D. It returns a  String  that is an exact copy of  s .  E. It returns a  String  that contains  s.length()  blanks. ### Correct Answer:  C ### Explanation: ### The  String temp  represents a single-character substring of  s . The method examines each character in  s  and, if it is a nonblank, appends it to  str , which is initially empty. Each assignment  str += temp  assigns a new reference to  str . Thus,  str  ends up as a copy of  s  but without the blanks. A reference to the final  str  object is returned. Choice A is correct in that  s  is left unchanged, but it is not the  best  characterization of what the method does. Choice B is not precise because an object parameter is never modified: Changes, if any, are performed on a copy. Choices D and E are wrong because the method removes blanks. ### 
#########################################################
Question: 84 ### 7.  Which is true about the value of  p1.compareTo(p2) ? ### A. It equals  true .  B. It equals  false .  C. It equals  0 .  D. It equals  1 .  E. It equals  -1 . ### Correct Answer:  E ### Explanation: ### The  compareTo  method returns an  int , so eliminate choices A and B. In the implementation of  compareTo , the code segment that applies to the particular example is  if (this. getRow () < p. getRow() || . ..
return -1;
  Since 2 &lt; 4, the value  -1  is returned. ### 
#########################################################
Question: 85 ### 8.  Which boolean expression about  p1  and  p3  is true?  I.  p1 == p3   II.  p1.equals(p3)   III.  p1.compareTo(p3) == 0 ### A. I only  B. II only  C. III only  D. II and III only  E. I, II, and III ### Correct Answer:  C ### Explanation: ### Expression III is true: The  compareTo  method is implemented to return  0  if two  Position  objects have the same row and column. Expression I is false because  object1 == object2  returns  true  only if  object1  and  object2  are the  same reference . Expression II is tricky. You would like  p1  and  p3  to be equal since they have the same row and column values. This is not going to happen automatically, however. The  equals  method must explicitly be overridden for the  Position  class. If this hasnât been done, the default  equals  method, which is inherited from class  Object , will return true only if  p1  and  p3  are the same reference, which is not true. ### 
#########################################################
Question: 86 ### 9.  Here are three different  swap  methods, each intended for use in a client program.  I. public static void swap(int a, int b)
{
int temp = a;
a = b;
b = temp;
  II. public static void swap(Integer obj_a, Integer obj_b)
{
Integer temp = new Integer(obj_a.intValue());
obj_a = obj_b;
obj_b = temp;
  III. public static void swap (IntPair pair)
int temp = pair.getFirst();
pair.setFirst(pair.getSecond());
pair.setSecond(temp);
}
  When correctly used in a client program with appropriate parameters, which method will swap two integers, as intended? ### A. I only  B. II only  C. III only  D. II and III only  E. I, II, and III ### Correct Answer:  C ### Explanation: ### Recall that primitive types and object references are passed by value. This means that copies are made of the actual arguments. Any changes that are made are made to the  copies . The actual parameters remain unchanged. Thus, in methods I and II, the parameters will retain their original values and remain unswapped.  To illustrate, for example, why method II fails, consider the following piece of code that tests it:  public static void main(String
args)
{
int x= 8, y = 6;
Integer xObject = new Integer(x) ;
Integer yObject = new Integer(y) ;
swap(xObject, yObject);
x= xObject.intValue ();
//surprise! still has value 8
y = yObject.intValue();
/ /surprise! still has value 6
. . .
}
  Here are the memory slots before  swap  is called:  X
y
xObject
Integer
8
6
8
yObject
Integer
6
  Here they are when  swap  is invoked:  xObject
Integer
x
y
8
6
obj_a
8
yObject
temp
Integer
Integer
8
obj_b
6
  Just before exiting the  swap  method:  Integer
X
y
xObject
8
6
8
temp
yObject
Integer
Integer
obj_b
obj_a
8
6
  After exiting,  xObject  and  yObject  have retained their original values:  x
y
xObject
Integer
8
6
8
yObject
Integer
6
  The reason method III works is that instead of the object references being changed, the object  contents  are changed. Thus, after exiting the method, the  IntPair  reference is as it was, but the first and second values have been interchanged. (See the explanation of the next question for diagrams of the memory slots.) In this question,  IntPair  is used as a wrapper class for a pair of integers whose values need to be swapped. ### 
#########################################################
Question: 87 ### 10.  Consider the following program that uses the  IntPair  class.  public class TestSwap
{
public static void swap(IntPair pair)
{
int temp = pair.getFirst();
pair.setFirst(pair.getSecond());
pair.setSecond(temp);
}
public static void main(String[] args)
{
int x= 8, y = 6;
/* code to swap x and y */
}
ـل
  Which is a correct replacement for  /*    code to swap    x    and    y */ ?  I. IntPair iPair = new IntPair(x, y) ;
swap(x, y);
x = iPair.getFirst () ;
y = iPair.getSecond() ;
  II. IntPair iPair = new IntPair(x, y) ;
swap(iPair) ;
x = iPair.getFirst () ;
y = iPair.getSecond() ;
  III. IntPair iPair = new IntPair(x, y) ;
swap(iPair) ;
x = iPair. setFirst () ;
y = iPair.setSecond() ;
 ### A. I only  B. II only  C. III only  D. II and III only  E. None is correct. ### Correct Answer:  B ### Explanation: ### The  swap  method has just a single  IntPair  parameter, which eliminates segment I. Segment III fails because  setFirst  and  setSecond  are used incorrectly. These are mutator methods that change an  IntPair  object. What is desired is to return the (newly swapped) first and second values of the pair: Accessor methods  getFirst  and  getSecond  do the trick. To see why the  swap  code in segment II works, look at the memory slots.  Before the  swap  method is called:  IntPair
X
y
iPair
8
6
firstValue
8
secondValue
6
  Just after the  swap  method is called:  X
y
iPair
IntPair
8
6
temp
pair
firstValue
8
8
secondValue
6
  Just before exiting the  swap  method:  X
y
iPair
IntPair
8
6
temp
pair
firstValue
6
8
secondValue
8
  Just after exiting the  swap  method:  IntPair
X
y
iPair
8
6
firstValue
6
secondValue
8
  After the statements:   x = iPair.getFirst();    y = iPair.getSecond();   IntPair
X
y
iPair
6
8
firstValue
6
secondValue
8
  Notice that  x  and  y  have been swapped! ### 
#########################################################
Question: 88 ### 1.  The  compareTo  method implements the standard name-ordering algorithm where last names take precedence over first names. Lexicographic or dictionary ordering of  String s is used. For example, the name Scott Dentes comes before Nick Elser, and Adam Cooper comes before Sara Cooper.  Which of the following is a correct replacement for  /*    more code    */ ?  I. int last Comp = lastName . compareTo (n. lastName) ;
if (lastComp != 0)
return lastComp;
else
return firstName. compareTo(n.firstName) ;
  II. if (lastName . equals (n. lastName) )
return firstName. compareTo (n.firstName) ;
else
return 0;
  III. if (! (lastName . equals (n.lastName) ))
return first Name. compareTo (n.firstName)
else
return lastName. compareTo (n.lastName) ;
 ### A. I only  B. II only  C. III only  D. I and II only  E. I, II, and III ### Correct Answer:  A ### Explanation: ### The first statement of segment I compares last names. If these are different, the method returns the  int  value  lastComp , which is negative if  lastName  precedes  n.lastName , positive otherwise. If the last names are the same, the method returns the  int  result of comparing first names. Segments II and III use incorrect algorithms for comparing names. Segment II would be correct if the  else  part were   return lastName.compareTo(n.lastName);   Segment III would be correct if the two  return  statements were interchanged. ### 
#########################################################
Question: 89 ### 2.  Which statement about the  Name  class is false? ### A.  Name  objects are immutable.  B. It is possible for the methods in  Name  to throw a  NullPointerException .  C. If  n1  and  n2  are  Name  objects in a client class, then the expressions  n1.equals(n2)  and  n1.compareTo(n2) == 0  must have the same value.  D. The  compareTo  method throws a run-time exception if the parameter is null.  E. Since the  Name  class has a  compareTo  method, it  must  provide an implementation for an  equals  method. ### Correct Answer:  E ### Explanation: ### It is  wise  to have an  equals  method that is compatible with the  compareTo  method; namely,  n1.equals(n2)  and  n1.compareTo(n2)==0  have the same value if  n1  and  n2  are  Name  objects. However, nothing in the Java language  mandates  that if a class has a  compareTo  method, it must also have an  equals  method. Choice A is true. You know this because the  Name  class has no mutator methods. Thus,  Name  objects can never be changed. Choice B is true: If a  Name  is initialized with null references, each of the methods will throw a  NullPointerException . Choice C is true: If  n1.equals(n2)  is true, then  n1.compareTo(n2) == 0  is true, because both are conditions for equality of  n1  and  n2  and should therefore be consistent. Choice D is true: If the parameter is null, the  compareTo  method will throw a  NullPointerException . ### 
#########################################################
Question: 90 ### 3.  What is the output of the following code segment?  String s = "How do you do?";
int index = s.indexOf ("o") ;
while (index >= 0)
{
System. out . print (index + " ") ;
s = s.substring(index + 1);
index = s.indexOf("o") ;
 ### A.  1 3 2 3   B.  2 4 3 4   C.  1 5 8 12   D.  1 5 8 11   E. No output because of an  IndexOutOfBoundsException ### Correct Answer:  A ### Explanation: ### The algorithm prints the current index of  "o"  in the string, and then creates a new substring containing all remaining characters following that  "o" . Here is the series of substrings and the corresponding output for each (the symbol <img  src="https://img.crackap.com/ap/computer-science-a/br23/com.jpg"/> denotes a blank character):  How_do_you_do?
1
Wudouyou_do?
3
uyou_do?
2
u_do?
3
 ### 
#########################################################
Question: 91 ### 4.  Consider the following method  removeAll  that creates and returns a string that has stripped its input phrase of all occurrences of its single-character  String  parameter  ch .  Line 1: public static String removeAll (String phrase, String ch)
Line 2: {
Line 3:
String str = "";
Line 4:
String newPhrase = phrase;
Line 5:
int pos = phrase.indexOf (ch);
Line 6:
if (pos == - 1)
Line 7:
return phrase;
Line 8:
else
Line 9:
{
Line 10:
while (pos >= 0)
Line 11:
{
Line 12:
str = str + newPhrase. substring(0, pos - 1);
Line 13:
newPhrase = newPhrase.substring(pos + 1);
Line 14:
pos = newPhrase. indexOf (ch) ;
Line 15:
if (pos == - 1)
Line 16:
str = str + newPhrase;
Line 17:
}
Line 18:
return str;
Line 19:
Line 20: }
  The method doesnât work as intended. Which of the following changes to the  removeAll  method will make it work as specified? ### A. Change Line 10 to<br/> while (pos &gt;= -1)   B. Change Line 12 to<br/> str = str + newPhrase.substring(0, pos);   C. Change Line 13 to<br/> newPhrase = newPhrase.substring(pos);   D. Change Line 14 to<br/> pos = phrase.indexOf(ch);   E. Change Line 16 to<br/> str = str + newPhrase.substring(pos + 1); ### Correct Answer:  B ### Explanation: ### Here is a description of the algorithm:  Make a copy of  phrase  in  newPhrase .  Find the first occurrence of  ch  in  newPhrase  ( pos  is the index).  If you found it, concatenate to  str  the characters in  newPhrase  from  0  to  pos-1 .  Change  newPhrase  to contain all characters from  ch  to the end, excluding  ch .  Repeat the process until there are no more occurrences of  ch  in  newPhrase .  So Line 12 is wrong because  newPhrase.substring(0,pos-1)  will not include the character at  pos-1 , which means that the string returned will lose a character that is  not  equal to  ch . ### 
#########################################################
Question: 92 ### 5.  A programmer has written a program that "chats" to a human user based on statements that the human inputs. The program contains a method  findKeyWord  that searches an input statement for a given keyword. The  findKeyWord  method contains the following line of code.   pos = statement.indexOf(word);   Suppose  pos  has a value  &gt;= 0 ; that is,  word  was found. The programmer now wants to test that an actual word was found, not part of another word. For example, if "cat" is the keyword, the programmer needs to check that itâs not part of "catch" or "category." Here is the code that tests if  word  is a stand-alone word. (You may assume that  statement  is all lowercase and contains only letters and blanks.)  pos = statement . indexOf (word) ;
/ /Check for first or last word
if (pos == 0 || pos + word.length() == statement.length())
{
before = " ";
after = " ";
}
else
{
before = statement. substring(pos - 1, pos) ;
after = statement. substring(pos + word. length(),
pos + word.length() +1);
if (/* test */)
/ /then a stand-alone word was found .
else
/ /word was part of a larger word
ـلـ
  Which replacement for  /*    test    */  will give the desired result? ### A.  (before &lt; "a" || before &gt; "z") &amp;&amp; (after &lt; "a" || after &gt; "z")   B.  (before &gt; "a" || before &lt; "z") &amp;&amp; (after &gt; "a" || after &lt; "z")   C. (before. compareTo ("a") < 0 && before. compareTo ("z") > 0) ||
(after. compareTo("a") > 0 && after. compareTo("z") < 0)
  D. (before. compareTo ("a") > 0 && before . compareTo ("z") < 0) &&
(after. compareTo("a") > 0 && after. compareTo("z") < 0)
  E. (before. compareTo ("a") < 0 || before. compareTo ("z") > 0) &&
(after. compareTo("a") < 0 || after. compareTo("z") > 0)
 ### Correct Answer:  E ### Explanation: ### The program has found a stand-alone word if the characters  before  and  after  are both blank. Choice E tests that they are not letters between  "a"  and  "z" ; i.e., they must be blank. Choices A and B fail because you must use  compareTo  for inequality tests on strings. Choices C and D allow at least one of  before  and  after  to be a letter, which would mean that  word  was not a stand-alone word. ### 
#########################################################
Question: 93 ### 6.  A program that simulates a conversation between a computer and a human user generates a random response to a userâs comment. All possible responses that the computer can generate are stored in an array of  String  called  allResponses . The method given below,  getResponse , returns a random response string from the array.  **
Precondition: array allResponses is initialized with strings.
*
Postcondition: returns a random response from allResponses.
*/
public String getResponse () ;
{ /* implementation */ }
  Which is a correct  /*    implementation    */ ? ### A. int i = (int) (Math. random() * allResponses. length);
return allResponses [i] ;
  B.  return (String) (Math.random() * allResponses.length);   C. int i = Math. random() * allResponses. length;
return allResponses [i] ;
  D. int i = (int) (Math.random() * (allResponses. length - 1));
return allResponses [i] ;
  E.  return (int) (Math.random() * allResponses.length); ### Correct Answer:  A ### Explanation: ### The first line in choice A returns a random integer that lies between 0 and  allResponses.length-1 . This range corresponds to the range of the array indexes and so it is correct. Choice B is wrongâyou cannot cast a real number to a string. Choice C fails because  Math.random()  is type  double  and you require an  int ; you must do the cast to  int  shown in choice A. Choice D fails because the element  allResponses[allResponses.length-1]  will never be returned:  i  will contain a random  int  from  0  to  allResponses.length-2 . Choice E returns an  int , not a  String . ### 
#########################################################
Question: 94 ### 7.  The  Tile  class contains a  toString  method that creates a  String  containing the letter and point value of a  Tile . The string should be in the following format.   Letter letter (point value = pointValue )   For example,   Letter A (point value = 1)    Letter Z (point value = 10)   Consider the  toString  method below.  public String toString()
return /* code */
  Which  /* code */  leads to correct output? ### A.  Letter + "letter " + "(point value = " + pointValue + ")";   B.  "Letter " + letter + ("point value = " + pointValue);   C.  Letter + this.letter + " (point value = " + pointValue + ")";   D.  "Letter " + letter + " (point value = " + (String) pointValue + ")";   E.  "Letter " + letter + " (point value = " + pointValue + ")"; ### Correct Answer:  E ### Explanation: ### The actual letter and its point value must not be in quotes because their  values  must be printed. Everything else, including the parentheses, must be in quotes. (All text in quotes is printed literally, as is.) Choices A and C fail because they donât place the opening word,  Letter , in quotes. Choice B doesnât have the parentheses in quotes. Choice D incorrectly tries to cast an  int  to a  String . ### 
#########################################################
Question: 95 ### 8.  Any two tiles in the word game that have the same letter also have the same point value, but the opposite is not necessarily true. For example, all the vowels have a point value of 1. Two tiles are said to match if they have the same letter. Consider the following  matches  method for the  Tile  class.  **
Returns true if the letter on this tile equals the letter
*
on otherTile. * /
public boolean matches(Tile otherTile)
{ return /* code */; }
  Which replacements for  /*    code    */  return the desired result? Note: You may not assume that the  Tile  class has its own  equals  method.  I.  letter == otherTile.letter   II.  this.equals(otherTile)   III.  letter.equals(otherTile.letter) ### A. I only  B. II only  C. III only  D. II and III only  E. I and III only ### Correct Answer:  C ### Explanation: ### Segment I will only be true if an object and its parameter are the same reference, which is not necessarily true for two matching tiles. Segment II fails similarly if the  Tile  class doesnât have its own  equals  method. (The inherited method from  Object  compares references.) ### 
#########################################################
Question: 96 ### 1.  A program that reads in a five-digit identification number is to be written. The specification does not state whether zero can be entered as a first digit. The programmer should ### A. write the code to accept zero as a first digit since zero is a valid digit.  B. write the code to reject zero as a first digit since five-digit integers do not start with zero.  C. eliminate zero as a possibility for any of the digits.  D. treat the identification number as a four-digit number if the user enters a number starting with zero.  E. check with the writer of the specification whether zero is acceptable as a first digit. ### Correct Answer:  E ### Explanation: ### A programmer should never make unilateral decisions about a program specification. When in doubt, check with the person who wrote the specification. ### 
#########################################################
Question: 97 ### 2.  Refer to the following three program descriptions.  I. Test whether there exists at least one three-digit integer whose value equals the sum of the squares of its digits.  II. Read in a three-digit code number and check if it is valid according to some given formula.  III. Passwords consist of three digits and three capital letters in any order. Read in a password, and check if there are any repeated characters.  For which of the preceding program descriptions would a  ThreeDigitNumber  class be suitable? ### A. I only  B. II only  C. III only  D. I and II only  E. I, II, and III ### Correct Answer:  D ### Explanation: ### In I and II a three-digit number is the object being manipulated. For III, however, the object is a six-character string, suggesting a class other than a  ThreeDigitNumber . ### 
#########################################################
Question: 98 ### 3.  Top-down programming is illustrated by which of the following? ### A. Writing a program from top to bottom in Java  B. Writing an essay describing how the program will work, without including any Java code  C. Using driver programs to test all methods in the order that theyâre called in the program  D. Writing and testing the lowest level methods first and then combining them to form appropriate abstract operations  E. Writing the program in terms of the operations to be performed and then refining these operations by adding more detail ### Correct Answer:  E ### Explanation: ### Top-down programming consists of listing the methods for the main object and then using stepwise refinement to break each method into a list of subtasks. Eliminate choices A, C, and D: Top-down programming refers to the design and planning stage and does not involve any actual writing of code. Choice B is closer to the mark, but "top-down" implies a list of operations, not an essay describing the methods. ### 
#########################################################
Question: 99 ### 4.  Which of the following should influence your choice of a particular algorithm?  I. The run time of the algorithm  II. The memory requirements of the algorithm  III. The ease with which the logic of the algorithm can be understood ### A. I only  B. III only  C. I and III only  D. I and II only  E. I, II, and III ### Correct Answer:  E ### Explanation: ### All three considerations are valid when choosing an algorithm. III is especially important if your code will be part of a larger project created by several programmers. Yet even if you are the sole writer of a piece of software, be aware that your code may one day need to be modified by others. ### 
#########################################################
Question: 100 ### 5.  A list of numbers is stored in a sorted array. It is required that the list be maintained in sorted order. This requirement leads to inefficient execution for which of the following processes?  I. Summing the five smallest numbers in the list  II. Finding the maximum value in the list  III. Inserting and deleting numbers ### A. I only  B. III only  C. II and III only  D. I and III only  E. I, II, and III ### Correct Answer:  B ### Explanation: ### A process that causes excessive data movement is inefficient. Inserting an element into its correct (sorted) position involves moving elements to create a slot for this element. In the worst case, the new element must be inserted into the first slot, which involves moving every element up one slot. Similarly, deleting an element involves moving elements down a slot to close the "gap." In the worst case, where the first element is deleted, all elements in the array will need to be moved. Summing the five smallest elements in the list means summing the first five elements. This requires no testing of elements and no excessive data movement, so it is efficient. Finding the maximum value in a sorted list is very fastâjust select the element at the appropriate end of the list. ### 
#########################################################
Question: 101 ### 6.  Which of the following is not necessarily a feature of a robust program? ### A. Does not allow execution to proceed with invalid data  B. Uses algorithms that give correct answers for extreme data values  C. Will run on any computer without modification  D. Will not allow division by zero  E. Will anticipate the types of errors that users of the program may make ### Correct Answer:  C ### Explanation: ### "Robustness" implies the ability to handle all data input by the user and to give correct answers even for extreme values of data. A program that is not robust may well run on another computer without modification, and a robust program may need modification before it can run on another computer. ### 
#########################################################
Question: 102 ### 7.  A certain freight company charges its customers for shipping overseas according to this scale.  $80 per ton for a weight of 10 tons or less  $40 per ton for each additional ton over 10 tons but not exceeding 25 tons  $30 per ton for each additional ton over 25 tons  For example, to ship a weight of 12 tons will cost 10(80) + 2(40) = $880. To ship 26 tons will cost 10(80) + 15(40) + 1(30) = $1430.  A method takes as parameter an integer that represents a valid shipping weight and outputs the charge for the shipment. Which of the following is the smallest set of input values for shipping weights that will adequately test this method? ### A. 10, 25  B. 5, 15, 30  C. 5, 10, 15, 25, 30  D. 0, 5, 10, 15, 25, 30  E. 5, 10, 15, 20, 25, 30 ### Correct Answer:  C ### Explanation: ### Eliminate choice D because 0 is an invalid weight, and you may infer from the method description that invalid data have already been screened out. Eliminate choice E because it tests two values in the range 10â25. (This is not wrong, but choice C is better.) Eliminate choice A since it tests only the endpoint values. Eliminate B because it tests  no  endpoint values. ### 
#########################################################
Question: 103 ### 8.  A code segment calculates the mean of values stored in integers  n1, n2, n3 , and  n4  and stores the result in  average , which is of type  double . What kind of error is caused with this statement?   double average = n1 + n2 + n3 + n4 / (double) 4; ### A. Logic  B. Run-time  C. Overflow  D. Syntax  E. Type mismatch ### Correct Answer:  A ### Explanation: ### The statement is syntactically correct, but as written it will not find the mean of the integers. The bug is therefore an intent or logic error. To execute as intended, the statement needs parentheses:    double average = (n1 + n2 + n3 + n4) / (double) 4; ### 
#########################################################
Question: 104 ### 9.  A program evaluates binary arithmetic expressions that are read from an input file. All of the operands are integers, and the only operators are  +, -, * , and  / . In writing the program, the programmer forgot to include a test that checks whether the right-hand operand in a division expression equals zero. When will this oversight be detected by the computer? ### A. At compile time  B. While editing the program  C. As soon as the data from the input file is read  D. During evaluation of the expressions  E. When at least one incorrect value for the expressions is output ### Correct Answer:  D ### Explanation: ### The error that occurs is a run-time error caused by an attempt to divide by zero ( ArithmeticException ). Donât be fooled by choice C. Simply reading an expression  8/0  from the input file wonât cause the error. Note that if the operands were of type  double , the correct answer would be E. In this case, dividing by zero does not cause an exception; it gives an answer of  Infinity . Only on inspecting the output would it be clear that something was wrong. ### 
#########################################################
Question: 105 ### 10.  A programmer plans to write a program that simulates various games. In the program, there is a  Player  class that has a  getMove  method. Method  getMove  returns an  int  value to simulate a move in a game.  Which of the games described below are suitable candidates for using the  getMove  method as specified above?  I. High-Low Guessing Game: The computer thinks of a number and the player who guesses it with the least number of guesses wins. After each guess, the computer tells whether its number is higher or lower than the playerâs guess.  II. Chips: Start with a pile of chips. Each player, in turn, removes some number of chips, but not all of them. The winner is the one who removes the final chip.  III. Tic-Tac-Toe: Two players alternate placing "X" or "O" on a 3 Ã 3 grid. The first player to get three in a row, where a row can be horizontal, vertical, or diagonal, wins. ### A. I only  B. II only  C. III only  D. I and II only  E. I, II, and III ### Correct Answer:  D ### Explanation: ### Games I and II are perfect games for using an integer value to describe the next move. For the High-Low Guessing Game,  getMove()  will return the next guess, and for Chips,  getMove()  will return the number of chips removed at the playerâs turn. Game III, Tic-Tac-Toe, requires a location on a 3 Ã 3 grid as a playerâs next move: a simple integer value isnât a suitable return type for the  getMove  method. ### 
#########################################################
Question: 106 ### 11.  Which best describes the precondition of a method? It is an assertion that ### A. describes precisely the conditions that must be true at the time the method is called.  B. initializes the parameters of the method.  C. describes the effect of the method on its postcondition.  D. explains what the method does.  E. states what the initial values of the local variables in the method must be. ### Correct Answer:  A ### Explanation: ### A precondition does not concern itself with the action of the method, the local variables, the algorithm, or the postcondition. Nor does it initialize the parameters. It simply asserts what must be true directly before execution of the method. ### 
#########################################################
Question: 107 ### 1.  Consider the following code fragment.  / ** Precondition: a1, a2, a3 contain 3 distinct integers.
Postcondition: max contains the largest of a1, a2, a3.
*/
//first set max equal to larger of a1 and a2
if (a1 > a2)
max = a1;
else
max = a2;
//set max equal to larger of max and a3
if (max < a3)
max = a3;
  For this algorithm, which of the following initial setups for  a1, a2 , and  a3  will cause   (1) the least number of computer operations (best case) and   (2) the greatest number of computer operations (worst case)? ### A. (1) largest value in a1 or a2
(2) largest value in a3
  B. (1) largest value in a2 or a3
(2) largest value in a
  C. (1) smallest value in a1
(2) largest value in a
  D. (1) largest value in a2
(2) smallest value in a
  E. 1) smallest value in a1 or a2 (2) largest value in a3
 ### Correct Answer:  A ### Explanation: ### The best case causes the fewest computer operations, and the worst case leads to the maximum number of operations. In the given algorithm, the initial test  if (a1 &gt; a2)  and the assignment to  max  will occur irrespective of which value is the largest. The second test,  if (max &lt; a3) , will also always occur. The final statement,  max = a3 , will occur only if the largest value is in  a3 ; thus, this represents the worst case. So the best case must have the biggest value in  a1  or  a2 . ### 
#########################################################
Question: 108 ### 2.  Refer to the following code segment.  / ** Compute the mean of integers 1 . . . N.
* N is an integer >= 1 and has been initialized.
*/
int k = 1;
double mean, sum = 1.0;
while (k < N)
/* loop body */
}
mean = sum / N;
  What is the precondition for the  while  loop? ### A.  k â¥ N, sum = 1.0   B.  sum = 1 + 2 + 3 + â¦ + k   C.  k &lt; N, sum = 1.0   D.  N â¥ 1, k = 1, sum = 1.0   E.  mean = sum / N ### Correct Answer:  D ### Explanation: ### The precondition is an assertion about the variables in the loop just before the loop is executed. Variables  N, k , and  sum  have all been initialized to the values shown in choice D. Choice C is wrong because  k  may equal  N . Choice A is wrong because  k  may be less than  N . Choice E is wrong because  mean  is not defined until the loop has been exited. Choice B is wrong because it omits the assertions about  N  and  k . ### 
#########################################################
Question: 109 ### 3.  The sequence of Fibonacci numbers is 1, 1, 2, 3, 5, 8, 13, 21, â¦. The first two Fibonacci numbers are each 1. Each subsequent number is obtained by adding the previous two. Consider this method.  / **
Precondition: n >= 1.
*
Postcondition: The nth Fibonacci number has been returned.
*/
public static int fib(int n)
{
int prev = 1, next = 1, sum = 1;
for (int i = 3; i <= n; i++)
{
/* assertion */
sum = next + prev;
prev = next ;
next = sum;
}
return sum;
}
  Which of the following is a correct  /*    assertion    */  about the loop variable  i ? ### A.  1 â¤ i â¤ n   B.  0 â¤ i â¤ n   C.  3 â¤ i â¤ n   D.  3 &lt; i â¤ n   E.  3 &lt; i &lt; n+1 ### Correct Answer:  C ### Explanation: ### Eliminate choices A and B, since  i  is initialized to  3  in the  for  loop. Choices D and E are wrong because  i  is equal to  3  the first time through the loop. ### 
#########################################################
Question: 110 ### 4.  Refer to the following method.  / ** Precondition: a and b are initialized integers
*/
public static int mystery(int a, int b)
int total = 0, count = 1;
while (count <= b)
{
total += a;
count++;
}
return total;
  What is the postcondition for method  mystery ? ### A.  total  =  a  +  b   B.  total  =  a b    C.  total  =  b a    D.  total  =  a  *  b   E.  total  =  a / b ### Correct Answer:  D ### Explanation: ### The quantity  a  is being added to  total b  times, which means that at the end of execution  total = a*b . ### 
#########################################################
Question: 111 ### 5.  A program is to be written that prints an invoice for a small store. A copy of the invoice will be given to the customer and will display:   â  A list of items purchased.   â  The quantity, unit price, and total price for each item.   â  The amount due.  Three candidate classes for this program are  Invoice, Item , and  ItemList , where an  Item  is a single item purchased and  ItemList  is the list of all items purchased. Which class is a reasonable choice to be responsible for the  amountDue  method, which returns the amount the customer must pay?  I.  Item   II.  ItemList   III.  Invoice ### A. I only  B. III only  C. I and II only  D. II and III only  E. I, II, and III ### Correct Answer:  D ### Explanation: ### It makes sense for an  Item  to be responsible for its name, unit price, quantity, and total price. It is  not  reasonable for it to be responsible for other  Item s. Since an  ItemList , however, will contain information for all the  Item s purchased, it is reasonable to have it also compute the total  amountDue . It makes just as much sense to give an  Invoice  the responsibility for displaying information for the items purchased, as well as providing a final total,  amountDue . ### 
#########################################################
Question: 112 ### 6.  Which is a false statement about classes in object-oriented program design? ### A. If a class  C1  has an instance variable whose type is another class,  C2 , then  C1   has-a   C2 .  B. If a class  C1  is associated with another class,  C2 , then  C1  depends on  C2  for its implementation.  C. If classes  C1  and  C2  are related such that  C1   is-a   C2 , then  C2   has-a   C1 .  D. If class  C1  is independent, then none of its methods will have parameters that are objects of other classes.  E. Classes that have common methods do not necessarily define an inheritance relationship. ### Correct Answer:  C ### Explanation: ### The  is-a  relationship defines inheritance, while the  has-a  relationship defines association. These types of relationships are mutually exclusive. For example, a graduate student  is-a  student. It doesnât make sense to say a student  has-a  graduate student! ### 
#########################################################
Question: 113 ### 7.  A Java program maintains a large database of vehicles and parts for a car dealership. Some of the classes in the program are  Vehicle, Car, Truck, Tire, Circle, SteeringWheel , and  AirBag . The declarations below show the relationships between classes. Which is a poor choice? ### A. public class Vehicle
{
private Tire[] tires;
private SteeringWheel sw;
  B. public class Tire extends Circle
{
. . .
//inherits methods that compute circumference
//and center point
}
  C. public class Car extends Vehicle
. ..
/ /inherits private Tire[] tires from Vehicle class
//inherits private SteeringWheel sw from Vehicle class
  D. public class Tire
{
. .
private String rating;
//speed rating of tire
private Circle boundary;
}
  E. public class SteeringWheel
{
.
private AirBag ab; //AirBag is stored in SteeringWheel
private Circle boundary;
}
 ### Correct Answer:  B ### Explanation: ### Even though itâs convenient for a  Tire  object to inherit  Circle  methods, an inheritance relationship between a  Tire  and a  Circle  is incorrect: It is false to say that a  Tire   is-a   Circle . A  Tire  is a car part, while a  Circle  is a geometric shape. Notice that there is an  association  relationship between a  Tire  and a  Circle : A  Tire   has-a   Circle  as its boundary. ### 
#########################################################
Question: 114 ### 8.  A Java programmer has completed a preliminary design for a large program. The programmer has developed a list of classes, determined the methods for each class, established the relationships between classes, and written an outline for each class. Which class(es) should be implemented first? ### A. Any superclasses  B. Any subclasses  C. All collaborator classes (classes that will be used to implement other classes)  D. The class that represents the dominant object in the program  E. All independent classes (classes that have no references to other classes) ### Correct Answer:  E ### Explanation: ### Independent classes do not have relationships with other classes and can therefore be more easily coded and tested. ### 
#########################################################
Question: 115 ### 9.  A program is to be written that simulates bumper cars in a video game. The cars move on a square grid and are located on grid points ( x, y ), where  x  and  y  are integers between ?20 and 20. A bumper car moves in a random direction, either left, right, up, or down. If it reaches a boundary (i.e.,  x  or  y  is Â±20), then it reverses direction. If it is about to collide with another bumper car, it reverses direction. Your program should be able to add bumper cars and run the simulation. One step of the simulation allows each car in the grid to move. After a bumper car has reversed direction twice, its turn is over and the next car gets to move.  To identify classes in the program, the nouns in the specification are listed:   program, bumper car, grid, grid point, integer, direction, boundary, simulation  How many nouns in the list should immediately be discarded because they are unsuitable as classes for the program? ### A. 0  B. 1  C. 2  D. 3  E. 4 ### Correct Answer:  C ### Explanation: ### The word "program" is never included when itâs used in this context. The word "integer" describes the type of coordinates  x  and  y  and has no further use in the specification. While words like "direction," "boundary," and "simulation" may later be removed from consideration as classes, it is not unreasonable to keep them as candidates while you ponder the design. ### 
#########################################################
Question: 116 ### 10.  Which operation should not be the responsibility of the  GridPoint  class? ### A.  isEmpty  - returns false if the grid point contains a  BumperCar , true otherwise  B.  atBoundary  - returns true if  x  or  y  coordinate = Â±20, false otherwise  C.  left - if not at left boundary, change the grid point to 1 unit left of current point   D.  up  - if not at top of grid, change the grid point to 1 unit above current point  E.  get_x  - return  x -coordinate of this point ### Correct Answer:  A ### Explanation: ### A  GridPoint  object knows only its  x  and  y  coordinates. It has no information about whether a  BumperCar  is at that point. Notice that operations in all of the other choices depend on the  x  and  y  coordinates of a  GridPoint  object. An  isEmpty  method should be the responsibility of the  Grid  class that keeps track of the status of each position in the grid. ### 
#########################################################
Question: 117 ### 11.  Which method is not suitable for the  BumperCar  class? ### A. public boolean atBoundary ()
/ /Returns true if BumperCar at boundary, false otherwise.
  B. public void selectRandomDirection ()
//Select random direction (up, down, left, or right)
// at start of turn.
  C. public void reverseDirection ()
/ /Move to grid position that is in direction opposite to
// current direction.
  D. public void move ()
//Take turn to move. Stop move after two changes
// of direction.
  E. public void update ()
/ /Modify Grid to reflect new position after each stage
// of
Of move.
 ### Correct Answer:  E ### Explanation: ### A  BumperCar  is responsible for itselfâkeeping track of its own position, selecting an initial direction, making a move, and reversing direction. It is not, however, responsible for maintaining and updating the grid. That should be done by the  Grid  class. ### 
#########################################################
Question: 118 ### 1.  Which of the following correctly initializes an array  arr  to contain four elements each with value  0 ?  I.  int[] arr = {0, 0, 0, 0};   II.  int[] arr = new int[4];   III. int [] arr = new int [4] ;
for (int i = 0; i < arr.length; i++)
arr[i] = 0;
 ### A. I only  B. III only  C. I and III only  D. II and III only  E. I, II, and III ### Correct Answer:  E ### Explanation: ### Segment I is an initializer list which is equivalent to  int [] arr = new int [4];
arr [0] = 0;
arr [1] = 0;
arr [2] = 0;
arr [3] = 0;
  Segment II creates four slots for integers, which by default are initialized to  0 . The  for  loop in segment III is therefore unnecessary. It is not, however, incorrect. ### 
#########################################################
Question: 119 ### 2.  The following program segment is intended to find the index of the first negative integer in  arr[0]  â¦  arr[N-1] , where  arr  is an array of  N  integers.  int i = 0;
while (arr[i] >= 0)
{
i++;
}
location = i;
  This segment will work as intended ### A. always.  B. never.  C. whenever  arr  contains at least one negative integer.  D. whenever  arr  contains at least one nonnegative integer.  E. whenever  arr  contains no negative integers. ### Correct Answer:  C ### Explanation: ### If  arr  contains no negative integers, the value of  i  will eventually exceed  N-1 , and  arr[i]  will cause an  ArrayIndexOutOfBoundsException  to be thrown. ### 
#########################################################
Question: 120 ### 3.  Refer to the following code segment. You may assume that  arr  is an array of  int  values.  int sum = arr [0], i = 0;
while (i < arr.length)
{
i++;
sum += arr [i];
  Which of the following will be the result of executing the segment? ### A. Sum of  arr[0], arr[1] , â¦,  arr[arr.length-1]  will be stored in  sum .  B. Sum of  arr[1], arr[2] , â¦,  arr[arr.length-1]  will be stored in  sum .  C. Sum of  arr[0], arr[1] , â¦,  arr[arr.length]  will be stored in  sum .  D. An infinite loop will occur.  E. A run-time error will occur. ### Correct Answer:  E ### Explanation: ### The intent is to sum elements  arr[0], arr[1] , â¦,  arr[arr.length-1] . Notice, however, that when  i  has the value  arr.length-1 , it is incremented to  arr.length  in the loop, so the statement  sum += arr[i]  uses  arr[arr.length] , which is out of range. ### 
#########################################################
Question: 121 ### 4.  Refer to the following code segment. You may assume that array  arr1  contains elements  arr1[0], arr1[1] , â¦,  arr1[N-1] , where  N  =  arr1.length .  int count = 0;
for (int i = 0; i < N; i++)
if (arr1[i] != 0)
{
arr1[count] = arr1 [i];
count++;
}
int [] arr2 = new int [count] ;
for (int i = 0; i < count; i++)
arr2 [i] = arr1 [i];
  If array  arr1  initially contains the elements 0, 6, 0, 4, 0, 0, 2 in this order, what will  arr2  contain after execution of the code segment? ### A. 6, 4, 2  B. 0, 0, 0, 0, 6, 4, 2  C. 6, 4, 2, 4, 0, 0, 2  D. 0, 6, 0, 4, 0, 0, 2  E. 6, 4, 2, 0, 0, 0, 0 ### Correct Answer:  A ### Explanation: ### The code segment has the effect of removing all occurrences of 0 from array  arr1 . The algorithm copies the nonzero elements to the front of  arr1 . Then it transfers them to array  arr2 . ### 
#########################################################
Question: 122 ### 5.  Consider this program segment.  for (int i = 2; i <= k; i++)
if (arr [i] < someValue)
System. out . print ( "SMALL") ;
  What is the maximum number of times that  SMALL  can be printed? ### A.  0   B.  1   C.  k - 1   D.  k - 2   E.  k ### Correct Answer:  C ### Explanation: ### If  arr[i] &lt; someValue  for all  i  from  2  to  k, SMALL  will be printed on each iteration of the  for  loop. Since there are  k - 1  iterations, the maximum number of times that  SMALL  can be printed is  k - 1 . ### 
#########################################################
Question: 123 ### 6.  What will be output from the following code segment, assuming it is in the same class as the  doSomething  method?  int [
arr = {1, 2, 3, 4};
doSomething(arr) ;
System. out. print (arr [1] + " ") ;
System. out. print (arr [3]) ;
. . .
public void doSomething (int [] list)
int [] b = list;
for (int i = 0; i < b.length; i++)
b[i] = i;
 ### A.  0 0   B.  2 4   C.  1 3   D.  0 2   E.  0 3 ### Correct Answer:  C ### Explanation: ### Array  arr  is changed by  doSomething . Here are the memory slots:  Just before doSomething is called:
Just after doSomething is called,
but before the for loop is executed:
arr
arr
>
1 2 3 4
1
2 3 4
list
b
Just before exiting doSomething:
Just after exiting doSomething:
arr
arr
0 12 3
012 3
list
b
 ### 
#########################################################
Question: 124 ### 7.  Consider writing a program that reads the lines of any text file into a sequential list of lines. Which of the following is a good reason to implement the list with an  ArrayList  of  String  objects rather than an array of  String  objects? ### A. The  get  and  set  methods of  ArrayList  are more convenient than the  []  notation for arrays.  B. The  size  method of  ArrayList  provides instant access to the length of the list.  C. An  ArrayList  can contain objects of any type, which leads to greater generality.  D. If any particular text file is unexpectedly long, the  ArrayList  will automatically be resized. The array, by contrast, may go out of bounds.  E. The  String  methods are easier to use with an  ArrayList  than with an array. ### Correct Answer:  D ### Explanation: ### Arrays are of fixed length and do not shrink or grow if the size of the data set varies. An  ArrayList  automatically resizes the list. Choice A is false: The  []  notation is compact and easy to use. Choice B is not a valid reason because an array  arr  also provides instant access to its length with the quantity  arr.length . Choice C is invalid because an array can also contain objects. Also, generality is beside the point in the given program: The list  must  hold  String  objects. Choice E is false: Whether a  String  object is  arr[i]  or  list.get(i) , the  String  methods are equally easy to invoke. ### 
#########################################################
Question: 125 ### 8.  Consider writing a program that produces statistics for long lists of numerical data. Which of the following is the best reason to implement each list with an array of  int  (or  double ), rather than an  ArrayList  of  Integer  (or  Double ) objects? ### A. An array of primitive number types is more efficient to manipulate than an  ArrayList  of wrapper objects that contain numbers.  B. Insertion of new elements into a list is easier to code for an array than for an  ArrayList .  C. Removal of elements from a list is easier to code for an array than for an  ArrayList .  D. Accessing individual elements in the middle of a list is easier for an array than for an  ArrayList .  E. Accessing all the elements is more efficient in an array than in an  ArrayList . ### Correct Answer:  A ### Explanation: ### In order for numerical elements to be added to an  ArrayList , each element must be wrapped in a wrapper class before insertion into the list. Then, to retrieve a numerical value from the  ArrayList , the element must be unboxed using the  intValue  or  doubleValue  methods. Even though these operations can be taken care of with autoboxing and unboxing, there are efficiency costs. In an array, you simply use the  []  notation for assignment (as in  arr[i] = num ) or retrieval ( value = arr[i] ). Note that choices B and C are false statements: Both insertion and deletion for an array involve writing code to shift elements. An  ArrayList  automatically takes care of this through its  add  and  remove  methods. Choice D is a poor reason for choosing an array. While the  get  and  set  methods of  ArrayList  might be slightly more awkward than using the  []  notation, both mechanisms work pretty easily. Choice E is false: Efficiency of access is roughly the same. ### 
#########################################################
Question: 126 ### 9.  A client method has this declaration, followed by code to initialize the list.   Address[] list = new Address[100];   Here is a code segment to generate a list of  names only .  for (Address a : list)
/* line of code */
  Which is a correct  /*    line of code    */ ? ### A.  System.out.println(Address[i].getName());   B.  System.out.println(list[i].getName());   C.  System.out.println(a[i].getName());   D.  System.out.println(a.getName());   E.  System.out.println(list.getName()); ### Correct Answer:  D ### Explanation: ### For each  Address  object  a  in  list , access the name of the object with  a.getName() . ### 
#########################################################
Question: 127 ### 10.  The following code segment is to print out a list of addresses.  for (Address addr : list)
/* more code */
  Which is a correct replacement for  /*    more code    */ ?  I. System. out . println (list [i] . getName () ) ;
System. out. println(list [i] .getStreet ()) ;
System. out. print (list [i] . getCity() + ", ");
System. out. print (list [i] . getState() + " ");
System. out. println(list [i] .getZip()) ;
  II. System. out . println (addr . getName ()) ;
System. out. println(addr.getStreet ()) ;
System. out . print (addr. getCity() + ", ");
System. out . print (addr .getState () + " ");
System. out . println (addr. getZip () ) ;
  III.  System.out.println(addr); ### A. I only  B. II only  C. III only  D. I and II only  E. I, II, and III ### Correct Answer:  B ### Explanation: ### Since the  Address  class does not have a  toString  method, each data field must explicitly be printed. Segment III would work if there  were  a  toString  method for the class (but there isnât, so it doesnât!). Segment I fails because of incorrect use of the enhanced  for  loop: The array index should not be accessed. ### 
#########################################################
Question: 128 ### 11.  A client method has this declaration.  Student
] allStudents = new Student [NUM_STUDS] ; //NUM_STUDS is
//an int constant
  Here is a code segment to generate a list of  Student  names only. (You may assume that  allStudents  has been initialized.)  for (Student student : allStudents)
/* code to print list of names */
  Which is a correct replacement for  /*    code to print list of names    */ ? ### A.  System.out.println(allStudents.getName());   B.  System.out.println(student.getName());   C.  System.out.println(student.getAddress().getName());   D.  System.out.println(allStudents.getAddress().getName());   E.  System.out.println(student[i].getAddress().getName()); ### Correct Answer:  C ### Explanation: ### Each  Student  name must be accessed via the  getName()  accessor of the  Address  class. The expression  student.getAddress()  accesses the entire address of that student. The  name  field is then accessed using the  getName()  accessor of the  Address  class. ### 
#########################################################
Question: 129 ### 12.  Here is a method that locates the  Student  with the highest  idNum .  ** Returns Student with highest idNum.
*
Precondition: Array stuArr of Student is initialized.
*/
public static Student locate (Student [] stuArr)
{
/* method body */
  Which of the following could replace  /*    method body    */  so that the method works as intended?  I. int max = stuArr [0] . getIdNum() ;
for (Student student : stuArr)
if (student.getIdNum() > max)
{
max = student.get IdNum() ;
return student ;
}
return stuArr [0] ;
  II. Student highestSoFar = stuArr [0] ;
int max = stuArr [0].getIdNum();
for (Student student : stuArr)
if (student . getIdNum() > max)
{
max = student . get IdNum ();
highestSoFar = student;
}
return highestSoFar;
  III. int maxPos = 0;
for(int i = 1; i < stuArr.length; i++)
if (stuArr [i] .getIdNum() > stuArr [maxPos] .getIdNum())
maxPos = i;
return stuArr [maxPos] ;
 ### A. I only  B. II only  C. III only  D. I and III only  E. II and III only ### Correct Answer:  E ### Explanation: ### Both correct solutions are careful not to lose the student who has the highest  idNum  so far. Segment II does it by storing a reference to the student,  highestSoFar . Segment III does it by storing the array index of that student. Code segment I is incorrect because it returns the first student whose  idNum  is greater than  max , not necessarily the student with the highest  idNum  in the list. ### 
#########################################################
Question: 130 ### 1.  Which of the following correctly replaces  /*    more code    */  in the  Transaction  constructor to initialize the  tickList  array? ### A.  tickList[i] = new Ticket(getRow(), getSeat(), getPrice());   B.  tickList[i] = new Ticket(theRow, theSeat, thePrice);   C.  tickList[i] = new tickList(getRow(), getSeat(), getPrice());   D.  tickList[i] = new tickList(theRow, theSeat, thePrice);   E.  tickList[i] = new tickList(numTicks); ### Correct Answer:  B ### Explanation: ### For each  i, tickList[i]  is a new  Ticket  object that must be constructed using the  Ticket  constructor. Therefore eliminate choices C, D, and E. Choice A is wrong because  getRow(), getSeat() , and  getPrice()  are accessors for values  that already exist  for some  Ticket  object. Note also the absence of the dot member construct. ### 
#########################################################
Question: 131 ### 2.  Which represents correct  /*    code to calculate amount    */  in the  totalPaid  method? ### A. for (Ticket t : tickList)
total += t.price;
  B. for (Ticket t : tickList)
total += tickList. getPrice();
  C. for (Ticket t : tickList)
total += t.getPrice() ;
  D. Transaction T;
for (Ticket t : T)
total += t. getPrice() ;
  E. Transaction T;
for (Ticket t : T)
total += t.price;
 ### Correct Answer:  C ### Explanation: ### To access the price for each  Ticket  in the  tickList  array, the  getPrice()  accessor in the  Ticket  class must be used, since  price  is private to that class. This eliminates choices A and E. Choice B uses the array name incorrectly. Choices D and E incorrectly declare a  Transaction  object. (The method applies to an existing  Transaction  object.) ### 
#########################################################
Question: 132 ### 3.  Suppose it is necessary to keep a list of all ticket transactions. Assuming that there are  NUMSALES  transactions, a suitable declaration would be ### A.  Transaction[] listOfSales = new Transaction[NUMSALES];   B.  Transaction[] listOfSales = new Ticket[NUMSALES];   C.  Ticket[] listOfSales = new Transaction[NUMSALES];   D.  Ticket[] listOfSales = new Ticket[NUMSALES];   E.  Transaction[] Ticket = new listOfSales[NUMSALES]; ### Correct Answer:  A ### Explanation: ### An array of type  Transaction  is required. This eliminates choices C and D. Additionally, choices B and D incorrectly use type  Ticket  on the right-hand side. Choice E puts the identifier  listOfSales  in the wrong place. ### 
#########################################################
Question: 133 ### 4.  The following code fragment is intended to find the smallest value in  arr[0]  â¦  arr[n-1] , but does not work as intended.  **
Precondition:
- arr is an array, arr.length = n.
- arr [0] . .. arr[n-1] initialized with integers.
*
Postcondition: min = smallest value in arr [0] . . . arr [n-1]
*/
int min = arr [0];
int i = 1;
while (i < n)
{
i++;
if (arr[i] < min)
min = arr [i];
}
  For the segment to work as intended, which of the following modifications could be made?  I. Change the line    int i = 1;    to    int i = 0;    Make no other changes.  II. Change the body of the  while  loop to  if (arr[i] < min)
min = arr [i];
i++;
7
   Make no other changes.  III. Change the test for the  while  loop as follows.    while (i &lt;= n)    Make no other changes. ### A. I only  B. II only  C. III only  D. I and II only  E. I, II, and III ### Correct Answer:  B ### Explanation: ### There are two problems with the segment as given:    1.   arr[1]  is not tested.    2.  When  i  has a value of  n-1 , incrementing  i  will lead to an out-of-range error for the  if(arr[i] &lt; min)  test.  Modification II corrects both these errors. The change suggested in III corrects neither of these errors. The change in I corrects (1) but not (2). ### 
#########################################################
Question: 134 ### 5.  Refer to method  match  below.  ** Returns true if there is an integer k that occurs
* in both arrays; otherwise returns false.
*
Precondition:
*
- v is an array of int sorted in increasing order
*
- w is an array of int sorted in increasing order
- N is the number of elements in array v
*
*
- M is the number of elements in array w
*
- v[0] . . . v [N-1] and w[O] ... w[M-1] is initialized with integers
*
- v[0] < v[1] < ... < v[N-1] and w[0] < w[1] < ... < w [M-1] .
*
public static boolean match(int [] v, int [] w, int N, int M)
{
int vIndex = 0, wIndex = 0;
while (vIndex < N && wIndex < M)
{
if (v[vIndex] == w[wIndex])
return true;
else if (v[vIndex] < w[wIndex])
vIndex++;
else
wIndex++;
return false;
2
  Assuming that the method has not been exited, which assertion is true at the end of every execution of the  while  loop? ### A.  v[0]â¦v[vIndex-1]  and  w[0]â¦w[wIndex-1]  contain no common value,  vIndex  â¤  N  and  wIndex  â¤  M .  B.  v[0]â¦v[vIndex]  and  w[0]â¦w[wIndex]  contain no common value,  vIndex  â¤  N  and  wIndex  â¤  M .  C.  v[0]â¦v[vIndex-1]  and  w[0]â¦w[wIndex-1]  contain no common value,  vIndex  â¤  N-1  and  wIndex  â¤  M-1 .  D.  v[0]â¦v[vIndex]  and  w[0]â¦w[wIndex]  contain no common value,  vIndex  â¤  N-1  and  wIndex  â¤  M-1 .  E.  v[0]â¦v[N-1]  and  w[0]â¦w[M-1]  contain no common value,  vIndex  â¤  N  and  wIndex  â¤  M . ### Correct Answer:  A ### Explanation: ### Notice that either  vIndex  or  wIndex  is incremented at the end of the loop. This means that, when the loop is exited, the current values of  v[vIndex]  and  w[wIndex]  have not been compared. Therefore, you can only make an assertion for values  v[0]..v[vIndex-1]  and  w[0]..w[wIndex-1] . Also, notice that if there is no common value in the arrays, the exiting condition for the  while  loop will be that the end of one of the arrays has been reached, namely  vIndex  equals  N  or  wIndex  equals  M . ### 
#########################################################
Question: 135 ### 6.  Consider this class.  public class Book
{
private String title;
private String author;
private boolean checkoutStatus;
public Book(String bookTitle, String bookAuthor)
{
title = bookTitle;
author = bookAuthor;
checkoutStatus = false;
}
/ ** Change checkout status. * /
public void changeStatus()
{ checkoutStatus = ! checkoutStatus; }
//Other methods are not shown.
ـلـ
  A client program has this declaration.   Book[] bookList = new Book[SOME_NUMBER];   Suppose  bookList  is initialized so that each  Book  in the list has a title, author, and checkout status. The following piece of code is written, whose intent is to change the checkout status of each book in  bookList .  for (Book b : bookList,
b. changeStatus () ;
  Which is true about this code? ### A. The  bookList  array will remain unchanged after execution.  B. Each book in the  bookList  array will have its checkout status changed, as intended.  C. A  NullPointerException  may occur.  D. A run-time error will occur because it is not possible to modify objects using the enhanced  for  loop.  E. A logic error will occur because it is not possible to modify objects in an array without accessing the indexes of the objects. ### Correct Answer:  B ### Explanation: ### Objects in an array can be changed in an enhanced  for  loop by using mutator methods of the objectsâ class. The  changeStatus  method, a mutator in the  Book  class, will work as intended in the given code. Choice C would be true if it were not given that each  Book  in  bookList  was initialized. If any given  b  had a value of  null , then a  Null-PointerException  would be thrown. ### 
#########################################################
Question: 136 ### 7.  Which of the following is a correct replacement for     /* declare array of   BingoCard */? ### A.  int[] BingoCard = new BingoCard[NUMPLAYERS];   B.  BingoCard[] players = new int[NUMPLAYERS];   C.  BingoCard[] players = new BingoCard[20];   D.  BingoCard[] players = new BingoCard[NUMPLAYERS];   E.  int[] players = new BingoCard[NUMPLAYERS]; ### Correct Answer:  D ### Explanation: ### The declaration must start with the type of value in the array, namely  BingoCard . This eliminates choices A and E. Eliminate choice B: The type on the right of the assignment should be  BingoCard . Choice C is wrong because the number of slots in the array should be  NUMPLAYERS , not 20. ### 
#########################################################
Question: 137 ### 8.  Assuming that  players  has been declared as an array of  BingoCard , which replacement for  /*    construct each    BingoCard */  is correct?  I. for (BingoCard card : players)
card = new BingoCard() ;
  II. for (BingoCard card : players)
players [card] = new BingoCard ();
  III. for (int i = 0; i < players. length; i++)
players[i] = new BingoCard();
 ### A. I only  B. II only  C. III only  D. I and III only  E. I, II, and III ### Correct Answer:  C ### Explanation: ### Segment III is the only segment that works, since the enhanced  for  loop should not be used to replace elements in an array. After the declaration    BingoCard[] players = new BingoCard[NUMPLAYERS];   each element in the  players  array is  null . The intent in the given code is to replace each null reference with a newly constructed  BingoCard . ### 
#########################################################
Question: 138 ### 9.  Here are two possible algorithms for shuffling the deck.   Algorithm 1   Initialize an array of  Card  called  shuffled  of length  NUMCARDS .  Set  k  to  0 .  For  j=0  to  NUMCARDS/2-1   - Copy  cards[j]  to  shuffled[k]   - Set  k  to  k+2   Set  k  to  1 .  For  j=NUMCARDS/2  to  NUMCARDS-1   - Copy  cards[j]  to  shuffled[k]   - Set  k  to  k+2    Algorithm 2   Initialize an array of  Card  called  shuffled  containing  NUMCARDS  slots.  For  k=0  to  NUMCARDS-1   - Repeatedly generate a random integer  j  from  0  to  NUMCARDS-1 , until  cards[j]  contains a card not marked as empty  - Copy  cards[j]  to  shuffled[k]   - Set  cards[j]  to empty  Which is a false statement concerning Algorithms 1 and 2? ### A. A disadvantage of Algorithm 1 is that it wonât generate all possible deck permutations.  B. For Algorithm 2, to determine the last element shuffled requires an average of  NUMCARDS  calls to the random number generator.  C. Algorithm 2 will lead to more permutations of the deck than Algorithm 1.  D. In terms of run time, Algorithm 2 is more efficient than Algorithm 1.  E. If Algorithm 1 is repeated several times, it may return the deck to its original state. ### Correct Answer:  D ### Explanation: ### The big defect of Algorithm 2 is that it eventually slows down. This is because every time it selects an empty element, it has to loop again. Each of the other choices is true. In choice A, for example, the element  cards[0]  always moves to  shuffled[0] , eliminating all permutations that have  cards[0]  in a different slot. For choice B, by the time you get to assign the last element, all but two slots of the  cards  array are marked empty. So, on average, you will need to go through  NUMCARDS  tries to find one of those two nonempty slots. For choice C, even though Algorithm 2 is slow, in theory every element in  cards  could land in any given slot in  shuffled . This is not true for Algorithm 1, where the first element never budges out of the first slot. For choice E, because of the precise ordering of elements in Algorithm 1, the array will always eventually return to its original state, assuming there are sufficient iterations. ### 
#########################################################
Question: 139 ### 10.  The following  shuffle  method is used to shuffle the cards in the  Deck  class.  Line 1: public void shuffle ()
Line 2: {
Line 3:
for (int k = NUMCARDS; k > 0; k -- )
Line 4:
{
Line 5:
int randPos = (int) (Math.random() * (k+1));
Line 6:
//swap randomly selected card with card at position k
Line 7:
Card temp = cards [k] ;
Line 8:
cards [k] = cards [randPos] ;
Line 9:
cards [randPos] = temp;
Line 10:
}
Line 11: }
  The method does not work as intended. Which of the following changes should be made to correct the method? ### A. Replace Line 3 with<br/> for (int k = NUMCARDS; k &gt;= 0; k--)   B. Replace Line 3 with<br/> for (int k = NUMCARDS - 1; k &gt; 0; k--)   C. Replace Line 3 with<br/> for (int k = 1; k &lt;= NUMCARDS; k++)   D. Replace Line 5 with<br/> int randPos = (int) (Math.random() * k);   E. Replace Lines 7 â 9 with<br/>Card temp = cards [randPos]
cards [randPos] = cards [k] ;
cards [k] = temp;
 ### Correct Answer:  B ### Explanation: ### If  k  starts with the value  NUMCARDS , the method encounters  cards[NUMCARDS]  on Line 7 and throws an  ArrayIndexOutOfBoundsException . ### 
#########################################################
Question: 140 ### 1.  Consider these declarations.  ArrayList<String> strList = new ArrayList<String> ();
String ch = " ";
Integer intOb = new Integer(5);
  Which statement will cause an error? ### A.  strList.add(ch);   B.  strList.add(new String("handy andy"));   C.  strList.add(intOb.toString());   D.  strList.add(ch + 8);   E.  strList.add(intOb + 8); ### Correct Answer:  E ### Explanation: ### All elements added to  strList  must be of type  String . Each choice satisfies this except choice E. Note that in choice D, the expression  ch + 8  becomes a  String  since  ch  is a  String  (just one of the operands needs to be a  String  to convert the whole expression to a  String ). In choice E, neither  intOb  nor  8  is a  String . ### 
#########################################################
Question: 141 ### 2.  Let  list  be an  ArrayList&lt;Integer&gt;  containing these elements.   2 5 7 6 0 1   Which of the following statements would not cause an error to occur? Assume that each statement applies to the given list, independent of the other statements. ### A.  Object ob = list.get(6);   B.  Integer intOb = list.add(3.4);   C.  list.add(6, 9);   D.  Object x = list.remove(6);   E.  Object y = list.set(6, 8); ### Correct Answer:  C ### Explanation: ### The effect of choice C is to adjust the size of the list to 7 and to add the  Integer 9  to the last slot (i.e., the slot with index  6 ). Choices A, D, and E will all cause an  IndexOutOfBoundsException  because there is no slot with index  6 : the last slot has index  5 . Choice B will cause a compile-time error, since it is attempting to add an element of type  Double  to a list of type  Integer . ### 
#########################################################
Question: 142 ### 3.  Refer to method  insert  below.  ** Inserts element in its correct sorted position in list
*
Precondition: list contains String values sorted
in decreasing order.
*/
public void insert (ArrayList<String> list, String element)
{
int index = 0;
while (element.compareTo(list.get(index)) < 0)
index++;
list.add(index, element);
}
  Assuming that the type of  element  is compatible with the objects in the list, which is a true statement about the  insert  method? ### A. It works as intended for all values of  element .  B. It fails for all values of  element .  C. It fails if  element  is greater than the first item in  list  and works in all other cases.  D. It fails if  element  is smaller than the last item in  list  and works in all other cases.  E. It fails if  element  is either greater than the first item or smaller than the last item in  list  and works in all other cases. ### Correct Answer:  D ### Explanation: ### If  element  is smaller than the last item in the list, it will be compared with every item in the list. Eventually  index  will be incremented to a value that is out of bounds. To avoid this error, the test in the  while  loop should be   while(index &lt; list.size() &amp;&amp; element.compareTo(list.get(index)) &lt; 0)   Notice that if  element  is greater than or equal to at least one item in  list , the test as given in the problem will eventually be false, preventing an out-of-range error. ### 
#########################################################
Question: 143 ### 4.  Consider the following code segment, applied to  list , an  ArrayList  of  Integer  values.  int len = list. size();
for (int i = 0; i < len; i++)
list.add(i+1, new Integer(i));
Object x = list.set(i, new Integer(i + 2));
  If  list  is initially  6 1 8 , what will it be following execution of the code segment? ### A.  2 3 4 2 1 8   B.  2 3 4 6 2 2 0 1 8   C.  2 3 4 0 1 2   D.  2 3 4 6 1 8   E.  2 3 3 2 ### Correct Answer:  A ### Explanation: ### Recall that  add(index, obj)  shifts all elements, starting at  index , one unit to the right, then inserts  obj  at position  index . The  set(index, obj)  method replaces the element in position  index  with  obj . So here is the state of  list  after each change:  i = 0
601 8
2018
i = 1
20118
23118
i = 2
2 3 1 2 1 8
23421 8
 ### 
#########################################################
Question: 144 ### 5.  Here is the  getTotal  method from the  Purse  class.  / **
Returns the total value of coins in purse. * /
public double getTotal()
{
double total = 0;
/* more code */
return total;
  Which of the following is a correct replacement for  /*    more code    */ ? ### A. for (Coin c : coins)
c = coins.get(i) ;
total += c.getValue ();
  B. for (Coin c : coins)
Coin value = c.getValue();
total += value;
  C. for (Coin c : coins)
Coin c = coins.get(i) ;
total += c.getValue();
  D. for (Coin c : coins)
{
total += coins. getValue ();
  E. for (Coin c : coins)
total += c.getValue ();
 ### Correct Answer:  E ### Explanation: ### The value of each  Coin c  in  coins  must be accessed with  c.getValue() . This eliminates choice D. Eliminate choices A and B: The loop accesses each  Coin  in the  coins ArrayList , which means that there should not be any statements attempting to get the next  Coin . Choice B would be correct if the first statement in the loop body were   double value = c.getValue(); ### 
#########################################################
Question: 145 ### 6.  Two coins are said to  match  each other if they have the same name or the same value. You may assume that coins with the same name have the same value and coins with the same value have the same name. A boolean method  find  is added to the  Purse  class.  ** Returns true if the purse has a coin that matches aCoin,
*
false otherwise.
*/
public boolean find(Coin aCoin)
{
for (Coin c : coins)
{
/* code to find match */
}
return false;
ـلـ
  Which is a correct replacement for  /*    code to find match    */ ?  I. if (c. equals (aCoin) )
return true;
  II. if ( (c. getName () ) . equals (aCoin. getName ()))
return true;
  III. if
( (c. get Value () ) . equals (aCoin. getValue () ) )
return true;
 ### A. I only  B. II only  C. III only  D. I and II only  E. I, II, and III ### Correct Answer:  D ### Explanation: ### Code segment III is wrong because the  equals  method is defined for objects only. Since  getValue  returns a  double , the quantities  c.getValue()  and  aCoin.getValue()  must be compared either using  == , or as described in the box on p. 70 (better). ### 
#########################################################
Question: 146 ### 7.  Which of the following initializes an 8 Ã 10 matrix with integer values that are perfect squares? (0 is a perfect square.)  I.  int[][] mat = new int[8][10];   II. int [] [] mat = new int [8] [10] ;
for (int r = 0; r < mat.length; r++)
for (int c = 0; c < mat [r] . length; c++)
mat [r] [c] = r * r;
  III. int
mat = new int [8] [10] ;
for (int c = 0; c < mat [r] .length; c++)
for (int r = 0; r < mat.length; r++)
mat [r] [c] = c * C;
 ### A. I only  B. II only  C. III only  D. I and II only  E. I, II, and III ### Correct Answer:  D ### Explanation: ### Segment II is the straightforward solution. Segment I is correct because it initializes all slots of the matrix to 0, a perfect square. (By default, all arrays of  int  or  double  are initialized to 0.) Segment III fails because  r  is undefined in the condition  c &lt; mat[r].length . In order to do a column-by-column traversal, you need to get the number of columns in each row. The outer  for  loop could be   for (int c = 0; c &lt; mat[0].length; c++)   Now segment III works. Note that since the array is rectangular, you can use any index  k  in the conditional  c &lt; mat[k].length , provided that  k  satisfies the condition  0  â¤  k  &lt;  mat.length  (the number of rows). ### 
#########################################################
Question: 147 ### 8.  Consider the following code segment.  int [] [] mat = { {1, 3, 5},
{2,4,6},
{0,7,8},
{9,10,11}}
for (int col = 0; col < mat [0] . length; col++)
for (int row = mat.length - 1; row > col; row -- )
System. out . println(mat [row] [col] ) ;
  When this code is executed, which will be the fifth element printed? ### A.  3   B.  4   C.  5   D.  6   E.  7 ### Correct Answer:  E ### Explanation: ### When  col  is  0 :  row  is  3 , then  2 , then  1 .  When  col  is  1 :  row  is  3 , then  2 .  When  col  is  2 :  row  is  3 .   Here are the corresponding elements, in order, that are printed:   mat [3] [0] , mat [2] [0] , mat [1] [0]
mat [3] [1], mat [2] [1],
mat [3] [2]
  The fifth element in the list is  mat[2][1] , which is  7 . ### 
#########################################################
Question: 148 ### 9.  Consider a class that has this private instance variable.   private int[][] mat;   The class has the following method,  alter .  public void alter(int c)
{
for (int i = 0; i < mat.length; i++)
for (int j = c + 1; j < mat [0] . length; j++)
mat [i] [j-1] = mat [i] [j] ;
  If a 3 Ã 4 matrix  mat  is  1 3 5 7
2 4 6 8
3 57 9
  then  alter(1)  will change  mat  to ### A. 1 5 7 7
2688
3 7 99
  B. 1 5 7
2 6 8
3 7 9
  C. 1 3 5 7
3 5
  D. 1 3 5 7
3 57 9
3 5 7 9
  E. 1 7 7 7
2888
3 9 9 9
 ### Correct Answer:  A ### Explanation: ### Method  alter  shifts all the columns, starting at column  c+1 , one column to the left. Also, it does it in a way that overwrites column  c . Here are the replacements for the method call  alter(1):    mat [0] [1] = mat [0] [2]
mat [0] [2] = mat [0] [3]
mat [1] [1] = mat [1] [2]
mat [1] [2] = mat [1] [3]
mat [2] [1] = mat [2] [2]
mat [2] [2] = mat [2] [3]
 ### 
#########################################################
Question: 149 ### 10.  Consider the following method that will alter the matrix  mat .  public static void matStuff (int []
mat, int row)
int numCols = mat [0].length;
for (int col = 0; col < numCols; col++)
mat [row] [col] = row;
1
  Suppose  mat  is originally  1
4
9
2
7
8
5
1
4
3
  After the method call  matStuff(mat,2) , matrix  mat  will be ### A. 1
4
9
0
2
7
8
2
2
2
  B. 1
4
9
2
2
2
5
1
4
3
  C. 2
2
2
2
2
2
2 2
2
2
2
  D. 1
4
2
2
7
2 6
5
1
2
3
  E. 1
2
9
2
2
8
6
5
2
4
3
 ### Correct Answer:  A ### Explanation: ### matStuff  processes the row selected by the row parameter, 2 in the method call. The row value, 2, overwrites each element in row 2. Donât make the mistake of selecting choice Bâthe row labels are 0, 1, 2. ### 
#########################################################
Question: 150 ### 1.  Assume that a square matrix  mat  is defined by  int [] []
mat = new int [SIZE] [SIZE] ;
//SIZE is an integer constant >= 2
  What does the following code segment do?  for (int i = 0; i < SIZE - 1; i++)
for (int j= 0; j < SIZE - i - 1; j++)
swap(mat, i, j, SIZE - j - 1, SIZE - i - 1)
  You may assume the existence of this  swap  method.  / ** Interchange mat [a] [b] and mat [c] [d] . * /
public void swap(int [] [] mat, int a, int b, int c, int d)
 ### A. Reflects  mat  through its major diagonal. For example,<br/>2
6
2
4
1
4
3
6
3
  B. Reflects  mat  through its minor diagonal. For example,<br/>2
6
3
6
4
3
4 2
  C. Reflects  mat  through a horizontal line of symmetry. For example,<br/>2
6
4 3
1
4
3
2 6
  D. Reflects  mat  through a vertical line of symmetry. For example,<br/>2
6
6
2
1
4
3
3
  E. Leaves  mat  unchanged. ### Correct Answer:  B ### Explanation: ### Hand execute this for a 2 Ã 2 matrix.  i  goes from 0 to 0 and  j  goes from 0 to 0, so the only interchange is swap  mat[0][0]  with  mat[1][1] , which suggests choice B. Check with a 3 Ã 3 matrix:   i = 0 j = 0
swap mat [0] [0] with mat [2] [2]
j= 1
swap mat [0] [1] with mat [1] [2]
i = 1
j = 0
swap mat [1] [0] with mat [2] [1]
  The elements to be interchanged are shown paired in the following figure. The result will be a reflection through the minor diagonal.  2
4
6
K
1
3
1.
7
9
 ### 
#########################################################
Question: 151 ### 2.  Consider a class  MatrixStuff  that has a private instance variable.   private int[][] mat;   Refer to method  alter  below that occurs in the  MatrixStuff  class. (The lines are numbered for reference.)  Line 1:
Precondition:
Line 2:
*
- the matrix mat is initialized with integers
Line 3:
*
Postcondition:
Line 4:
*
- Column c has been removed.
Line 5:
*
- The last column is filled with zeros.
Line 6:
*/
Line 7: public void alter(int [] [] mat, int c)
Line 8: {
Line 9:
for (int i = 0; i < mat.length; i++)
Line 10:
for (int j = c; j < mat [0].length; j++)
Line 11:
mat [i] [j] = mat [i] [j+1];
Line 12:
//code to insert zeros in rightmost column
Line 13:
. .
Line 14: }
  The intent of the method  alter  is to remove column  c . Thus, if the input matrix  mat  is  <img  src="https://img.crackap.com/ap/computer-science-a/br23/p0289-03.jpg"/>  the method call  alter(mat, 1)  should change  mat  to  <img  src="https://img.crackap.com/ap/computer-science-a/br23/p0289-04.jpg"/>  The method does not work as intended. Which of the following changes will correct the problem?  I. Change line 10 to    for (int j = c; j &lt; mat[0].length - 1; j++)    and make no other changes.  II. Change lines 10 and 11 to   for (int j = c + 1; j < mat [0] . length; j++)
mat [i] [j-1] = mat [i] [j] ;
   and make no other changes.  III. Change lines 10 and 11 to   for (int j = mat [0] . length - 1; j > c; j -- )
mat [i] [j-1] = mat [i] [j] ;
   and make no other changes. ### A. I only  B. II only  C. III only  D. I and II only  E. I, II, and III ### Correct Answer:  D ### Explanation: ### The method as given will throw an  ArrayIndexOutOfBoundsException . For the matrix in the example,  mat[0].length  is 4. The call  mat.alter(1)  gives  c  a value of 1. Thus, in the inner  for  loop,  j  goes from 1 to 3. When  j  is 3, the line  mat[i][j] = mat[i][j+1]  becomes  mat[i][3] = mat[i][4] . Since columns go from 0 to 3,  mat[i][4]  is out of range. The changes in segments I and II both fix this problem. In each case, the correct replacements are made for each row  i: mat[i][1] = mat[i][2]  and  mat[i][2] = mat[i][3] . Segment III makes the following incorrect replacements as  j  goes from 3 to 2:  mat[i][2] = mat[i][3]  and  mat[i][1] = mat[i][2] . This will cause both columns 1 and 2 to be overwritten. Before inserting zeros in the last column,  mat  will be  2
9
9
9
1
3
3
3
0
2
2
  This does not achieve the intended postcondition of the method. ### 
#########################################################
Question: 152 ### 3.  This question refers to the following method.  public static boolean isThere(String[] [] mat, int row, int col,
String symbol)
{
boolean yes;
int i, count = 0;
for (i = 0; i < SIZE; i++)
if (mat [i] [col] .equals(symbol))
count++;
yes= (count == SIZE) ;
count = 0;
for (i = 0; i < SIZE; i++)
if (mat [row] [i] .equals(symbol))
count++;
return (yes | | count == SIZE) ;
}
  Now consider this code segment.  public final int SIZE = 8;
String [] []
mat = new String [SIZE] [SIZE]
  Which of the following conditions on a matrix  mat  of the type declared in the code segment will by itself guarantee that   isThere(mat, 2, 2, "$")   will have the value  true  when evaluated?  I. The element in row 2 and column 2 is  "$" .  II. All elements in both diagonals are  "$" .  III. All elements in column 2 are  "$" . ### A. I only  B. III only  C. I and II only  D. I and III only  E. II and III only ### Correct Answer:  B ### Explanation: ### For the method call  isThere(mat, 2, 2, "$") , the code counts how many times  "$"  appears in row 2 and how many times in column 2. The method returns  true  only if  count == SIZE  for either the row or column pass (i.e., the whole of row 2 or the whole of column 2 contains the symbol  "$" ). This eliminates choices I and II. ### 
#########################################################
Question: 153 ### 4.  Consider the following method.  public static void alterArray (int [] arr)
{
int mid = arr.length/2;
for (int i = 0; i < mid; i++)
{
int temp = arr [i];
arr [i] = arr[arr.length - i - 1];
arr [arr.length - i - 1] = temp;
}
  If the current state of a matrix  mat  is  2 795
8 1 4 3
6 509
  which matrix will result from the method call  alterArray(mat[2]) ? ### A. 2 795
341 8
6 50 9
  B. 2 705
814 3
6 5 99
  C. 5972
3 4 1 8
9056
  D. 2 795
814 3
9056
  E. 5 972
814 3
6 5 0 9
 ### Correct Answer:  D ### Explanation: ### The matrix  mat  consists of an array of rows,  mat[0], mat[1], mat[2] , each of which is an array. The method  alterArray  swaps the first and last elements of an array, then the second and second-last elements, and so on, until it reaches the middle of the array. The method call  alterArray(mat[2])  performs this series of swaps on row 2 of the matrix, the bottom row, resulting in the matrix in choice D. ### 
#########################################################
Question: 154 ### 5.  The method  changeNegs  below should replace every occurrence of a negative integer in its matrix parameter with 0.  ** Replaces all negative values in mat with 0.
*
Precondition: mat is initialized with integers.
*/
public static void changeNegs (int [] [] mat)
{
/* code */
}
  Which is a correct replacement for  /*    code    */ ?  I. for (int r = 0; r < mat. length; r++)
for (int c = 0; c < mat [r].length; c++)
if (mat [r] [c] < 0)
mat [r] [c] = 0;
  II. for (int c = 0; c < mat [0] . length; c++)
for (int r = 0; r < mat.length; r++)
if (mat [r] [c] < 0)
mat [r] [c] = 0;
  III. for (int [] row : mat)
for (int element : row)
if (element < 0)
element = 0;
 ### A. I only  B. II only  C. III only  D. I and II only  E. I, II, and III ### Correct Answer:  D ### Explanation: ### Segment I is a row-by-row traversal; segment II is a column-by-column traversal. Each achieves the correct postcondition. Segment III traverses the matrix but does not alter it. All that is changed is the local variable  element . You cannot use this kind of loop to replace elements in an array. ### 
#########################################################
Question: 155 ### 6.  A two-dimensional array  rainfall  that contains  double  values will be used to represent the daily rainfall for a given year. In this scheme,  rainfall[month][day]  represents the amount of rain on the given day and month. For example,  rainfall [1] [15]
is the amount of rain on Jan. 15
rainfall [12] [25]
is the amount of rain on Dec. 25
  The array can be declared as follows.   double[][] rainfall = new double[13][32];   This creates 13 rows indexed from  0  to  12  and 32 columns indexed from  0  to  31 , all initialized to  0.0 . Row  0  and column  0  will be ignored. Column  31  in row  4  will be ignored, since April 31 is not a valid day. In years that are not leap years, columns  29, 30 , and  31  in row  2  will be ignored since Feb. 29, 30, and 31 are not valid days.   Consider the method  averageRainfall  below.  **
Precondition:
- rainfall is initialized with values representing amounts
of rain on all valid days.
- Invalid days are initialized to 0.0.
- Feb 29 is not a valid day.
*
Postcondition: Returns average rainfall for the year.
*/
public double averageRainfall (double rainfall [] [])
{
double total = 0.0;
/* more code */
}
  Which of the following is a correct replacement for  /*    more code    */  so that the postcondition for the method is satisfied?  I. for (int month = 1; month < rainfall . length; month++)
for (int day = 1; day < rainfall [month] .length; day++)
total += rainfall [month] [day] ;
return total / (13 * 32);
  II. for (int month = 1; month < rainfall . length; month++)
for (int day = 1; day < rainfall [month] .length; day++)
total += rainfall [month] [day] ;
return total / 365;
  III. for (double []
month : rainfall)
for (double rainAmt : month)
total += rainAmt;
return total / 365;
 ### A. None  B. I only  C. II only  D. III only  E. II and III only ### Correct Answer:  E ### Explanation: ### Since there are 365 valid days in a year, the divisor in calculating the average must be 365. It may appear that segments II and III are incorrect because they include rainfall for invalid days in  total . Since these values are initialized to  0.0 , however, including them in the total wonât affect the final result. ### 
#########################################################
Question: 156 ### 7.  This question is based on the  Point  class below.  public class Point
{
/ ** The coordinates. * /
private int x;
private int y;
public Point (int xValue, int yValue)
{
x = xValue;
y = yValue;
}
/ ** Returns the x-coordinate of this point. * /
public int getx()
{ return x; }
/ ** Returns the y-coordinate of this point. * /
public int gety()
{ return y; }
/ ** Sets x and y to new_x and new_y. * /
public void setPoint(int new_x, int new_y)
{
x = new_x;
y = new_y;
//Other methods are not shown.
  The method  changeNegs  below takes a matrix of  Point  objects as parameter and replaces every  Point  that has as least one negative coordinate with the  Point  (0,0).  ** Replaces every point that has at least one negative coordinate
* with Point (0,0).
*
Precondition: pointMat is initialized with Point objects.
*/
public static void changeNegs (Point [] [] pointMat)
{
/* code */
7
  Which is a correct replacement for  /*    code    */ ?  I. for (int r = 0; r < pointMat. length; r++)
for (int c = 0; c < pointMat [r] . length; c++)
if (pointMat [r] [c].getx() < 0
| | pointMat [r] [c].gety() < 0)
pointMat [r] [c].setPoint(0, 0);
  II. for (int c = 0; c < pointMat [0] . length; c++)
for (int r = 0; r < pointMat. length; r++)
if (pointMat [r] [c].getx() < 0
|| pointMat [r] [c].gety() < 0)
pointMat [r] [c] . setPoint (0, 0);
  III. for (Point [] row : pointMat)
for (Point p : row)
if (p.getx() < 0 || p.gety() < 0)
p.setPoint (0, 0);
 ### A. I only  B. II only  C. III only  D. I and II only  E. I, II, and III ### Correct Answer:  E ### Explanation: ### This is similar to the previous question, but in this case segment III is also correct. This is because instead of  replacing  a matrix element, you are  modifying  it using a mutator method. ### 
#########################################################
Question: 157 ### 8.  A  Pixel  class has several mutator methods that allow the color of a  Pixel  to be changed. For example,  /* Sets amount of red in Pixel to value. * /
public void setRed(int value)
{ /* implementation not shown */ }
  Consider a  Picture  class that has a private instance variable  pixels , which is a 2D array of  Pixel  objects. There are also  int  variables  rows  and  cols  that contain the number of rows and columns in the  pixels  array.   A method  removeRed  in the  Picture  class sets the red value of every pixel to zero.  public void removeRed ()
{
for (int row = 0; row < numRows; row++)
for (int col = 0; col < numCols; col++)
{
/* code to set red value to 0 */
}
  Which is a correct replacement for  /*    code to set red value to 0    */ ?  I. Pixel p = pixels [row] [col]
p.setRed(0) ;
  II.  pixels[row][col].setRed(0);   III.  pixels[row][col] = 0; ### A. I only  B. II only  C. III only  D. I and II only  E. I, II, and III ### Correct Answer:  D ### Explanation: ### Segment I works because  p  is a reference to the element  pixels[row][col] . Changing  p  with a mutator method will change the array. Segment II changes the two-dimensional array directly. Segment III fails because  pixels  is not an array of integers. ### 
#########################################################
Question: 158 ### 9.  Consider a class  MatrixStuff  that has a private instance variable  mat .   private int[][] mat;   The following method uses a vertical mirror down the center of a matrix to reflect the left half of the matrix onto the right. The following two examples show the result of mirroring a two-dimensional array of numbers from left to right vertically. (Another way of saying this is that the right half of the matrix is replaced by a vertical mirror image of the left half.)    Example 1:   mat
mat after mirroring
1
2
3
4
5
1
2
3
2
1
6
7
8
9
10
6
7
8
7
6
11
12.
13
14
15
11
12
13
12
11
    Example 2:   mat
mat after mirroring
1
2
3
4
1
2
2
1
5
6
7
8
5
6
6
5
9
10
11
12
9
10
10
C
  public static void mirrorVerticalLeftToRight (int [] [] mat)
{
int width = mat [0].length;
int numRows = mat.length;
for (int row = 0; row < numRows; row++)
for (int col = 0; col < width/2; col++)
/* element assignments */
  Which replacement for  /*    element assignments    */  will make the method work as intended? ### A.  mat[row][col] = mat[row][width - col];   B.  mat[row][width - col] = mat[row][col];   C.  mat[row][width - 1 - col] = mat[row][col];   D.  mat[row][col] = mat[row][width - 1 - col];   E.  mat[row][width - 1 - col] = mat[col][row]; ### Correct Answer:  C ### Explanation: ### Look at Example 2 for this question:  mat
mat after mirroring
1
2
3
4
1
2
2
1
5
6
7
8
5
6
6
0
10
11
12
10
10
C
  Now consider one element,  12 , say. It must be replaced by its vertical mirror image  9 , i.e.,  mat[2][3]=mat[2][0] . The value of  width  is  4 . See which expression in the answer choices correctly makes this assignment. Eliminate choices A and D right away because  col  can only have the values  0  and  1  in this algorithm, so  mat[2][3]  will not be assigned. In choice B, when  col  has value  1, mat[2][3]=mat[2][1] , an incorrect assignment. Choice C works: when  row  is  2  and  col  is  0, mat[2][3]=mat[2][0] . In choice E, when  row  is  2  and  col  is  0 , the assignment  mat[2][3]=mat[0][2]  is incorrect. ### 
#########################################################
Question: 159 ### 10.  Consider a square matrix in a class that has a private instance variable  mat .   private int[][] mat;   Method  alter  in the class changes  mat .  public void alter()
{
for (int row = 1; row < mat.length; row++)
for (int col = 0; col < row; col++)
mat [col] [row] = mat [row] [col] ;
  If  mat  has current value  {{1, 2, 3}
{4, 5, 6},
{7, 8, 9}}
  what are the contents of  mat  after method  alter  has been executed? ### A. {{1, 4, 7},
{4, 5, 8},
{7, 8, 9}}
  B. {{1, 4, 7},
{2, 5, 8},
{3, 6, 9}}
  C. {{1, 2, 3},
{2, 5, 6},
{3, 6, 9}}
  D. {{9, 6, 3},
{8, 5, 6},
17.
  E. {{1, 2, 3},
{4, 5, 2},
{7, 4, 1}}
 ### Correct Answer:  A ### Explanation: ### Method  alter  places a mirror along the major diagonal and reflects the elements from left to right across this diagonal.  1
2 3
45 6
7 8 9
  In this algorithm, when  row  is  1, col  can only be  0 , and when  row  is  2, col  takes on the values  0  and  1 . Thus, only three elements are altered:  mat[0][1], mat[0][2] , and  mat[1][2] . (Note that the method assigns values to  mat[col][row] .) These elements are all to the right of the diagonal. Choice A is the only choice that leaves elements to the left of the diagonal unchanged. ### 
#########################################################
Question: 160 ### 11.  A simple Tic-Tac-Toe board is a 3 Ã 3 array filled with either Xâs, Oâs, or blanks. Here is a class for a game of Tic-Tac-Toe.  public class TicTacToe
x
0
private String[] [] board;
O
private static final int ROWS = 3;
x
private static final int COLS = 3;
/ ** Construct an empty board. * /
public TicTacToe()
{
board = new String [ROWS] [COLS] ;
for (int r = 0; r < ROWS; r++)
for (int c = 0; c < COLS; c++)
board [r] [c] = " ";
/ ** Places symbol on board [r] [c].
*
Precondition: The square board[r] [c] is empty.
*/
public void makeMove(int r, int c, String symbol)
{
board[r] [c] = symbol;
}
/ ** Creates a string representation of the board, e.g.
*
1
*
| xx |
-
*
0
* Returns the string representation of board.
*/
public String toString()
{
String s = "";
//empty string
/* more code */
return s;
  Which segment represents a correct replacement for  /*    more code    */  for the  toString  method? ### A. for (int r = 0; r < ROWS; r++)
for (int c = 0; c < COLS; c++)
{
S = s + "| ";
S = s + board [r] [c] ;
s = s + "|n";
}
}
  B. for (int r = 0; r < ROWS; r++)
s = s + "|";
for (int c = 0; c < COLS; c++)
{
S = s + board [r] [c] ;
s = s + "|n";
}
}
  C. for (int r = 0; r < ROWS; r++)
{
S = s + "| ";
for (int c = 0; c < COLS; c++)
s = s + board [r] [c] ;
}
S = s + "| n";
  D. for (int r = 0; r < ROWS; r++)
S = s + "| ";
for (int c = 0; c < COLS; c++)
{
S = s + board [r] [c] ;
S = s + "|n";
  E. for (int r = 0; r < ROWS; r++)
s = s + "| ";
for (int c = 0; c < COLS; c++)
s = s + board [r] [c] ;
S = s + "|n";
7
 ### Correct Answer:  E ### Explanation: ### There are three things that must be done in each row:   â  Add an opening boundary line:    s = s + "|";    â  Add the symbol in each square:   for (int c = 0; c < COLS; c++)
s = s + board [r] [c] ;
   â  Add a closing boundary line and go to the next line:    s = s + "|\n";   All of these statements must therefore be enclosed in the outer  for  loop, that is,   for (int r = â¦) ### 
#########################################################
Question: 161 ### 1.  Which of the following statements about recursion are true?  I. Every recursive algorithm can be written iteratively.  II. Tail recursion is always used in "divide-and-conquer" algorithms.  III. In a recursive definition, a process is defined in terms of a simpler case of itself. ### A. I only  B. III only  C. I and II only  D. I and III only  E. II and III only ### Correct Answer:  D ### Explanation: ### Tail recursion is when the recursive call of a method is made as the last executable step of the method. Divide-and-conquer algorithms like those used in merge sort or quicksort have recursive calls  before  the last step. Thus, statement II is false. ### 
#########################################################
Question: 162 ### 2.  Which of the following, when used as the  /*    body    */  of method  sum , will enable that method to compute 1 + 2 + Â·Â·Â· +  n  correctly for any  n  &gt; 0?  Returns 1 + 2 + ... + n.
*
Precondition: n is a positive integer.
*/
public int sum(int n)
{
/* body */
7
  I.  return n + sum(n - 1);   II. if (n == 1)
return 1;
else
urn n + sum(n - 1) ;
  III. if (n == 1)
return 1;
else
return sum(
sum (n) + sum(n - 1);
 ### A. I only  B. II only  C. III only  D. I and II only  E. I, II, and III ### Correct Answer:  B ### Explanation: ### Code segment I is wrong because there is no base case. Code segment III is wrong because, besides anything else,  sum(n)  prevents the method from terminatingâthe base case  n == 1  will not be reached. ### 
#########################################################
Question: 163 ### 3.  Refer to the method  stringRecur .  public void stringRecur (String s)
{
if (s.length() < 15)
System.out.println(s) ;
stringRecur(s + "*") ;
1
  When will method  stringRecur  terminate without error? ### A. Only when the length of the input string is less than 15  B. Only when the length of the input string is greater than or equal to 15  C. Only when an empty string is input  D. For all string inputs  E. For no string inputs ### Correct Answer:  E ### Explanation: ### When  stringRecur  is invoked, it calls itself irrespective of the length of  s . Since there is no action that leads to termination, the method will not terminate until the computer runs out of memory (run-time error). ### 
#########################################################
Question: 164 ### 4.  Refer to method  strRecur .  public void strRecur (String s)
{
if (s.length() < 15)
{
System. out. println(s) ;
strRecur(s + "*");
}
ـل
  When will method  strRecur  terminate without error? ### A. Only when the length of the input string is less than 15  B. Only when the length of the input string is greater than or equal to 15  C. Only when an empty string is input  D. For all string inputs  E. For no string inputs ### Correct Answer:  D ### Explanation: ### The base case is  s.length()  â¥  15 . Since  s  gets longer on each method call, the method will eventually terminate. If the original length of  s  is â¥  15 , the method will terminate without output on the first call. ### 
#########################################################
Question: 165 ### 5.  What value does  result(5)  return? ### A. 64  B. 32  C. 16  D. 8  E. 2 ### Correct Answer:  B ### Explanation: ### Letting  R  denote the method  result , we have  R(5) = 2 * R(4)
=2 * (2 * (R(3)))
=
..
=2 * (2 * (2 * (2 * R(1))))
= 25
=32
 ### 
#########################################################
Question: 166 ### 6.  If  n  &gt; 0, how many times will  result  be called to evaluate  result(n)  (including the initial call)? ### A. 2  B. 2  n    C.  n   D. 2 n   E.  n  2 ### Correct Answer:  C ### Explanation: ### For  result(n)  there will be ( n  ? 1) recursive calls before  result(1) , the base case, is reached. Adding the initial call gives a total of  n  method calls. ### 
#########################################################
Question: 167 ### 7.  Refer to method  mystery .  public int mystery(int n, int a, int d)
{
if (n == 1)
return a;
else
return d + mystery(n - 1, a, d) ;
}
  What value is returned by the call  mystery(3, 2, 6) ? ### A. 20  B. 14  C. 10  D. 8  E. 2 ### Correct Answer:  B ### Explanation: ### This method returns the  n th term of an arithmetic sequence with first term  a  and common difference  d . Letting  M  denote method  mystery , we have  M(3,2,6) = 6+ M(2,2,6)
=6+(6+ M(1,2,6)) (base case)
=6+6+2
- 14
 ### 
#########################################################
Question: 168 ### 8.  Refer to method  f .  public int f (int k, int n)
if (n == k)
return k;
else
if (n > k)
return f(k, n - k);
else
return f(k - n, n);
}
  What value is returned by the call  f(6, 8) ? ### A. 8  B. 4  C. 3  D. 2  E. 1 ### Correct Answer:  D ### Explanation: ### Here are the recursive calls that are made, in order:  f  (6,8) â  f  (6,2) â  f  (4,2) â  f  (2,2), base case. Thus, 2 is returned. ### 
#########################################################
Question: 169 ### 9.  What does method  recur  do?  / ** x is an array of n integers.
*
n is a positive integer.
*/
public int recur (int [] x, int n)
{
int t;
if (n == 1)
return x [0] ;
else
{
t= recur(x, n-1);
if (x[n-1] > t)
return x [n-1] ;
else
return t;
}
}
 ### A. It finds the largest value in  x  and leaves  x  unchanged.  B. It finds the smallest value in  x  and leaves  x  unchanged.  C. It sorts  x  in ascending order and returns the largest value in  x .  D. It sorts  x  in descending order and returns the largest value in  x .  E. It returns  x[0]  or  x[n-1] , whichever is larger. ### Correct Answer:  A ### Explanation: ### If there is only one element in  x , then  recur  returns that element. Having the recursive call at the beginning of the  else  part of the algorithm causes the  if  part for each method call to be stacked until  t  eventually gets assigned to  x[0] . The pending  if  statements are then executed, and  t  is compared to each element in  x . The largest value in  x  is returned. ### 
#########################################################
Question: 170 ### 10.  Which best describes what the  printString  method below does?  public void printString (String s)
{
if (s.length()> 0)
{
printString(s.substring(1));
System.out.print(s.substring(0, 1));
}
ـل
 ### A. It prints string  s .  B. It prints string  s  in reverse order.  C. It prints only the first character of string  s .  D. It prints only the first two characters of string  s .  E. It prints only the last character of string  s . ### Correct Answer:  B ### Explanation: ### Since the recursive call is made directly following the base case, the  System.out.printâ¦  statements are stacked up. If  printString("cat")  is called, here is the sequence of recursive calls and pending statements on the stack:  printString ("at ")
- print "c"
print "t"
printString ("t")
- print "a"
print "a"
printString ("")
- print "t"
print "c"
Execution stack
  When  printString("") , the base case, is called, the  print  statements are then popped off the stack in reverse order, which means that the characters of the string will be printed in reverse order. ### 
#########################################################
Question: 171 ### 1.  Refer to the method  power .  ** Returns base raised to the expo power.
*
Precondition:
*
- base is a nonzero real number.
*
- expo is an integer.
*/
public double power (double base, int expo)
{
if (expo == 0)
return 1;
else if (expo > 0)
return base * power(base, expo - 1) ;
else
return /* code */;
}
  Which  /*    code    */  correctly completes method  power ?  (Recall that  a  - n   = 1/ a   n  ,  a  â  0; for example, 2 -3  = 1/2 3  = 1/8.) ### A.  (1 / base) * power(base, expo + 1)   B.  (1 / base) * power(base, expo - 1)   C.  base * power(base, expo + 1)   D.  base * power(base, expo - 1)   E.  (1 / base) * power(base, expo) ### Correct Answer:  A ### Explanation: ### The required code is for a negative  expo . For example,  power(2, -3)  should return 2 ?3  = 1/8. Notice that  2-3= = (2-2)
2-2 = ↓(2-1)
2-1 = 3 (20)
  In general:  whenever n<0
  This is equivalent to  (1 / base) * power(base, expo + 1) . ### 
#########################################################
Question: 172 ### 2.  Consider the following method.  public void doSomething (int n)
{
if (n > 0)
{
doSomething(n-1);
System.out.print (n);
doSomething(n- 1);
}
  What would be output following the call  doSomething(3) ? ### A.  3211211   B.  1121213   C.  1213121   D.  1211213   E.  1123211 ### Correct Answer:  C ### Explanation: ### Each box in the diagram below represents a recursive call to  doSomething . The numbers to the right of the boxes show the order of execution of the statements. Let D denote  doSomething .  D(3)
D(2)
1
print 3
11
D(2)
12
D(2)
D(2)
D(1)
2
D(1)
13
print 2
6
print 2
(17
D(1)
7
D(1)
18
D(1)
D(1)
D(1)
D(1)
D(0)
3
D(0)
8
D(0)
14
D(0)
19
print 1
4
print 1
print 1
15
print 1
(20)
D(0)
5
D(0)
10
D(0)
16
D(0)
21
  The numbers in each box refer to that method call only. D(0) is the base case, so the statement immediately following it is executed next. When all statements in a given box (method call) have been executed, backtrack along the arrow to find the statement that gets executed next. The circled numbers represent the statements that produce output. Following them in order, statements 4, 6, 9, 11, 15, 17, and 20 produce the output in choice C. ### 
#########################################################
Question: 173 ### 3.  A user enters several positive integers at the keyboard and terminates the list with a sentinel ( -999 ). A  writeEven  method reads those integers and outputs the even integers only, in the reverse order that they are read. Thus, if the user enters   3 5 14 6 1 8 -999   the output for the  writeEven  method will be   8 6 14   Assume that the user enters at least one positive integer and terminates the list with â999. Here is the method.  **
Postcondition: All even integers in the list are output in
*
reverse order.
*/
public static void writeEven()
{
int num = ...;
//read user input
if (num != - 999)
{
/* code */
}
  Which  /*    code    */  satisfies the postcondition of method  writeEven ?  I. if (num % 2 == 0)
System.out. print (num + " ");
writeEven();
  II. if (num % 2 == 0)
writeEven() ;
System. out. print (num + " ");
  III. writeEven() ;
if (num % 2 == 0)
System. out. print (num + " ") ;
 ### A. I only  B. II only  C. III only  D. I and II only  E. I, II, and III ### Correct Answer:  C ### Explanation: ### Since even numbers are printed  before  the recursive call in segment I, they will be printed in the order in which they are read from the keyboard. Contrast this with the correct choice, segment III, in which the recursive call is made before the test for evenness. These tests will be stacked until the last number is read. Recall that the pending statements are removed from the stack in reverse order (most recent recursive call first), which leads to even numbers being printed in reverse order. Segment II is wrong because all numbers entered will be printed, irrespective of whether they are even or not. Note that segment II would work if the input list contained only even numbers. ### 
#########################################################
Question: 174 ### 4.  Refer to the following recursive method.  public int mystery (int n)
{
if (n < 0)
return 2;
else
return mystery(n- 1) + mystery(n - 3) ;
  What value is returned by the call  mystery(3) ? ### A. 12  B. 10  C. 8  D. 6  E. 4 ### Correct Answer:  A ### Explanation: ### Let  mystery(3)  be denoted  m (3). Picture the execution of the method as follows:  m(3)
m(2)
m(0)
m(1)
m(-1)
m(-1)
m(-3)
m(0)
m(-2)
m(-1)
m(-3)
  The base cases are shaded. Note that each of the six base case calls returns 2, resulting in a total of 12. ### 
#########################################################
Question: 175 ### 5.  What will be returned by  t(5) ? ### A. 4  B. 2  C. 0  D. -2  E. -4 ### Correct Answer:  E ### Explanation: ### The method generates a sequence. The first two terms,  t (1) and  t (2), are 2 and 4. Each subsequent term is generated by subtracting the previous two terms. This is the sequence: 2, 4, 2, ?2, ?4, ?2, 2, 4, â¦. Thus,  t (5) = ?4. Alternatively,  t(5) = t(4) - t(3)
= [t(3) - t(2)] - t(3)
=- t(2)
=- 4
 ### 
#########################################################
Question: 176 ### 6.  For the method call  t(6) , how many calls to  t  will be made, including the original call? ### A. 6  B. 7  C. 11  D. 15  E. 25 ### Correct Answer:  D ### Explanation: ### Count them! (Note that you stop at  t (2) since itâs a base case.)  t(6)
t(5)
t(4)
t(4)
t(3)
t(3)
t(2)
t(3)
/
t(2)
t(2)
t(1)
t(2)
t(1)
t(2)
t(1)
 ### 
#########################################################
Question: 177 ### 7.  This question refers to methods  f1  and  f2  that are in the same class.  public int f1(int a, int b)
{
if (a == b)
return b;
else
return a + f2(a - 1, b);
}
public int f2(int p, int q)
{
if (p < q)
return p + q;
else
return p+ f1(p - 2, q) ;
}
  What value will be returned by a call to  f1(5, 3) ? ### A. 5  B. 6  C. 7  D. 12  E. 15 ### Correct Answer:  E ### Explanation: ### This is an example of  mutual recursion , where two methods call each other.  fi (5,3) = 5 + f2(4,3)
=5+(4+ f1(2,3))
=5+(4+(2+f2(1,3)))
=5+(4+(2+4))
-15
  Note that  f <sub>2</sub>(1,3) is a base case. ### 
#########################################################
Question: 178 ### 8.  Consider method  foo .  public int foo (int x)
{
if (x == 1 || x == 3)
return x;
else
return x * foo(x - 1);
  Assuming no possibility of integer overflow, what will be the value of  z  after execution of the following statement? Note that  n ! = ( n )( n  - 1)( n  - 2)â¦ (2)(1).   int z = foo(foo(3) + foo(4)); ### A. (15!)/(2!)  B. 3! + 4!  C. (7!)!  D. (3! + 4!)!  E. 15 ### Correct Answer:  A ### Explanation: ### foo(3) = 3 (this is a base case). Also, foo(4) = 4 Ã foo(3) = 12. So you need to find foo(foo(3) + foo(4)) = foo(15).  foo(15) = 15 x foo(14)
= 15 x (14 × foo(13))
=...
= 15 x 14 x · · · × 4 × foo(3)
=15×14x ··· ×4×3
= (15)!/(2!)
 ### 
#########################################################
Question: 179 ### 9.  The method  writeWithCommas  is supposed to print its nonnegative  int  argument with commas properly inserted (every three digits, starting at the right). For example, the integer 27048621 should be printed as 27,048,621. Method  writeWithCommas  does not always work as intended, however. Assuming no integer overflow, which of the following integer arguments will not be printed correctly? ### A. 896  B. 251462251  C. 365051  D. 278278  E. 4 ### Correct Answer:  C ### Explanation: ### Suppose that  n  = 365051. The method call  writeWithCommas(365051)  will write  051  and then execute the call  writeWithCommas(365) . This is a base case, so  365  will be written out, resulting in  051,365 . A number like 278278 (two sets of three identical digits) will be written out correctly, as will a "symmetrical" number like 251462251. Also, any  n  &lt; 1000 is a base case and the number will be written out correctly as is. ### 
#########################################################
Question: 180 ### 10.  Which change in the code of the given methods will cause method  writeWithCommas  to work as intended? ### A. Interchange the lines  System.out.print(n / 100)  and  System.out.print(n % 10)  in method  writeThreeDigits .  B. Interchange the lines  writeThreeDigits(n % 1000)  and  writeWithCommas(n / 1000)  in method  writeWithCommas .  C. Change the test in  writeWithCommas  to  if (n &gt; 1000) .  D. In the method  writeWithCommas , change the line  writeThreeDigits(n % 1000)  to  writeThreeDigits(n / 1000) .  E. In the method  writeWithCommas , change the recursive call  writeWithCommas(n / 1000)  to  writeWithCommas(n % 1000) . ### Correct Answer:  B ### Explanation: ### The cause of the problem is that the numbers are being written out with the sets of three digits in the wrong order. The problem is fixed by interchanging  writeThreeDigits(n % 1000)  and  writeWithCommas(n / 1000) . For example, here is the order of execution for  writeWithCommas(365051) .   writeWithCommas (365) -> Base case. Writes 365
System.out.print(","); - 365,
writeThreeDigits(051) -> 365, 051, which is correct
 ### 
#########################################################
Question: 181 ### 11.  Consider the following method.  public static void sketch(int x1, int y1, int x2, int y2, int n)
{
if (n <= 0)
y
drawLine(x1, y1,x2, y2);
else
{
int xm = (x1 +x2 +y1-y2) / 2;
X
intym= (y1 +y2+x2-x1) / 2;
sketch(x1, y1, xm, ym, n-1);
sketch(xm, ym, x2, y2, n-1);
}
7
  Assume that the screen looks like a Cartesian coordinate system with the origin at the center, and that  drawLine  connects ( x1 , y1 ) to ( x2 , y2 ). Assume also that  x1, y1, x2 , and  y2  are never too large or too small to cause errors. Which picture best represents the sketch drawn by the method call   sketch(a, 0, -a, 0, 2)   where  a  is a positive integer? ### A. <img  src="https://img.crackap.com/ap/computer-science-a/br23/f0336-01.jpg"/>  B. <img  src="https://img.crackap.com/ap/computer-science-a/br23/f0336-02.jpg"/>  C. <img  src="https://img.crackap.com/ap/computer-science-a/br23/f0336-03.jpg"/>  D. <img  src="https://img.crackap.com/ap/computer-science-a/br23/f0336-04.jpg"/>  E. <img  src="https://img.crackap.com/ap/computer-science-a/br23/f0336-05.jpg"/> ### Correct Answer:  B ### Explanation: ### Here is the "box diagram" for the recursive method calls, showing the order of execution of statements. Notice that the circled statements are the base case calls, the only statements that actually draw a line. Note also that the first time you reach a base case (see circled statement 6), you can get the answer: The picture in choice B is the only one that has a line segment joining  (a,0)  to  (a,-a) .  sketch (a, 0,-a, 0,2)
xm = 0
1
ym = - a
2
sketch(a,0,0,-a,1)
3
sketch(0,-a,-a,0,1)
8
sketch(a,0,0,-a,1)
sketch(0,-a,-a,0,1)
xm = a
4
xm = - a
9
ym = - a
5
ym = - a
10
sketch(a,0,a,-a,0)
6
sketch(0,-a,-a,-a,0)
11
sketch(a,-a,0,-a,0)
7
y
sketch(-a,-a,-a,0,0)
12
a
-a
a
x
12
0
-a
11
7
 ### 
#########################################################
Question: 182 ### 1.  The decision to choose a particular sorting algorithm should be made based on which of the following?  I. Run-time efficiency of the sort  II. Size of the array  III. Space efficiency of the algorithm ### A. I only  B. II only  C. III only  D. I and II only  E. I, II, and III ### Correct Answer:  E ### Explanation: ### The time and space requirements of sorting algorithms are affected by all three of the given factors, so all must be considered when choosing a particular sorting algorithm. ### 
#########################################################
Question: 183 ### 2.  The following code fragment does a sequential search to determine whether a given integer,  value , is stored in an array  a[0]  â¦  a[n-1] .  int i = 0;
while (/* boolean expression */)
{
i++;
}
if (i == n)
return -1;
//value not found
else
return i;
// value found at location i
  Which of the following should replace  /*    boolean expression    */  so that the algorithm works as intended? ### A.  value != a[i]   B.  i &lt; n &amp;&amp; value == a[i]   C.  value != a[i] &amp;&amp; i &lt; n   D.  i &lt; n &amp;&amp; value != a[i]   E.  i &lt; n || value != a[i] ### Correct Answer:  D ### Explanation: ### Choice B doesnât make sense: The loop will be exited as soon as a value is found that does  not  equal  a[i] . Eliminate choice A because, if  value  is not in the array,  a[i]  will eventually go out of bounds. You need the  i &lt; n  part of the boolean expression to avoid this. The test  i &lt; n , however, must precede  value != a[i]  so that if  i &lt; n  fails, the expression will be evaluated as false, the test will be short-circuited, and an out-of-range error will be avoided. Choice C does not avoid this error. Choice E is wrong because both parts of the expression must be true in order to continue the search. ### 
#########################################################
Question: 184 ### 3.  A feature of data that is used for a binary search but not necessarily used for a sequential search is ### A. length of list.  B. type of data.  C. order of data.  D. smallest value in the list.  E. median value of the data. ### Correct Answer:  C ### Explanation: ### The binary search algorithm depends on the array being sorted. Sequential search has no ordering requirement. Both depend on choice A, the length of the list, while the other choices are irrelevant to both algorithms. ### 
#########################################################
Question: 185 ### 4.  Array  unsortedArr  contains an unsorted list of integers. Array  sortedArr  contains a list of integers sorted in increasing order. Which of the following operations is more efficient for  sortedArr  than  unsortedArr ? Assume the most efficient algorithms are used.  I. Inserting a new element  II. Searching for a given element  III. Computing the mean of the elements ### A. I only  B. II only  C. III only  D. I and II only  E. I, II, and III ### Correct Answer:  B ### Explanation: ### Inserting a new element is quick and easy in an unsorted arrayâjust add it to the end of the list. Computing the mean involves finding the sum of the elements and dividing by  n , the number of elements. The execution time is the same whether the list is sorted or not. Operation II, searching, is inefficient for an unsorted list, since a sequential search must be used. In  sortedArr , the efficient binary search algorithm, which involves fewer comparisons, could be used. In fact, in a sorted list, even a sequential search would be more efficient than for an unsorted list: If the search item were not in the list, the search could stop as soon as the list elements were greater than the search item. ### 
#########################################################
Question: 186 ### 5.  An algorithm for searching a large sorted array for a specific value  x  compares every third item in the array to  x  until it finds one that is greater than or equal to  x . When a larger value is found, the algorithm compares  x  to the previous two items. If the array is sorted in increasing order, which of the following describes all cases when this algorithm uses fewer comparisons to find  x  than would a binary search? ### A. It will never use fewer comparisons.  B. When  x  is in the middle position of the array  C. When  x  is very close to the beginning of the array  D. When  x  is very close to the end of the array  E. When  x  is not in the array ### Correct Answer:  C ### Explanation: ### Suppose the array has 1000 elements and  x  is somewhere in the first 8 slots. The algorithm described will find  x  using no more than five comparisons. A binary search, by contrast, will chop the array in half and do a comparison six times before examining elements in the first 15 slots of the array (array size after each chop: 500, 250, 125, 62, 31, 15). ### 
#########################################################
Question: 187 ### 6.  Assume that  a[0]  â¦  a[N-1]  is an array of  N  positive integers and that the following assertion is true.   a[0] &gt; a[k] for all k such that 0 &lt; k &lt; N   Which of the following  must  be true? ### A. The array is sorted in ascending order.  B. The array is sorted in descending order.  C. All values in the array are different.  D.  a[0]  holds the smallest value in the array.  E.  a[0]  holds the largest value in the array. ### Correct Answer:  E ### Explanation: ### The assertion states that the first element is greater than all the other elements in the array. This eliminates choices A and D. Choices B and C are incorrect because you have no information about the relative sizes of elements  a[1]â¦a[N-1] . ### 
#########################################################
Question: 188 ### 7.  The following code is designed to set  index  to the location of the first occurrence of  key  in array  a  and to set  index  to -1 if  key  is not in  a .  index = 0;
while (a[index] != key)
index++;
if (a[index] != key)
index = - 1;
  In which case will this program  definitely  fail to perform the task described? ### A. When  key  is the first element of the array  B. When  key  is the last element of the array  C. When  key  is not in the array  D. When  key  equals 0  E. When  key  equals  a[key] ### Correct Answer:  C ### Explanation: ### When  key  is not in the array,  index  will eventually be large enough that  a[index]  will cause an  ArrayIndexOutOfBoundsException . In choices A and B, the algorithm will find  key  without error. Choice D wonât fail if 0 is in the array. Choice E will work if  a[key]  is not out of range. ### 
#########################################################
Question: 189 ### 8.  Consider the following class.  / ** A class that sorts an array of Integer objects from
*
largest to smallest using a selection sort.
*/
public class Sorter
private Integer []
a;
public Sorter(Integer []
arr)
{ a = arr; }
/ ** Swap a[i] and a[j] in array a. * /
private void swap(int i, int j)
{ /* implementation not shown */ }
/ ** Sort array a from largest to smallest using selection sort
*
Precondition: a is an array of Integer objects.
*/
public void selectionSort ()
{
for (int i = 0; i < a.length - 1; i++)
{
//find max element in a[i+1] to a[n-1]
Integer max = a [i];
int maxPos = i;
for (int j= i + 1; j < a.length; j++)
if (max. compareTo(a[j]) < 0) //max less than a[j]
{
max = a[j];
maxPos = j;
swap(i, maxPos) ;
/ /swap a[i] and a [maxPos]
}
}
2
  If an array of  Integer  contains the following elements, what would the array look like after the third pass of  selectionSort , sorting from high to low?  89  42  -3
13  109  70 ### A. <img  src="https://img.crackap.com/ap/computer-science-a/br23/e0354-02.jpg"/>  B. <img  src="https://img.crackap.com/ap/computer-science-a/br23/e0354-03.jpg"/>  C. <img  src="https://img.crackap.com/ap/computer-science-a/br23/e0354-04.jpg"/>  D. <img  src="https://img.crackap.com/ap/computer-science-a/br23/e0354-05.jpg"/>  E. <img  src="https://img.crackap.com/ap/computer-science-a/br23/e0354-06.jpg"/> ### Correct Answer:  A ### Explanation: ### After 1st pass:
109
42
-3
13
89
70
2
After 2nd pass:
109
89
-3
13
42
70
2
After 3rd pass:
109
89
70
13
42
-3
2
 ### 
#########################################################
Question: 190 ### 9.  Refer to method  search .  **
Returns value k such that -1 <= k <= v. length-1.
If k >= 0 then v [k] == key.
*
* If k == - 1, then key != any of the elements in v.
*/
public static int search(int [] v, int key)
int index = 0;
while (index < v.length && v[index] < key)
index++;
if (v[index] == key)
return index;
else
return -1;
}
  Assuming that the method works as intended, which of the following should be added to the precondition of  search ? ### A.  v  is sorted smallest to largest.  B.  v  is sorted largest to smallest.  C.  v  is unsorted.  D. There is at least one occurrence of  key  in  v .  E.  key  occurs no more than once in  v . ### Correct Answer:  A ### Explanation: ### The algorithm uses the fact that array  v  is sorted smallest to largest. The  while  loop terminatesâwhich means that the search stopsâas soon as  v[index] &gt;= key . ### 
#########################################################
Question: 191 ### 1.  To find the key value 27, the search interval  after  the first pass through the  while  loop will be ### A.  a[0]  â¦  a[7]   B.  a[5]  â¦  a[6]   C.  a[4]  â¦  a[7]   D.  a[2]  â¦  a[6]   E.  a[6]  â¦  a[7] ### Correct Answer:  C ### Explanation: ### The first pass uses the interval  a[0]â¦a[7] . Since  mid  = (0 + 7)/2 = 3,  low  gets adjusted to  mid  + 1 = 4, and the second pass uses the interval  a[4]â¦a[7] . ### 
#########################################################
Question: 192 ### 2.  How many iterations will be required to determine that 27 is not in the list? ### A. 1  B. 3  C. 4  D. 8  E. 16 ### Correct Answer:  B ### Explanation: ### First pass: Compare 27 with  a[3] , since  low  = 0  high  = 7  mid  = (0 + 7)/2 = 3. Second pass: Compare 27 with  a[5] , since  low  = 4  high  = 7  mid  = (4 + 7)/2 = 5. Third pass: Compare 27 with  a[6] , since  low  = 6  high  = 7  mid  = (6 + 7)/2 = 6. The fourth pass doesnât happen, since  low  = 6 and  high  = 5, and therefore the test  (low &lt;= high)  fails. Using the general rule for finding the number of iterations when  key  is not in the list: If  n  is the number of elements, round  n  up to the nearest power of 2, which is 8 in this case. Note that 8 = 2 3 . Since 27 lies between 4 and 41, there will be 3 iterations of the "divide-and-compare" loop. ### 
#########################################################
Question: 193 ### 3.  What will be stored in  y  after executing the following?   int y = binSearch(4); ### A.  20   B.  7   C.  4   D.  0   E.  -1 ### Correct Answer:  D ### Explanation: ### The method returns the index of the  key  parameter, 4. Since  a[0]  contains 4,  binSearch(4)  will return 0. ### 
#########################################################
Question: 194 ### 4.  If the test for the  while  loop is changed to   while (low &lt; high)   the  binSearch  method does not work as intended. Which value in the given list will not be found? ### A. 4  B. 7  C. 11  D. 24  E. 30 ### Correct Answer:  A ### Explanation: ### Try 4. Here are the values for  low, high , and  mid  when searching for 4:   Ist pass:
low = 0,
high = 7,
mid = 3
2nd pass:
low = 0,
high = 2,
mid=1
  After this pass,  high  gets adjusted to  mid  ?1, which is 0. Now  low  equals  high , and the test for the  while  loop fails. The method returns ?1, indicating that 4 wasnât found. ### 
#########################################################
Question: 195 ### 5.  For  binSearch , which of the following assertions will be true following every iteration of the  while  loop? ### A.  key  =  a[mid]  or  key  is not in  a .  B.  a[low]  â¤  key  â¤  a[high]   C.  low  â¤  mid  â¤  high   D.  key  =  a[mid] , or  a[low]  â¤  key  â¤  a[high]   E.  key  =  a[mid] , or  a[low]  â¤  key  â¤  a[high] , or  key  is not in array  a . ### Correct Answer:  E ### Explanation: ### When the loop is exited, either  key  =  a[mid]  (and  mid  has been returned) or  key  has not been found, in which case either  a[low]  â¤  key  â¤  a[high]  or  key  is not in the array. The correct assertion must account for all three possibilities. ### 
#########################################################
Question: 196 ### 6.  A large sorted array containing about 30,000 elements is to be searched for a value  key  using an iterative binary search algorithm. Assuming that  key  is in the array, which of the following is closest to the smallest number of iterations that will guarantee that  key  is found? Note: 10 3  â 2 10 . ### A. 15  B. 30  C. 100  D. 300  E. 3000 ### Correct Answer:  A ### Explanation: ### 30,000 = 1000 Ã 30 â 2 10  Ã 2 5  = 2 15 . Since a successful binary search in the worst case requires log<sub>2</sub>  n  iterations, 15 iterations will guarantee that  key  is found. (Note that 30,000 &lt; 2 10  Ã 2 5  = 32,768.) Shortcut: 30,000 &lt; 2 15 . Therefore, the maximum (worst case) number of comparisons that guarantees the key is found is equal to the exponent, 15. ### 
#########################################################
Question: 197 ### 7.  An array of  Integer  is to be sorted biggest to smallest using the  insertionSort  method. If the array originally contains  1
7
9
5
4
12  what will it look like after the third pass of the  for  loop? ### A. 9 7 1 5 4 12  B. 9 7 5 1 4 12  C. 12 9 7 1 5 4  D. 12 9 7 5 4 1  E. 9 7 12 5 4 1 ### Correct Answer:  B ### Explanation: ### Start with the second element in the array.  After 1st pass:
7
1
9
5
4
12
After 2nd pass:
9
7
1
5
4
12
After 3rd pass:
9
7
5
1
4
12
 ### 
#########################################################
Question: 198 ### 8.  When sorted biggest to smallest with  insertionSort , which list will need the fewest changes of position for individual elements? ### A. 5, 1, 2, 3, 4, 9  B. 9, 5, 1, 4, 3, 2  C. 9, 4, 2, 5, 1, 3  D. 9, 3, 5, 1, 4, 2  E. 3, 2, 1, 9, 5, 4 ### Correct Answer:  B ### Explanation: ### An insertion sort compares  a[1]  and  a[0] . If they are not in the correct order,  a[0]  is moved and  a[1]  is inserted in its correct position.  a[2]  is then inserted in its correct position, and  a[0]  and  a[1]  are moved if necessary, and so on. Since B has only one element out of order, it will require the fewest changes. ### 
#########################################################
Question: 199 ### 9.  When sorted biggest to smallest with  insertionSort , which list will need the greatest number of changes in position? ### A. 5, 1, 2, 3, 4, 7, 6, 9  B. 9, 5, 1, 4, 3, 2, 1, 0  C. 9, 4, 6, 2, 1, 5, 1, 3  D. 9, 6, 9, 5, 6, 7, 2, 0  E. 3, 2, 1, 0, 9, 6, 5, 4 ### Correct Answer:  A ### Explanation: ### This list is almost sorted in reverse order, which is the worst case for insertion sort, requiring the greatest number of comparisons and moves. ### 
#########################################################
Question: 200 ### 10.  While typing the  insertionSort  method, a programmer by mistake enters   while (temp &gt; a[j])   instead of   while (j &gt;= 0 &amp;&amp; temp &gt; a[j])   Despite this mistake, the method works as intended the first time the programmer enters an array to be sorted in descending order. Which of the following could explain this?  I. The first element in the array was the largest element in the array.  II. The array was already sorted in descending order.  III. The first element was less than or equal to all the other elements in the array. ### A. I only  B. II only  C. III only  D. I and II only  E. II and III only ### Correct Answer:  D ### Explanation: ### j &gt;= 0  is a stopping condition that prevents an element that is larger than all those to the left of it from going off the left end of the array. If no error occurred, it means that the largest element in the array was  a[0] , which was true in situations I and II. Omitting the  j &gt;= 0  test will cause a run-time (out-of-range) error whenever  temp  is bigger than all elements to the left of it (i.e., the insertion point is  0 ). ### 
#########################################################
Question: 201 ### 1.  The elements in a long list of integers are roughly sorted in decreasing order. No more than 5 percent of the elements are out of order. Which of the following is a valid reason for using an insertion sort rather than a selection sort to sort this list into decreasing order?  I. There will be fewer comparisons of elements for insertion sort.  II. There will be fewer changes of position of elements for insertion sort.  III. There will be less space required for insertion sort. ### A. I only  B. II only  C. III only  D. I and II only  E. I, II, and III ### Correct Answer:  A ### Explanation: ### Look at a small array that is almost sorted:  10 8 9 6 2  For <span class="underline">insertion sort , you need four passes through this array.  The first pass compares 8 and 10âone comparison, no moves.  The second pass compares 9 and 8, then 9 and 10. The array becomes 10 9 8 6 2âtwo comparisons, two moves.  The third and fourth passes compare 6 and 8, and 2 and 6âno moves.  In summary, there are approximately one or two comparisons per pass and no more than two moves per pass.  For <span class="underline">selection sort , there are four passes too.  The first pass finds the biggest element in the array and swaps it into the first position.  The array is still 10 8 9 6 2âfour comparisons. There are two moves if your algorithm makes the swap in this case, otherwise no moves.  The second pass finds the biggest element from  a[1]  to  a[4]  and swaps it into the second position: 10 9 8 6 2âthree comparisons, two moves.  For the third pass there are two comparisons, and one for the fourth. There are zero or two moves each time.  Summary: 4 + 3 + 2 + 1 total comparisons and a possible two moves per pass.  Notice that reason I is valid. Selection sort makes the same number of comparisons irrespective of the state of the array. Insertion sort does far fewer comparisons if the array is almost sorted. Reason II is invalid. There are roughly the same number of data movements for insertion and selection. Insertion may even have more changes, depending on how far from their insertion points the unsorted elements are. Reason III is wrong because insertion and selection sorts have the same space requirements. ### 
#########################################################
Question: 202 ### 2.  Which of the following is a valid reason why merge sort is a better sorting algorithm than insertion sort for sorting long, randomly ordered lists?  I. Merge sort requires less code than insertion sort.  II. Merge sort requires less storage space than insertion sort.  III. Merge sort runs faster than insertion sort. ### A. I only  B. II only  C. III only  D. I and II only  E. II and III only ### Correct Answer:  C ### Explanation: ### Reject reason I. Merge sort requires both a  merge  and a  mergeSort  methodâ more  code than the relatively short and simple code for insertion sort. Reject reason II. The  merge  algorithm uses a temporary array, which means  more  storage space than insertion sort. Reason III is correct. For long lists, the "divide-and-conquer" approach of merge sort gives it a faster run time than insertion sort. ### 
#########################################################
Question: 203 ### 3.  A large array of lowercase characters is to be searched for the pattern "pqrs." The first step in a very efficient searching algorithm is to look at characters with index ### A. 0, 1, 2, â¦ until a "p" is encountered.  B. 0, 1, 2, â¦ until any letter in "p" â¦ "s" is encountered.  C. 3, 7, 11, â¦ until an "s" is encountered.  D. 3, 7, 11, â¦ until any letter in "p" â¦ "s" is encountered.  E. 3, 7, 11, â¦ until any letter other than "p" â¦ "s" is encountered. ### Correct Answer:  D ### Explanation: ### Since the search is for a four-letter sequence, the idea in this algorithm is that if you examine every fourth slot, youâll find a letter in the required sequence very quickly. When you find one of these letters, you can then examine adjacent slots to check if you have the required sequence. This method will, on average, result in fewer comparisons than the strictly sequential search algorithm in choice A. Choice B is wrong. If you encounter a "q," "r," or "s" without a "p" first, you canât have found "pqrs." Choice C is wrong because you may miss the sequence completely. Choice E doesnât make sense. ### 
#########################################################
Question: 204 ### 4.  The array  names[0], names[1] , â¦,  names[9999]  is a list of 10,000 name strings. The list is to be searched to determine the location of some name  X  in the list. Which of the following preconditions is necessary for a binary search? ### A. There are no duplicate names in the list.  B. The number of names  N  in the list is large.  C. The list is in alphabetical order.  D. Name  X  is definitely in the list.  E. Name  X  occurs near the middle of the list. ### Correct Answer:  C ### Explanation: ### The main precondition for a binary search is that the list is ordered. ### 
#########################################################
Question: 205 ### 5.  Consider the following method.  / ** Precondition: a [0] , a [1] ... a[n-1] contain integers. * /
public static int someMethod(int [] a, int n, int value)
{
if (n == 0)
return -1;
else
{
if (a[n-1] == value)
return n - 1;
else
return someMethod(a, n - 1, value) ;
}
ـل
  The method shown is an example of ### A. insertion sort.  B. merge sort.  C. selection sort.  D. binary search.  E. sequential search. ### Correct Answer:  E ### Explanation: ### This algorithm is just a recursive implementation of a sequential search. It starts by testing if the last element in the array,  a[n-1] , is equal to  value . If so, it returns the index  n - 1 . Otherwise, it calls itself with  n  replaced by  n - 1 . The net effect is that it examines  a[n-1], a[n-2] , â¦. The base case,  if (n == 0) , occurs when there are no elements left to examine. In this case, the method returns ?1, signifying that  value  was not in the array. ### 
#########################################################
Question: 206 ### 6.  The  partition  method for quicksort partitions a list as follows.  (i) A pivot element is selected from the array.   (ii) The elements of the list are rearranged such that all elements to the left of the pivot are less than or equal to it; all elements to the right of the pivot are greater than or equal to it.  Partitioning the array requires which of the following? ### A. A recursive algorithm  B. A temporary array  C. An external file for the array  D. A swap algorithm for interchanging array elements  E. A merge method for merging two sorted lists ### Correct Answer:  D ### Explanation: ### The  partition  algorithm performs a series of swaps until the pivot element is swapped into its final sorted position. No temporary arrays or external files are used, nor is a recursive algorithm invoked. The  merge  method is used for merge sort, not quicksort. ### 
#########################################################
Question: 207 ### 7.  Assume that merge sort will be used to sort an array  arr  of  n  integers into increasing order. What is the purpose of the  merge  method in the merge sort algorithm? ### A. Partition  arr  into two parts of roughly equal length, then merge these parts.  B. Use a recursive algorithm to sort  arr  into increasing order.  C. Divide  arr  into  n  subarrays, each with one element.  D. Merge two sorted parts of  arr  into a single sorted array.  E. Merge two sorted arrays into a temporary array that is sorted. ### Correct Answer:  D ### Explanation: ### Recall the merge sort algorithm:   Divide  arr  into two parts.   Merge sort the left side.   Merge sort the right side.   Merge the two sides into a single sorted array.  The  merge  method is used for the last step of the algorithm. It does not do any sorting or partitioning of the array, which eliminates choices A, B, and C. Choice E is wrong because  merge  starts with a  single  array that has two sorted parts. ### 
#########################################################
Question: 208 ### 1.  A binary search is to be performed on an array with 600 elements. In the  worst  case, which of the following best approximates the number of iterations of the algorithm? ### A. 6  B. 10  C. 100  D. 300  E. 600 ### Correct Answer:  B ### Explanation: ### Round 600 up to the next power of 2, which is 1024 = 2 10 . Recall the shortcut: 600 &lt; 2 10 , so the worst case equals the exponent, 10. ### 
#########################################################
Question: 209 ### 2.  A worst case situation for insertion sort would be  I. A list in correct sorted order.  II. A list sorted in reverse order.  III. A list in random order. ### A. I only  B. II only  C. III only  D. I and II only  E. II and III only ### Correct Answer:  B ### Explanation: ### If the list is sorted in reverse order, each pass through the array will involve the maximum possible number of comparisons and the maximum possible number of element movements if an insertion sort is used. ### 
#########################################################
Question: 210 ### 3.  Consider a binary search algorithm to search an ordered list of numbers. Which of the following choices is closest to the maximum number of times that such an algorithm will execute its main comparison loop when searching a list of 1 million numbers? ### A. 6  B. 20  C. 100  D. 120  E. 1000 ### Correct Answer:  B ### Explanation: ### 1 million = 10 6  = (10 3 ) 2  â (2 10 ) 2  = 2 20 . Thus, there will be on the order of 20 comparisons. ### 
#########################################################
Question: 211 ### 4.  Consider these three tasks.  I. A sequential search of an array of  n  names  II. A binary search of an array of  n  names in alphabetical order  III. An insertion sort into alphabetical order of an array of  n  names that are initially in random order  For large  n , which of the following lists these tasks in order (from least to greatest) of their average case run times? ### A. II I III  B. I II III  C. II III I  D. III I II  E. III II I ### Correct Answer:  A ### Explanation: ### A binary search, on average, has a smaller run time than a sequential search. All of the sorting algorithms have greater run times than a sequential search. This is because a sequential search looks at each element once. A sorting algorithm, however, processes  other  elements in the array for each element it looks at. ### 
#########################################################
Question: 212 ### 5.  Suppose the game is programmed so that the computer uses a binary search strategy for making its guesses. What is the maximum number of guesses the computer could make before guessing the userâs number? ### A. 50  B. 25  C. 10  D. 7  E. 6 ### Correct Answer:  D ### Explanation: ### The computer should find the number in no more than seven tries. This is because the guessing interval is halved on each successive try:  <div class="table-responsive"><table class="table table-bordered"><tr><td> (1) </td><td>  100 Ã· 2 = 50 numbers left to try </td></tr><tr><td> (2) </td><td> 50 Ã· 2 = 25 numbers left to try </td></tr><tr><td> (3) </td><td> 25 Ã· 2 = 13 numbers left to try </td></tr><tr><td> (4) </td><td> 13 Ã· 2 = 7 numbers left to try </td></tr><tr><td> (5) </td><td> 7 Ã· 2 = 4 numbers left to try </td></tr><tr><td> (6) </td><td> 4 Ã· 2 = 2 numbers left to try </td></tr><tr><td> (7) </td><td> 2 Ã· 2 = 1 number left to try </td></tr></table>  Seven iterations of the loop leaves just 1 number left to try! Donât forget the shortcut. The algorithm is a binary search of 100 possible elements. Rounding 100 up to the next power of 2 gives 128 = 2 7 . The exponent, 7, is the number of guesses in the worst case. ### 
#########################################################
Question: 213 ### 6.  Suppose the computer used a  sequential search  strategy for guessing the userâs number. What is the maximum number of guesses the computer could make before guessing the userâs number? ### A. 100  B. 99  C. 50  D. 25  E. 10 ### Correct Answer:  B ### Explanation: ### The maximum number of guesses is 99. A sequential search means that the computer starts at the first possible numberânamely, 1âand tries each successive number until it gets to 99. If the userâs number is 100, the computer will know that when it tests 99. ### 
#########################################################
Question: 214 ### 7.  Using a sequential search strategy, how many guesses  on average  would the computer need to guess the number? ### A. 100  B. Between 51 and 99  C. 50  D. 25  E. Fewer than 25 ### Correct Answer:  C ### Explanation: ### On average the computer will make 50 guesses. The user is equally likely to pick any number between 1 and 100. Half the time it will be less than 50; half the time, greater than 50. So on the average, the distance of the number from 1 is 50. ### 
#########################################################
Question: 215 ### 1.  Consider the following two methods in the same class.  public static void changeArray (int [] arr)
{
for (int i = 0; i < arr.length - 1; i++)
{
arr[i] = arr[i + 1];
}
arr [arr.length - 1] = arr [0] ;
public static void changeMatrix(int [] [] mat)
{
for (int i = 0; i <mat.length; i++)
{
changeArray(mat [i]) ;
  If the current state of   mat  is <pre>        1 2 3 4 <br/>        5 6 7 8 </pre> which matrix will result from the method call   changeMatrix(mat);  ? ### A. <pre>1 2 3 4<br/>5 6 7 8 </pre>  B. <pre>2 3 4 1<br/>6 7 8 5 </pre>  C. <pre>4 1 2 3<br/>8 5 6 7 </pre>  D. <pre>3 1 2 3<br/>7 5 6 7 </pre>  E. <pre>2 3 4 2<br/>6 7 8 6 </pre> ### Correct Answer:  E ### Explanation: ### Answer: E   The  changeArray  method shifts the elements of its array parameter (except for  a[0] , which gets overwritten) one slot to the left. Then it sets  a[a.length-1] , the rightmost element, to the current value of  a[0] . The  changeMatrix  method changes each of its rows in this way. Note that  mat[0] ,  mat[1] , . . .,  mat[mat.length-1]  are the row arrays of  mat . ### 
#########################################################
Question: 216 ### 2.  The Richter scale is used to measure the strength of an earthquake. A value on the scale is a real number between 0 and 10; and each step in the scaleâfor example from 5.0 to 6.0ârepresents a tenfold increase in the strength of the earthquake.  Consider the following class, written by a student, whose intent is to describe the effects of an earthquake.  public class Earthquake
private double richter;
/ .. Constructor, Sets richter to the specified value on the Richter scale. .
public Earthquake(double value)
{ richter = value; }
/ ** Returns the effect of the earthquake im string form. * /
public String getDescription()
1
String atr;
if (richter >= 8.0)
str = "Most buildings collapse.";
if (richter >= 6.5)
str = "Many buildings damaged. Some fall.";
if (richter >= 4.5)
str = "Poorly-constructed buildings collapse.";
if (richter >= 3.0)
str = "Earth shakes. No destruction. ";
if (richter >= 0)
str = "Barely folt by people.";
return str;
  Consider the following segment of a client program.  did not see any text  If theÂ Richter magnitudeÂ is 4.0, what will be output? ### A.  Earth shakes. No destruction.   B.  Poorly-constructed buildings collapse.   C.  Barely felt by people.   D.  Earth shakes. No destruction.Barely felt by people.   E. An error message will be output. ### Correct Answer:  C ### Explanation: ### Answer: C   The intent of the programmer is to set  str  to   Earth shakes. No destruction.   However, because  else  is not used, each of the  if  statements will be executed, and  str  will be set twice, once when it passes the  if (richter &gt;= 3.0)  test and again when it passes the  if (richter &gt;= 0)  test. The programmer can avoid this either by using a sequence of  else if  tests, thus excluding all other tests when one is found to be true, or by returning the appropriate string (with a  return  statement) as soon as a test is true. ### 
#########################################################
Question: 217 ### 3.  Suppose   x ,   y , and   z  are variables of type   int . Consider the following boolean conditions.  I. (x == y) && (y == z) && (x == z)
II. (x == y) || (y == z) && (x == z)
III. (x-y) * (x-z) *(y-z) == 0
  Which of these expressions is true for all values of  z  ,  given that  x  and  y  have the same value? ### A. I only  B. II only  C. III only  D. I and II only  E. II and III only ### Correct Answer:  E ### Explanation: ### Answer: E   For expression I to be true, each of the three tests must be true. Because the values of  (y == z)  and  (x == z)  are unknown, the truth value of expression I is unknown. Expression II is true if  (x == y)  is true: Since  &amp;&amp;  (and) has higher precedence than  ||  (or), you can think of expression II as being  (x == y)  OR  p , where  p  is the truth value of  (y == z) &amp;&amp; (x == z) . Given that  (x == y)  is true, true OR  p  must be true, irrespective of whether  p  is true or false. Expression III is true, since  x - y  equals 0, and 0 multiplied by any number of factors equals 0. ### 
#########################################################
Question: 218 ### 4.  Which of the following declarations will cause an error? You may assume that each of the classes shown has a default constructor.     LibraryItem item = new LibraryItem();     Book b = new LibraryItem();     LibraryItem cd = new CD(); ### A. I only  B. II only  C. III only  D. I and II only  E. II and III only ### Correct Answer:  B ### Explanation: ### Answer: B   Declaration II fails because it fails this test:   LibraryItem  is-a  Book ? No.  Notice that declarations I and II pass the  is-a  test:      LibraryItem  is-a  LibraryItem?  Yes.<br/>     CD  is-a  LibraryItem ? Yes. ### 
#########################################################
Question: 219 ### 5.  Suppose that, of the three classes shown in the diagram, only the   LibraryItem  class has a method called   getPrice  defined in it, whose specification is as follows.  did not see any text  Now consider the following declaration that appears in a client program.  did not see any text   Assume that   libraryList  is initialized with   LibraryItem  objects. Consider the following code segment that computes the total cost of all items stored in   libraryList .  double total = 0.0;
for (LibraryItem item : libraryList)
total += item. getPrice();
   The use of   getPrice  in this code segment is an example of ### A. an inherited method.  B. an overridden method.  C. polymorphism.  D. an overloaded method.  E. a mutator method. ### Correct Answer:  A ### Explanation: ### Answer: A   Because the  CD  and  Book  classes are subclasses of  LibraryItem , each inherits  getPrice  and can call it in a client class. Each of the other choices has a specific function, none of which is illustrated in the code segment. An overridden method is redefined in a subclass. (This is not true here, because you are given that  getPrice  is defined only in the superclass.) Polymorphism operates only when methods are overridden: At run time, the actual subclass instance is bound to the correct version of the method. An overloaded method has the same name as another method in the class or subclass but a difference signature. A mutator method is one that changes the state of an object. The  getPrice  method is an  accessor . ### 
#########################################################
Question: 220 ### 6.  Consider the following method.  public static int [] doSomething (int [] arr)
{
int num = 0;
for (int i = 0; i < arr.length; i++)
{
num += arr [i] ;
arr [i] = num;
return arr;
  An array  numbers  is declared and initialized as follows.   int [ ] numbers = {1, 3, 5, 7};   What array will be returned as a result of the call  doSomething(numbers) ? ### A. 1,    4,   7,    14  B. 1,    4,    9,    16  C. 1,    3,    5,    7  D. 7,    5,    3,    1  E. 1,    4,    7,    10 ### Correct Answer:  B ### Explanation: ### Answer: B   When i  is 0,   num  becomes 1, and  arr  [0] is set to 1.  When i  is 1,   num  becomes 4, and  arr  [1] is set to 4.  When i  is 2,   num  becomes 9, and  arr  [2] is set to 9.  When i  is 3,   num  becomes 16, and  arr  [3] is set to 16. ### 
#########################################################
Question: 221 ### 7.  A charity organization has a large list of donor records, sorted alphabetically by name. Each record contains the amount of money donated in the current year. Which of the following represents an algorithm that will locate the top seven donors for the current year? ### A. Seven passes through the outer loop of an insertion sort  B. Seven passes through the outer loop of a selection sort  C. Seven recursive calls to mergesort  D. Seven passes through the loop of a binary search  E. Accessing the last seven entries in the list ### Correct Answer:  B ### Explanation: ### Answer: B    After seven passes of a selection sort, if you are sorting donors from largest to smallest amounts of money, the donors with the seven largest amounts will be in their final sorted position. Choice A doesn’t work because after seven passes through an insertion sort loop, the first seven elements will be sorted with respect to each other, but not in their  final  position. Choice C is completely wrong: Mergesort does not sort the elements into their final position until the final merging of elements. Choice D does not make sense: A binary search is meaningless if the array is not sorted by dollar amounts! Choice E will locate the seven donors whose names are at the end of the alphabetical list. They are not necessarily the people who donated the most money. ### 
#########################################################
Question: 222 ### 8.  Consider a method called   outside  that returns true if   value  lies outside the range from   low  to   high , and false if   value  lies between   low  and   high , inclusive.  / ** Precondition: low <- high.
* Postcondition:
*
Returns false if value lies between low and high, inclusive
*
Otherwise returns true.
public boolean outside(int value, int low, int high)
/* code */ }
  Which of the following can replace   /*    code    */  so that   outside  will work as intended? ### A.  return high &gt;= value &gt;= low   B.  return low &lt; value &lt; high   C.  return value &gt; low &amp;&amp; value &lt; high   D.  return value &lt; low &amp;&amp; value &gt; high   E.  return value &lt; low || value &gt; high ### Correct Answer:  E ### Explanation: ### Answer: E   The  value  must lie outside of the range, namely it must either be less than  low  or greater than  high . Choices A and B are wrong, primarily because they are not valid Java expressions. Choice C returns true if  value  is between  low  and  high , which was not required. Choice D fails because it doesn't make sense to use AND here: How can  value  be both less than  low  and greater than  high ? ### 
#########################################################
Question: 223 ### 9.  A  Card , which has an   int  value, is represented with the class below.  public class Card
{
private int value;
public Card (int cardValue)
{ value = cardValue; }
public int getValue()
{ return value; }
public void setValue(int newValue)
{ value = newValue; }
//Other methods are not shown.
  Consider an array   arr  of   Card  values. Which of the following correctly changes   Card  in   arr[0]  to have a value of   100 ?  I. arr [0] = 100;
II. arr [0] . setValue(100) ;
III. Card c = arr [0] ;
c.setValue(100);
 ### A. I only  B. II only  C. III only  D. II and III only  E. I, II, and III ### Correct Answer:  D ### Explanation: ### Answer: D   Segment I is incorrect because it assigns an  int  to  arr[0] , instead of a  Card . Segments II and III correctly use the  setValue  mutator to change the value. Segment III works because  c  is a reference to  arr[0] , so changing  c  changes the array. ### 
#########################################################
Question: 224 ### 10.  Consider the following class definitions.  public class Dancer
{
// . . . data fields and several methods not shown
public void leap()
{ /* implementation not shown */ }
}
public class BalletDancer extends Dancer
{
public void glide()
{ /* implementation not shown */ }
// . . . other methods not shown
  A client program has the following declarations.  did not see any text  Which of the following statements is (are) valid?  I. b. leap() ;
II. d.glide ();
III. d.leap() ;
 ### A. I only  B. II only  C. III only  D. II and III only  E. I and III only ### Correct Answer:  E ### Explanation: ### Answer: E   Statement I works because  BalletDancer  inherits the  leap  method. Statement III works because  Dancer  contains the  leap  method. Statement II fails because  Dancer  does not contain a  glide  method. There will be a compile-time error. The statement can be fixed with a cast:  ((BalletDancer) d) . glide ()
 ### 
#########################################################
Question: 225 ### 1.  The   flip  method below simulates a flip of a weighted coin by returning "heads" or "tails"Â each time it is called. The coin is three times more likely to turn up heads than tails.  public static String flip()
{ /* implementation code */}
  Which of the following is correct   /*     implementation code     */ ?  I int r = (int) (Math. random () * 100) ;
if (r < 75)
return "heads";
else
return "tails";
II int r = (int) (Math.random() * 4);
if (r < 3)
return "heads";
else
return "tails";
III double x = Math.random();
if (x < 0.75)
return "heads";
else
return "tails";
 ### A. I only  B. II only  C. III only  D. I and II only  E. I, II, and III ### Correct Answer:  E ### Explanation: ### Answer: E   All work! In implementation III,  x  is a real number that lies in the interval 0.0 â¤  x  &lt; 1.0. The interval 0.0 â¤  x  &lt; 0.75 is three times as long as 0.75 â¤  x  &lt; 1.0, thus the test  if(x &lt; 0.75)  is correct. In implementation II,  r  has value  0 ,  1 ,  2 , or  3 , with equal probability. Thus the test returns  "heads"  if  r  is  0 ,  1 , or  2 , an outcome that is three times as likely as  r  being  3 . Implementation I works similarly, with 100 possible random integers. For 3/4 of these, the method returns  "heads,"  and for 1/4, it returns  "tails." ### 
#########################################################
Question: 226 ### 2.  Which of the following best describes the value of   sum1 ? ### A. The sum of all positive values in   arr   B. The sum of all positive odd values in   arr   C. The sum of all odd values in   arr   D. The sum of all positive values and odd negative values in   arr   E. The sum of all positive values and even negative values in   arr ### Correct Answer:  D ### Explanation: ### Answer: D   The test  did not see any text  translates to "if  num  is positive or the absolute value of  num  is odd . . . ." Because either condition can be true for the value to be added,  sum1  will include all positive values in  arr  and all odd negative values. ### 
#########################################################
Question: 227 ### 3.  Which of the following best describes the value of   sum2 ? ### A. The sum of all negative values in   arr   B. The sum of all negative even values in   arr   C. The sum of all even values in   arr   D. The sum of all negative values and positive even values in   arr   E. The sum of all values in   arr ### Correct Answer:  B ### Explanation: ### Answer: B   The test  did not see any text  translates to "if  num  is negative and the absolute value of  num  is even . . . ." Because both conditions must be true for the value to be added,  sum2  will include all negative values in  arr  that are also even. ### 
#########################################################
Question: 228 ### 4.  Consider the following method.    public static void mystery (int [] arr)
{
int mid = arr.length/2;
for (int i = 0; i < mid; i++)
{
int temp = arr [i];
arr[i] = arr [arr.length - i - 1];
arr [arr.length - i - 1] = temp;
}
2
  What does method  mystery  do? ### A. Searches for a given element in  arr .  B. Swaps the first and last elements of  arr , and leaves the other elements unchanged.  C. Reverses the elements of  arr .  D. Sorts  arr  in increasing order.  E. Sorts  arr  in decreasing order. ### Correct Answer:  C ### Explanation: ### Answer: C   The algorithm does a series of swaps, working from the endpoints of the array toward the middle.  did not see any text ### 
#########################################################
Question: 229 ### 5.  Which of the following code segments correctly stores in   int  variables   x1  and   x2  unequal integers, each of which can be between 10 and 15, inclusive? ### A. x1 = (int) (Math.random() * 6) + 10;
x2 = (int) (Math.random() * 6) + 10;
   B. x1 = (int) (Math. random() * 5) + 10;
x2 = (int) (Math.random() * 5) + 10;
   C. x1 = (int) (Math. random() * 6) + 10;
x2 = (int) (Math.random() * 6) + 10;
if (x1 == x2)
x2= (int) (Math.random() * 6) + 10;
   D. x1 = (int) (Math. random() * 5) + 10;
x2 = (int) (Math.random() * 5) + 10;
while (x1 == x2)
x2 = (int) (Math.random() * 5) + 10;
   E. x1 = (int) (Math. random() * 6) + 10;
x2 = (int) (Math.random() * 6) + 10;
while (x1 == x2)
x2= (int) (Math.random() * 6) + 10;
 ### Correct Answer:  E ### Explanation: ### Answer: E    There are six different possible values for  x1  and  x2 :  10, 11, 12, 13, 14, or 15.   Thus  Math.random()  must be multiplied by 6. Eliminate choices B and D, which multiply by 5. Choices A and C are wrong because  x1  and  x2  may be the same value. Choice E correctly reassigns  x2  until it has a different value from  x1 . ### 
#########################################################
Question: 230 ### 6.  What will be output for   str1  by a call to   mystery ? ### A.  dogcatcowbird   B.  ogatowird   C.  oaoi   D.  dccb   E.  og ### Correct Answer:  B ### Explanation: ### Answer: B   The  substring  method, when used with just one parameter, returns the substring of the calling string that starts at the parameter position and extends to the end of the string. Thus,  "dog".substring(1)  will return  og . The enhanced  for  loop in method  mystery  cycles through each string in  list  and appends the relevant substring of the current element to  str1 :  og  +  at  +  ow  +  ird , resulting in choice B. ### 
#########################################################
Question: 231 ### 7.  What will be output for   str2  by a call to   mystery ? ### A.  oaoi   B.  dccb   C.  gtwr   D.  ogatowir   E.  docacobi ### Correct Answer:  A ### Explanation: ### Answer: A   When the  substring  method is used with two parameters, the first parameter is where the substring starts, and the second parameter is the position one place to the right of where the substring ends.  "bird".substring(1, 2)  will return  i , for example. The enhanced for loop in method  mystery  thus appends to  str2  a single-character string for each element in  list :  o  +  a  +  o  +  i , resulting in choice A. ### 
#########################################################
Question: 232 ### 8.  Consider the following declarations.  int[ ]arr = {2, 4, 6, 8} ;
ArrayList<Integer> list = new ArrayList<Integer>();
  Which of the following code segments will correctly add all the elements of  arr  to  list ? (The final ordering of  list  elements is irrelevant.)      for (int i = 0; i &lt; arr.length; i++)<br/> Â  Â  Â list.add(arr[i]);     for (int i = arr.length - 1; i &gt;= 0; i--)<br/> Â  Â  Â list.add(arr[i]);     for (int i = arr.length - 1; i &gt;= 0; i--)<br/> Â  Â  Â list.add(i, arr[i]); ### A. I only  B. II only  C. III only  D. I and II only  E. I, II, and III ### Correct Answer:  D ### Explanation: ### Answer: D   Segment III fails because the index for  list  is out of range. For example, if the array has 8 elements, the algorithm in segment III will try to add an element to an empty list at position 7. This will throw an  IndexOutOfBoundsException . ### 
#########################################################
Question: 233 ### 9.  Which of the following declarations in a client class would cause an error?   I. PosInt p = new PosInt () ;
II. PosInt even = new EvenPosInt ();
III. PosInt pe = new EvenPosInt (10);
   ### A. I only  B. II only  C. I and II only  D. II and III only  E. I, II, and III ### Correct Answer:  E ### Explanation: ### Answer: E   None of these declarations will get past the compiler. Declaration I fails because the  PosInt  class has no default constructor. Declaration II fails for the same reason: If  PosInt  had a default constructor, the following code would automatically be placed in the subclass  EvenPosInt .  did not see any text  Declaration III fails because the superclass constructors are not inherited. You need to add the following constructor code to  EvenPosInt  to make declaration III work.  {  }  But this only works if there is a default constructor in the superclass! ### 
#########################################################
Question: 234 ### 10.  Suppose that the following constructor is added to the   EvenPosInt  class.  { }    Which of the following is a correct /*    implementation    */ for the   getNextEven  method?  I. return value + 2;
II. return getValue() + 2;
III. return this + 2;
 ### A. I only  B. II only  C. III only  D. II and III only  E. I, II, and III ### Correct Answer:  B ### Explanation: ### Answer: B   Implementation I is incorrect because a subclass cannot access the private data of its superclass. The accessor method  getValue  must be used (shown in implementation II). Implementation III is wrong because  this  represents the current  EvenPosInt  object, not its value. The statement can be corrected to:  did not see any text  Note that without a constructor an  EvenPosInt  could not be created. ### 
#########################################################
Question: 235 ### 1.  Consider an array   arr  that is initialized with   int  values. The following code segment stores in   sum  the sum of all values in   arr .  int sum = 0, index = 0;
while (index < arr.length)
sum += arr [index] ;
index++;
  Which of the following code segments result in the same value for  sum  as in the above segment?  I. int sum = 0;
for (int num : arr)
{
sum += arr[num] ;
II. int sum = 0;
for (int num : arr)
{
sum += num;
}
III. int sum = 0, indenx = 0;
for (int index : arr)
{
sum += arr [index] ;
1
 ### A. I only  B. II only  C. III only  D. II and III only  E. I, II, and III ### Correct Answer:  B ### Explanation: ### Answer: B   In an enhanced  for  loop (i.e., for-each loop) indices are not explicitly accessed by the programmer. Thus, segments I and III are wrong. ### 
#########################################################
Question: 236 ### 2.  Consider the following method.  public int multiply (int n)
{
if (n == 0)
return 1;
else if (n % 2 == 1)
return n;
else
return n * multiply(n - 2);
  What will be returned by a call to   multiply(8) ? ### A. 1  B. 8  C. a value equal to (8)(7)(6)(5)(4)(3)(2)  D. a value equal to (8)(6)(4)(2)  E. a value equal to (7)(5)(3) ### Correct Answer:  D ### Explanation: ### Answer: D   Since  n == 8  fails the two base case tests, method  multiply  returns values as follows:  multiply (8) = 8 * multiply (6)
= 8 * 6 * multiply (4)
= 8 * 6 * 4 * multiply(2)
= 8 * 6 * 4 * 2 * multiply(0)
= 8 * 6*4 * 2
*2* 1
  This is equivalent to (8)(6)(4)(2). ### 
#########################################################
Question: 237 ### 3.  Consider the following declarations.  did not see any text  Which of the following tests will return true?  I. if (s1.equals(s2))
II. if (s1 == s2)
III. if (s1.compareTo(s2) == 0)
 ### A. I only  B. II only  C. III only  D. I and III only  E. I, II, and III ### Correct Answer:  D ### Explanation: ### Answer: D   Because the  String  class has an  equals  method, and strings  s1  and  s2  have the same contents, test I will be true. Since  String  has a  compareTo  method, test III, the test for equality, will be true. Test II returns false because the  ==  operator tests whether two object  references  are the same. Since  s1  and  s2  were each created with  new , the references are different. Note that if the declarations had been  did not see any text  then  s1 == s2  would be true. ### 
#########################################################
Question: 238 ### 4.  In the following code segment, you may assume that   a ,   b , and   n  are all type   int .  if (a ! = b && n / (a - b) > 90)
/* statement 1 */
else
{
/* statement 2 */
}
/* statement 3 */
  What will happen if   a == b  is true? ### A.  /*   statement 2   */  will be executed, followed by    /* statement 3 */   .  B.  /*   statement 1   */  will be executed, followed by    /* statement 3 */   .  C. Neither  /*   statement 1   */  nor   /*   statement 2   */  will be executed. Execution will pass to   /*   statement 3   */ .  D. A compile-time error will occur.  E. An exception will be thrown. ### Correct Answer:  A ### Explanation: ### Answer: A   If  a == b  is true, then  a != b  is false, and the entire compound  if  test will be false, leading to the evaluation of  /*   statement 2   */ . Short-circuiting will occur as soon as  a != b  is evaluated. This means that  n / (a - b) &gt; 90  will never be evaluated. Notice that  n / (a - b)  represents division by 0, so if the second piece of the test  were  evaluated, it would cause an  ArithmeticException  to be thrown. If the test executes without error,    /* statement 3 */    will always be executed, because it is outside the  if...else  statement. ### 
#########################################################
Question: 239 ### 5.  Consider the methodÂ   printSomething , which prints a piece of its matrix parameter,   mat .  / ** Precondition: mat is initialized with integers. * /
public static void printSomething(int [] [] mat)
{
for (int i = 1; i < mat.length; i += 2)
for (int j = 1; j < mat[i].length; j += 2)
System.out.print (mat [i] [j] + " ");
System.out. println();
System.out.println();
  What will be output from a call to   printSomething(mat)  if   mat  is as shown below?  1 2 3 4<br/> 5 6 7 8<br/> 9 0 1 2<br/> 3 4 5 6 ### A. <pre>6 8 4 6 </pre>  B. <pre>2 4 0 2 </pre>  C. <pre>5 7 3 5 </pre>  D. <pre>5 3 7 5 </pre>  E. <pre>6 4 8 6 </pre> ### Correct Answer:  A ### Explanation: ### Answer: A   The algorithm traverses the matrix starting with the second row (  i=1 ) and second column (  j=1 ). The expressions  i+=2  and  j+=2  cause every other row and column to be skipped. Thus, the second and fourth elements in the second and fourth rows of the matrix will be printed. ### 
#########################################################
Question: 240 ### 6.  Which represents a correct   /*   implementation   */  for the   increment  method?  I. if (value == rollOverLimit)
value = 0;
else
value++;
II. value++;
if (value == rollOverLimit)
value = 0;
III. value = (value + 1) & rollOverLimit;
   ### A. I only  B. II only  C. III only  D. II and III only  E. I, II, and III ### Correct Answer:  D ### Explanation: ### Answer: D   Suppose the  NumberDisplay  represents hours on a 24-hour digital clock. The roll over limit will be 24, and the values will range from 0 to 23 inclusive. Thus,  value  can never equal  rollOverLimit  at the start of the method. Therefore, segment I fails. Segment II performs the operations in the correct order: Add 1 to the value; check if the limit has been reached; and, if so, reset the value to 0. Segment III achieves the correct result in a tricky way. Suppose  value  is 9. Then  value  = (10) % 24 = 10, which was required. Suppose  value  is 23. Then  value  = (24) % 24 = 0, which is correct. ### 
#########################################################
Question: 241 ### 7.  A digital clock contains two   NumberDisplay  objects, for minutes and hours. Which of the following is the most suitable set of  declarations? ### A. public class DigitalClock extends NumberDisplay
{
private int hours;
private int minutes;
    B. public class NumberDisplay extends DigitalClock
{
private int hours;
private int minutes;
3
   C. public class DigitalClock extends NumberDisplay
{
private NumberDisplay hours;
private NumberDisplay minutes;
   D. public class DigitalClock
{
private NumberDisplay hours;
private NumberDisplay minutes;
2
   E. public class DigitalClock
private int hours;
private int minutes;
 ### Correct Answer:  D ### Explanation: ### Answer: D   The relationship between a  DigitalClock  and  NumberDisplay  is a  has-a  relationship: The  DigitalClock    has-a    NumberDisplay  for hours, and it  has-a    NumberDisplay  for minutes. There is no inheritance in this relationship, so all of the choices that use "extends" in their class headers are wrong (choices A, B, and C). Choice E is wrong because  hours  and  minutes  should be of type  NumberDisplay . ### 
#########################################################
Question: 242 ### 8.  Consider the following declarations.  public class ClassA
1
..
public void doSomething(ClassB b, ClassC c)
..
}
public class ClassB extends ClassA
{
}
public class ClassC extends ClassB
1
...
  A different class has these declarations. (You may assume that each class has a defaultconstructor.)  ClassA objA = new ClassA ( ) ;
ClassB objB = new ClassB( ) ;
ClassC objc = new ClassC ( ) ;
 Which of the following is a correct call to   doSomething ? ### A.  objC.doSomething(objC, objC);   B.  objC.doSomething(objA, objA);   C.  objB.doSomething(objC, objB);   D.  objB.doSomething(objB, objB);   E.  objA.doSomething(objA, objA); ### Correct Answer:  A ### Explanation: ### Answer: A   Each of the references,  objA ,  objB , and  objC , has access to  doSomething . So the only issue in this question is the parameter types. According to the  doSomething  method header, the first parameter must pass the  is-a    ClassB  test, and the second parameter must pass the  is-a    ClassC  test. Choice A is the only choice in which both parameters satisfy this requirement. ### 
#########################################################
Question: 243 ### 9.  Refer to the static method   removeValue .  / .. Removes all occurrences of value from list. Does not
. remove any other values.
public static void removeValue(ArrayList<Integer> list, Integer value)
/* implementation */
  Which represents an   /*   implementation   */  of   removeValue  that achieves the postcondition?  I. for (int = 0; i < list.size( ); i++)
if (list. get(i) . equals (value) )
list.remove(i) ;
II. for (Integer int0b : list)
if (int0b.equals (value) )
list. remove(int0b) ;
III. int i = 0;
while (i < list.size) )
{
if (list.get (i) .equals (value))
list.remove(i) ;
else
i++;
-
 <pre></pre> ### A. I only  B. II only  C. III only  D. I and III only  E. I, II, and III ### Correct Answer:  C ### Explanation: ### Answer: C   Segment I will not work whenever there are consecutive occurrences of  value . This is because removal of an element from  list  causes the elements to the right of it to be shifted to the left to fill the "hole." The index  i , however, moves one slot to the right. For example, if  list  contains 1, 6, 6, 9, and 6 is the value to be removed,  list  will end up with 1, 6, 9. (The first occurrence of 6 will be removed. The second occurrence will be passed over.) Segment III, a correct algorithm, works because the index shifts right only if an element was not equal to  value . You should reject segment II as soon as you see it. An enhanced  for  loop should not be used to remove elements from a list. ### 
#########################################################
Question: 244 ### 10.  Suppose methods   f1  and   f2  are defined as follows.  public int fl(int x)
{
if (x == 0)
return 0;
else
return f2(x- 2);
}
public int f2(int x)
{
if (x == 1)
return 1;
else
return f1(x + 1) + x;
  What value is returned as a result of the call   f1(5) ? ### A. -4  B. 4  C. 6  D. 8  E. Infinite recursion occurs, and no value is returned. ### Correct Answer:  C ### Explanation: ### Answer: C   The method call  f1(5)  leads to the following sequence of calls.  f1 (5) = f2(3)
= f1(4)+ 3
= f2(2) + 3
= f1(3)+2+ 3
= f2(1)+2+3
= 1+2 + 3
= 6
 ### 
#########################################################
Question: 245 ### 1.  Which is correct   /*   implementation   */  code for the constructor of the   Hen  class?  I. super () ;
II. super(aSpecies);
III. species = aSpecies;
   ### A. I only  B. II only  C. III only  D. II and III only  E. I, II, and III ### Correct Answer:  B ### Explanation: ### Answer: B   The superclass,  Bird , does not have a default constructor; therefore, segment I is incorrect. Segment II works because the constructor for  Bird  has one  String  parameter. Segment III fails because a subclass cannot access the private data of its superclass. ### 
#########################################################
Question: 246 ### 2.  A client class has an   ArrayList&lt;Bird&gt; birds  that is initialized with many different objects that are subclasses of   Bird . Each subclass has an overridden   makeNoise  method, similar to those shown in the   Owl  and   Hen  classes. What is the effect of executing the following code segment?  did not see any text   ### A. The unique noise for each particular   Bird  will be output.  B. There will be a compile-time error with a message to the effect that there cannot  be different types in   ArrayList&lt;Bird&gt; .  C. There will be a compile-time error with a message to the effect that   Bird b  needs to be cast to its actual type.  D. An   IndexOutOfBoundsException  will be thrown.  E. A  ConcurrentModificationException  will be thrown. ### Correct Answer:  A ### Explanation: ### Answer: A   The code will work as intended, namely, at run time, the appropriate  makeNoise  method will be called, depending on the current instance of  Bird b . This is an example of polymorphism or dynamic binding. Polymorphism occurs when a superclass method has been overridden in the subclass(es). Choices B and C are incorrect because they contradict polymorphism. Choice D is false because no indices are accessed in the code. Choice E is false because no attempt is made to add an element to  birds  in the enhanced  for  loop. ### 
#########################################################
Question: 247 ### 3.  Consider the following method.  public static int mystery (int n)
if (n < 0)
return 1;
else return mystery (n - 1) + mystery (n - 2);
 What value will be returned by a call to  mystery(2) ? ### A. 5  B. 4  C. 3  D. 2  E. 1 ### Correct Answer:  A ### Explanation: ### Answer: A   Let  mystery(2)  be denoted   m (2) .  m(2) = m(1) + m(0)
= [m(0)+m(-1)] + [m(-1) + m(-2)]
= [m(-1) + m(-2) + 2] + 1 + 1 (each base case equals 1)
= [1+1+1] +1+ 1
= 5
 ### 
#########################################################
Question: 248 ### 4.  An array of hospital records is sorted by patient ID numbers. Suppose a patient's record must be located given the patient's name only. Which of the following procedures is the most efficient for locating that patient's record? ### A. Do a binary search.  B. Do a sequential search.  C. Sort the array into alphabetical order, then do a binary search.  D. Sort the array into alphabetical order, then do a sequential search.  E. Start with the first record and examine every fifth record. If this fails, start with the second record and examine every fourth record. If this fails, start with the third record and examine every third record. Proceed in this way until the record with the given name is found. ### Correct Answer:  B ### Explanation: ### Answer: B   The records are not ordered by name, so the quickest way to find the given record is to start at the first record and proceed sequentially through the records until you find the given name. Eliminate choice A: You can't do a binary search for a given name unless the array is sorted by  name . Choices C and D will eventually locate the given record, but it is inefficient to start by sorting the array. Since sorting requires the examination of every record anyway, you may as well omit the sort and start with the sequential search! The fancy algorithm in choice E doesn't save time. It, in fact, examines some records more than once! ### 
#########################################################
Question: 249 ### 5.  Which of the following is (are) false?     A subclass inherits all the constructors of its superclass.   A subclass inherits all the private instance variables of its superclass.   A subclass inherits all the methods of its superclass. ### A. I only  B. II only  C. III only  D. I and II only  E. I, II, and III ### Correct Answer:  E ### Explanation: ### Answer: E    <p data-uid="">Constructors are never inherited, nor are private instance variables. To access the private data of its superclass, a subclass must use the inherited accessor methods of the superclass. Statement III is false because a subclass does not inherit the private methods of its superclass. ### 
#########################################################
Question: 250 ### 6.  Consider the method   makeBorder , whose intent is to place a border of   num  around matrix   mat .  / ** Precondition: mat is initialized with integers.
*
Postcondition: mat has a border of num.
* @param mat a matrix of integers
* @param num the value to be placed on the border of mat
*/
public static void makeBorder (int[ ] [ ] mat, int num)
{
/* code to make border of num */
  For example, if   mat  is originally  0 1 2 3
45 6 7
3 2 1 0
7654
  the method call   makeBorder(mat, 9)  will change   mat  to be  9999
9569
9 2 1 9
9 9 9 9
  If   mat  is originally  1 2 3
4 5 9  the method call   makeBorder(mat, 2)  will change   mat  to be  2 2 2
2 2 2  Which of the replacements for   /* code to make border of num */  will work as intended?  I. for (int r = 0; r < mat. length; r++)
{
for (int c = 0; c < mat[r] . length; c++)
if (r == 0 || r == mat.length - 1 | | c == 0
| | c == mat[r] . length - 1)
mat[r] [c] = num;
II. for (int c = 0; c < mat[0] . length; c++)
{
mat [ 0] [c] = num;
mat [mat. length - 1] [c] = num;
for (int r = 0; r < mat. length; r++)
{
mat [r ] [ 0] = num;
mat [r ] [mat [ r] . length - 1] = num;
1
III. for (int c = 0; c < mat[0] . length; c++)
{
mat [ 0 ] [c] = num;
mat [mat . length - 1] [c] = num;
for (int r = 1; r < mat.length -1; r++)
{
mat [r] [0] = num;
mat [r ] [mat [r] . length - 1] = num;
 <pre></pre> ### A. I only  B. II only  C. III only  D. I and II only  E. I, II, and III ### Correct Answer:  E ### Explanation: ### Answer: E   All work! Segment I traverses the whole matrix and changes only those elements that are in the top or bottom rows of the leftmost or rightmost columns. Segment II changes first the leftmost and rightmost columns, then the top and bottom rows. Segment III does the same as segment II, except it doesn't change the corner elements, which have already been changed by the first  for  loop. ### 
#########################################################
Question: 251 ### 7.  In a client program, which of the following correctly declares and initializes   Employee emp  whose name is Ben M. Zax and ID number is 1492?  I. Employee emp = new Employee ( ) ;
emp. name = new Name ("Ben", "M.", "Zax") ;
emp.idNumber = 1492;
II. Employee emp = new Employee("Ben M. Zax", 1492) ;
III. Employee emp = new Employee (new Name ("Ben", "M. ", "Zax") , 1492) ;
   <pre></pre> ### A. I only  B. II only  C. III only  D. I and II only  E. II and III only ### Correct Answer:  C ### Explanation: ### Answer: C   The  Employee  constructor takes two parameters, one of type  Name  and one of type  int . Declaration III has the correct types. Declaration II does not: The first parameter is a  String , not a  Name . Declaration I has two problems: It uses a default constructor even though  Employee  does not necessarily have one. It also attempts to access the private instance variables of the  Employee  class, which is illegal for a client class. ### 
#########################################################
Question: 252 ### 8.  Of the following, which is the most appropriate header in a static client class for a   nameMatch  method that determines whether two   Employee s have the same name? ### A.  public static boolean nameMatch(Employee other)   B.  public static void nameMatch(Employee other)   C.  public static boolean nameMatch(Name other)   D.  public static void nameMatch(Employee emp1, Employee emp2)   E.  public static boolean nameMatch(Employee emp1, Employee emp2) ### Correct Answer:  E ### Explanation: ### Answer: E   This is an objectless client method, so there is no current  Employee  object. This means that the method needs two  Employee  parameters to compare. You can therefore eliminate choices A, B, and C. Note that the method should return true if the  Employee  parameters have the same name, false otherwise. Therefore, the method should have a  boolean  return type, and you can eliminate choice D. ### 
#########################################################
Question: 253 ### 9.  The following method is intended to return the index of the "smallest" word in the array  words , namely the word that would appear first in an alphabetized list of the strings in the array.  / ** Precondition:
*
- words is initialized with lowercase words.
* - words. length > 0.
*/
public static int findMin(String[ ] words)
{
int minPos = 0;
for (int index = 1; index < words. length; index++)
{
if ( /* condition */ )
{
minPos = index;
}
}
return minPos;
  Which of the following should be used to replace   /* condition */  so that   findMin  works as intended? ### A.  words[minPos] &gt; words[index]   B.  words[index] &gt; words[minPos]   C.  words[index].compareTo(words[minPos]) &gt; 0   D.  words[index].compareTo(words[minPos]) &gt;= 0   E.  words[index].compareTo(words[minPos]) &lt; 0 ### Correct Answer:  E ### Explanation: ### Answer: E   Eliminate choices A and B: When comparing  String  objects, you cannot use simple inequality operators; you  must  use  compareTo . For the calling object to be  less than  the parameter object, use the  less than  0 test (a good way to remember this!). ### 
#########################################################
Question: 254 ### 10.  Consider the following static method,   countDiff . Method   countDiff  is intended to count the number of different values in array   arr . It does not, however, work as intended. (Lines are numbered for reference.)  Line 1:
/ ** Precondition:
Line 2:
* - Array arr contains int values.
Line 3:
*
arr is sorted in increasing order.
Line 4:
* Postcondition: Returns the number of distinct (different) values in arr
Line 5:
*/
Line 6:
public static int countDiff (int []
arr)
Line 7:
Line 8:
int count = 1;
Line 9:
for (int i = 0; i < arr.length; i++)
Line 10:
Line 11:
if (arr[i] != arr[i + 1])
Line 12:
Line 13:
count++;
Line 14:
Line 15:
}
Line 16:
return count;
Line 17: }
  Which of the following changes should be made so that   countDiff  will work as intended? ### A. <span class="cambria">Line 8 should be changed to   int count = 0;   B. <span class="cambria">Line 9 should be changed to   for (int i = 0; i &lt; arr.length - 1; i++)   C. <span class="cambria">Line 11 should be changed to   if (arr[i] == arr[i + 1])   D. <span class="cambria">Line 16 should be changed to   return arr.length - count;   E. <span class="cambria">Line 16 should be changed to   return count - arr.length; ### Correct Answer:  B ### Explanation: ### Answer: B   In the given implementation of the method,  count  is incremented every time a different value is encountered, which is what was required. The problem in the code is that if line 9 is not changed, when the last index in the array is reached,  arr[i + 1]  is out of range and an exception will be thrown (  ArrayIndexOutOfBoundsException ). Assuming that line 9 is fixed, each of the other choices will cause an intent error. Choice A will return a count that is off by one. Choice C will increment the count when two adjacent values are the same, which is not what was required. Choice D will give a count of each occurrence of a duplicate value-not required. Choice E will give zero or a negative value, which doesn't make sense. ### 
#########################################################
Question: 255 ### 1.  Refer to the following code segment.  int n = < some positive integer >
for (int i = n; i > 1; i /= 2)
process(i);
1.
  In terms of   n , which is nearest to the number of times  process (i)  will be executed? ### A. 1  B.  n   C.  n  2   D.  n /2  E.  k , where  n = 2 k ### Correct Answer:  E ### Explanation: ### Answer: E    The  for  loop is executed approximately log<sub>2</sub>  n  times (i.e., the number of times that  i , which is initialized to  n , is divided by 2 until it reaches 1). If you take a small value for  n , like 16, you can very quickly eliminate choices A-D. ### 
#########################################################
Question: 256 ### 2.  Consider the following hierarchy of classes. Each of the classes has a default constructor.  Teacher
EnglishTeacher
MathTeacher
-
PoetryTeacher
  Which of the following is (are) true?    If  EnglishTeacher  has no overridden methods,   PoetryTeacher  inherits all the public methods of   Teacher  and   EnglishTeacher .     MathTeacher  inherits the constructors of   Teacher .     PoetryTeacher  inherits the constructors of   EnglishTeacher  and   Teacher . ### A. I only  B. II only  C. III only  D. I and II only  E. I, II, and III ### Correct Answer:  A ### Explanation: ### Answer: A   Statement I is true: Since  EnglishTeacher  is a subclass of  Teacher , it inherits all public methods of  Teacher , and since  PoetryTeacher  is a subclass of  EnglishTeacher , it inherits those methods too, plus any additional public methods in  EnglishTeacher . (Note that if  EnglishTeacher  had an overridden method, then  PoetryTeacher  would inherit that method, not the original method in  Teacher .) Statements II and III are wrong because constructors are not inherited. ### 
#########################################################
Question: 257 ### 3.  Consider the following hierarchy of classes. Each of the classes has a default constructor.  Teacher
EnglishTeacher
MathTeacher
-
PoetryTeacher
  A program is written to print data about teachers in a school.  public class TeacherStuff
{
//Private instance variables and constructors not shown
public void displayTitle(Teacher t)
{ /* implementation not shown */ }
//Other methods not shown.
  Class  SchoolStuff  has the following declarations.  did not see any text  In the  SchoolStuff  class, which of the following method calls will  not  cause an error?  I displayTitle (t1) ;
II displayTitle(t2);
III displayTitle(t3);
 ### A. I only  B. II only  C. III only  D. II and III only  E. I, II, and III ### Correct Answer:  E ### Explanation: ### Answer: E   All are correct. The parameter must be a  Teacher , and each of  t1 ,  t2 , and  t3  satisfies that requirement. ### 
#########################################################
Question: 258 ### 4.  Which of the following correctly initializes a two-dimensional array   mat  of   int , with   numRows  rows and   numCols  columns, so that it contains all zeroes?  I int [] [] mat = new int [numRows] [numCols]
for (int [] row : mat)
for (int c = 0; c < numCols; c++)
row [c] = 0;
II int [] [] mat = new int [numRows] [numCols]
for (int r = 0; r < numRows; r++)
for (int c = 0; c < numCols; c++)
mat [r] [c] = 0;
III int [] [] mat = new int [numRows] [numCols]
for (int [] row : mat)
for (int num : row)
num = 0;
 ### A. I only  B. II only  C. III only  D. I and II only  E. II and III only ### Correct Answer:  D ### Explanation: ### Answer: D    Segment I uses the fact that  mat  is an array of rows in which each row is an array of  int  with  numCols  elements. Segment III fails because you can’t use an enhanced  for  loop to assign elements in this way. Segment II is the traversal needed for assignment of elements. ### 
#########################################################
Question: 259 ### 5.  Look at the following poorly formatted program segment. If   a == 7  and   c == 6  before execution, which of the following represents the correct values of   c ,   d ,   p , and   t  after execution? An undetermined value is represented with a question mark.  if (a == 6)
if (c == 6)
{
c = 9;
d = 9;
else
{
t = 10;
if (c == 6)
c = 5;
else p = 9;
 ### A.  c == 6,   d == ?,   p == 9,   t == ?   B.  c == 5,   d == ?,   p == ?,   t == 10   C.  c == 6,   d == ?,   p == ?,   t == ?   D.  c == 5,   d == 9,   p == ?,   t == 10   E.  c == 9,   d == 9,   p == ?,   t == ? ### Correct Answer:  A ### Explanation: ### Answer: A   Because  (a == 6)  is  false , the  if (c == 6) ...
else
{
= 10; ..
  statement will not be executed. The second  else  matches up with the first  if , which means that  p = 9  gets executed. Variables  d  and  t  remain undefined. ### 
#########################################################
Question: 260 ### 6.  Refer to the following method.  public static String weirdString (String s, String sub)
String temp;
String w = ""; //empty string
for (int i = 0; i < s.length(); i++)
temp = s.substring(i, i + 1);
if (temp.compareTo(sub) < 0)
w = w + temp;
7
return w;
  What will   weirdStr  contain after the following code is executed?  did not see any text ### A.  "cglmeai"   B.  "cgleai"   C.  "cogloeratio"   D.  "onomrton"   E. No value.   StringIndexOutOfBoundsException . ### Correct Answer:  B ### Explanation: ### Answer: B   The statement  temp = s.substring(i, i+1)  places in  temp  the string containing the character at position  i . The  for  loop thus cycles through  "conglomeration,"  starting at  "c,"  and compares each single character string to  "m."  If that character precedes  "m,"  a new  String  reference  w  is created, which consists of the current value of  w  concatenated with that character. Notice that every character in the string  "cgleai"  precedes  "m"  in alphabetical order. ### 
#########################################################
Question: 261 ### 7.  Which of the following code segments correctly stores in   x  a random real number such that 0.6 â¤   x  &lt; 1? ### A.  double x = 0.6 * Math.random() + 0.4;   B.  double x = 0.4 * Math.random() + 0.6;   C.  double x = Math.random() - 0.4;   D.  double x = (double) (Math.random() * 0.4);   E.  double x = (double) (Math.random() + 0.6); ### Correct Answer:  B ### Explanation: ### Answer: B    The statement       double x = Math.random();    produces a random real number such that  0 â¤ x &lt; 1 . The statement      double x = 0.4 * Math.random();    produces a random real in 0 â¤  x  &lt; 0.4. To shift this interval 0.6 to the right, you need       double x = (0.4 * Math.random()) + 0.6; ### 
#########################################################
Question: 262 ### 8.  Consider an array  arr  that is initialized with integers, and an  ArrayList&lt;Integer&gt;  declared as follows.  did not see any text  Which of the following will add all the elements of  arr  to  list  without error? The final ordering of elements is irrelevant.  I. for (int num : arr)
list.add(num);
II. for (int i = 0; i < arr.length; i++)
list. add(arr [i]);
III. for (int i = arr.length - 1; i >= 0; i -- )
list. add (arr [
arr [i] ) ;
 ### A. I only  B. II only  C. III only  D. I and II only  E. I, II, and III ### Correct Answer:  E ### Explanation: ### Answer: E   All are correct! In segment I, all elements of  arr  are accessed and added to  list . Segments II and III must be careful to avoid an  ArrayIndexOutOfBounds  index by not including  arr[arr.length] . Note that segment III accesses elements in reverse order, which is allowed. ### 
#########################################################
Question: 263 ### 9.  Consider array  arr , which is initialized as follows.  did not see any text  Which statement about a sequential search or binary search is  false ? ### A. A key of 20 represents a worst case for sequential search.  B. A key of 8 represents a best case for binary search.  C. A key of 0 represents a worst case for sequential search.  D. A key of 20 represents a worst case for binary search.  E. A key of 30 represents a worst case for both sequential and binary searches. ### Correct Answer:  C ### Explanation: ### Answer: C    In a sequential search in a sorted array, a key that is less than the first element will be revealed almost immediately in the search, and so cannot be a worst case. Choice A is true because the search algorithm must search the whole array before 20 is found. Choice B is true because  arr[(0 + 7)/2] = arr[3]  will be the first element compared to the key. Choice D is true because a rightmost endpoint is a worst case for binary search, whereas a leftmost endpoint would not be, because the div operation skews to the left. Choice E is true because an element that is to the right of the largest element of the array will need the maximum number of passes through the search algorithms (both binary and sequential) to discover that it’s not in the array. ### 
#########################################################
Question: 264 ### 10.  Which statement about constructors is  false ? ### A. It is legal for the value of a static variable to be changed in a constructor.  B. The constructor in a subclass must use the keyword   super  to initialize the private instance variables from its superclass.  C. A subclass can have a default constructor that differs from the default constructor of its superclass.  D. A subclass has fewer constructors than its superclass.  E. If a subclass does not explicitly provide a constructor and its superclass has justone constructor with a parameter, an error will occur when an attempt is made to createan instance of a subclass object. ### Correct Answer:  D ### Explanation: ### Answer: D   A subclass can have any number of constructors. Each of the other statements is true. For choice A, a static variable stores information for the entire class. For example, it could provide a new serial number each time an object is created. To do this, the variable must be updated in the constructor. For choice B, a subclass cannot directly access the private instance variables of its superclass. It therefore  must  use  super  to invoke the constructor of the superclass to initialize those variables. For choice C, the default constructor of a subclass often initializes new private instance variables that are not in the superclass. For choice E, if there is no constructor in a subclass, code for a superclass default constructor will be provided by the compiler. If the superclass does not have a default constructor, there will be a compile-time error. ### 
#########################################################
Question: 265 ### 1.  What output will be produced by this code?  for (int i = 5; i > 0; i -- )
{
for (int k = 1; k <= i; k++)
System. out.print(k + " ")
System.out.println();
 ### A. 5 4 3 2 1
543 2
54 3
5 4
5
   B. 5 4 3 2 1
43 2 1
3 2 1
2 1
1
   C. 1 2 3 4 5
1 2 3 4
1 2 3
1 2
1
   D. 1 2 3 4 5
2 3 4 5
3 4 5
4 5
5
   E. 1 1 1 1 1
2 2 2 2
3 3 3
4 4
5
 ### Correct Answer:  C ### Explanation: ### Answer: C   The outer loop produces five rows of output. Each pass through the inner loop goes from  1  to  i , printing each value of  k . Thus, in the first row, when  i  is  5 , the numbers  1 2 3 4 5  are printed. In the second row, the numbers  1 2 3 4  are printed, and so on. ### 
#########################################################
Question: 266 ### 2.  Consider the following instance variable and method.  private int [] numbers;
/ ** Precondition: numbers contains {9,8,7,6,5}.
*/
public void shuffleNumbers()
{
for (int i = 4; i > 0; i -- )
{
int index = < a random int from 0 to i, inclusive >;
int temp = numbers [i] ;
numbers [i] = numbers [index] ;
numbers [index] = temp;
  Suppose that when   shuffleNumbers  is called, the sequence of random integers generated in   index  is   0 ,   2 ,   1 ,   0 . Which element will be in   numbers[0]  after execution of the   shuffleNumbers  method? ### A.  9   B.  8   C.  7   D.  6   E.  5 ### Correct Answer:  D ### Explanation: ### Answer: D    The variable  i  goes from  4  down to  1  and  index  has the values  0 ,  2 ,  1 ,  0 . Here is the sequence of swaps and state of  numbers  after each pass through the loop:  swap numbers [4] and numbers [0]
5 8 7 6 9
swap numbers [3] and numbers [2]
5867 9
swap numbers [2] and numbers [1]
568 7 9
p numbers [1]
d numbers [0]
6 5 8 7 9
 ### 
#########################################################
Question: 267 ### 3.  Which is a true statement about the methods in   ClassA  and   ClassB ? ### A.  ClassB  inherits   method2  from   ClassA .  B.  ClassA  inherits   method2  from   ClassB .  C.  method1  is an example of an overloaded method.  D.  method2  is an example of an overridden method.  E.  method1  is an example of an overridden method. ### Correct Answer:  E ### Explanation: ### Answer: E   An overridden method is an inherited method whose implementation is changed in the subclass (same header, different body). Since  method1  fits this description, choice E is true and choice D is false. For choice A,  method2  is defined for the first time in  ClassB . Therefore, it is not inherited. For choice B, a superclass  never  inherits a method from its subclass. For choice C, for  method1  to be an overloaded method, it would need a different signature in  ClassB . ### 
#########################################################
Question: 268 ### 4.  Consider the following declarations in a client class.   ClassA ob1 = new ClassA ();
ClassA ob2 = new ClassB():
    Which of the following method calls will cause an error?   I ob1 . method1 () ;
II ob1.method2();
III ob2. method2():
 ### A. I only  B. II only  C. III only  D. II and III only  E. I, II, and III ### Correct Answer:  D ### Explanation: ### Answer: D   Statement I is okay. Either  ob1  or  ob2  could call  method1  without a problem since each is of type  ClassA  and  method1  is in  ClassA . Statement II fails because an object of a superclass does not have access to new methods of its subclass. Statement III fails because  ob2  is declared to be of type  ClassA , so a compile-time error will occur with a message indicating that there is no  method2  in  ClassA . ### 
#########################################################
Question: 269 ### 5.  Consider the  ElapsedTime  constructor that creates an  ElapsedTime  object from its  numSecs  parameter.  Recall that there are 60 seconds in a minute, and 60 minutes in an hour.  / ** Creates an ElapsedTime object from numSecs the total
* number of seconds of elapsed time.
*/
public ElapsedTime(int numSecs)
{ /* ElapsedTime implementation code */}
    Which of the following is a correct /*  ElapsedTimeÂ   implementation code   */?   I secs = numSecs;
II mins = numSecs / 60;
hours = mins/60;
secs = numSecs - (hours + mins)
III secs = numSecs % 60;
mins = numSecs / 60;
hours = (numSecs / 60) /60
 ### A. I only  B. II only  C. III only  D. I and III only  E. I, II, and III ### Correct Answer:  C ### Explanation: ### Answer: C   Implementation III is correct: The number of seconds equals the remainder when  numSecs  is divided by 60; the number of minutes equals the quotient when  numSecs  is divided by 60; and the number of hours equals the quotient when the number of minutes is divided by 60.  A constructor must assign values to the private instance variables, in a way that satisfies their specifications. Implementation I fails because it doesn’t assign values to  hours  and  mins , and also because  secs  should be no greater than 59. Implementation II fails on the assignment of  secs . For example, if  numSecs  is 67,  hours  is 0,  mins  is 1, but  secs  is not equal to 67 - (0 + 1). ### 
#########################################################
Question: 270 ### 6.  Consider the implementation of the   compareTo  method for the   ElapsedTime  class:  / ** Returns a negative integer if this object is less than rhs, 0 if
* this object is equal to rhs, and a positive integer if this
* object is greater than rhs.
*/
public int compareTo(ElapsedTime rhs)
{ /* compareTo implementation code */ }
  Which is a correct replacement for   /*   implementation code   */ ?  I if (hours < rhs. hours && mins < rhs.mins && secs < rhs.secs)
return -1;
else if (hours > rhs. hours && mins > rhs.mins &k secs > rhs. secs)
return 1;
else
return 0;
Il if (hours < rhs. hours)
return =1;
else if (hours > rhs.hours)
return 1;
else
if (mins < rhs.mins)
return -1;
else if (mins > rhs.mins)
return 1;
else
return secs - rhs.secs;
III int secs = this. convertToSeconds ();
int rhsSecs = rhs.convertToSeconds();
return secs - rhsSecs;
 ### A. I only  B. II only  C. III only  D. I and II only  E. II and III only ### Correct Answer:  E ### Explanation: ### Answer: E   Implementation I uses faulty logic. For example, it treats an  ElapsedTime  of 5 hours 12 minutes 30 seconds as equal to 12 hours 6 minutes 20 seconds. ### 
#########################################################
Question: 271 ### 7.  Let   ArrayList&lt;String&gt; list  be an initialized list of   String  objects. Consider a piece of code that creates an array   arr  that contains all the elements of   list  in the same order.  did not see any text  Which of the following replacements for   /*   more code   */ correctly copies the elements of   list  to   arr ?    for (String str : list)<br/> Â Â Â Â Â Â Â Â arr = str;   int i = 0;<br/> for (String str : list)<br/> {<br/> Â  Â  Â  Â  arr[i] = str;<br/> Â  Â  Â  Â  i++;<br/> }   for (int i = 0; i &lt; list.size(); i++)<br/> Â  Â  Â  Â  arr[i] = list(i); ### A. I only  B. II only  C. III only  D. I and II only  E. II and III only ### Correct Answer:  B ### Explanation: ### Answer: B   To assign elements to array  arr , the  arr[i] =...  structure is needed. Therefore, segment I is wrong. Segment III would be correct if the last line were      arr[i] = list.get(i); ### 
#########################################################
Question: 272 ### 8.  What value does   mystery(6)  return? ### A. 10  B. 12  C. 16  D. 26  E. 32 ### Correct Answer:  C ### Explanation: ### Answer: C   Denote  mystery(6)  as  m (6). The following diagram follows  m (6) to its base case (shaded), which returns the value 2.  m(6)
m(5)
m(4)
m(4)
m(3)
m(3)
m(2)
m(3)
m(2)
m(2)
m(1)
m(2)
m(1)
m(2)
m(1)
  Going up the left-hand side of the tree, you can see the pattern:    m (3) = 2 + 2 = 4<br/>  m (4) = 4 + 2 = 6<br/>  m (5) = 6 + 4 = 1<span class="cambria">0 <br/>  m (6) = 1<span class="cambria">0  + 6 = 16 ### 
#########################################################
Question: 273 ### 9.  To evaluate   mystery(n) , approximately how many calls to   mystery  will there be? ### A.  n   B.  n  2   C.  n  3   D. 2 n   E. 2 n-2 ### Correct Answer:  E ### Explanation: ### Answer: E   Notice from the solution to the previous question that for  mystery(6)  there are 15 calls to  mystery . Plug  n  = 6 into each formula of the answer choices to find which formula gives the result closest to 15:  <div class="table-responsive"><table class="table table-bordered"><tbody> <tr><td> n </td><td>  â </td><td> 6 </td><td></td><td></td> </tr> <tr><td> n 2  </td><td>  â </td><td>  (6) 2  </td><td>  = </td><td>  36 </td> </tr> <tr><td> n 3  </td><td>  â </td><td>  (6)  3  </td><td>  = </td><td>  216 </td> </tr> <tr><td> 2 n  </td><td>  â </td><td> 2 6  </td><td>  = </td><td>  64 </td> </tr> <tr><td> 2 n-2  </td><td>  â </td><td> 2 4  </td><td>  = </td><td>  16 </td> </tr></tbody> </table> ### 
#########################################################
Question: 274 ### 10.  Which of the following is a correct implementation for   /* body */  in the   toString  method of the   Book  class?  I return author + " " + title;
II System. out. println(author + " " + title)
III String s = getAuthor();
s += " ";
s += getTitle ();
return S
   ### A. I only  B. II only  C. III only  D. I and III only  E. I, II, and III ### Correct Answer:  D ### Explanation: ### Answer: D   Segments I and III are both correct: A  String  with the author followed by a space and then the title must be returned. Segment III is a long way of doing this, but it eventually gets there. Segment II is wrong because it doesn't return a  String . ### 
#########################################################
Question: 275 ### 1.  A client program creates a   Book  object as follows:   Â Â Â Â Â Book b = new Book("Vikram Chandra", "Sacred Games");    Which of the following subsequent code segments will cause an error? ### A.  String s = b.toString();   B.  String title = b.getTitle();   C.  String author = b.author;   D.  Book other = b;   E.  System.out.println(b); ### Correct Answer:  C ### Explanation: ### Answer: C   A client of a class cannot access a private instance variable of that class. ### 
#########################################################
Question: 276 ### 2.  Refer to the following class.   public class ManyBooks
private ArrayList<Book> bookList;
/ ** Constructor. Initializes bookList with many Books. . /
public ManyBooks()
{ /* implementation not shown */ }
/ ** Lists the titles only of all the books in bookList, one per line. *
public void displayTitles ()
{ /* implementation code */ }
    Which of the following is correct   /* implementation code */ ?  I for (Book b : bookList)
System. out.println(b.getTitle ());
Il int index = 0;
while (index < bookList. size())
€
System. out.println(bookList.get(index));
index++;
}
III for (int index = 0; index < bookList.size(); index++)
System. out. println(bookList. get (index) . getTitle () );
 ### A. I only  B. II only  C. III only  D. I and III only  E. I, II, and III ### Correct Answer:  D ### Explanation: ### Answer: D   Segment II fails because it doesn't get the  title  of the book, it gets the whole book. The first line of the  while  loop should be<br/>   System.out.println(bookList.get(index).getTitle()); ### 
#########################################################
Question: 277 ### 3.  What is the value of this expression?  did not see any text ### A. 0  B. 1  C. A real number  x  such that 0 â¤  x  &lt; 1  D. A real number  x  such that 0 &lt;  x  â¤ 1  E. The expression is undefined. ### Correct Answer:  A ### Explanation: ### Answer: A    The method call  Math.random()  returns a random real  y  such that 0 â¤  y  &lt; 1. (Some examples: 0.51 . . ., 0.973 . . ., . . .) Casting the expression to  int , namely  (int) Math.random() , truncates  y . This means that the decimal part of the number is chopped off, leaving 0. ### 
#########################################################
Question: 278 ### 4.  Consider this hierarchy of classes.  Cake
LemonCake
ChocolateCake
AppleCake
.. . other Cake subclasses
  The   Cake  class has a method   printRecipe  with the following header.  did not see any text  The method is overridden in each of the subclasses shown above. A client class   ManyRecipes  has a private instance variable   cakeArray  declared as follows.  did not see any text  If   cakeArray  is correctly initialized and contains at least one  Cake , what will happen if the following piece of code is subsequentlyexecuted?  did not see any text ### A. An  ArrayIndexOutOfBoundsException  will be thrown because there is no check on the array indices in the  for  loop.  B. A  ConcurrentModificationException  will be thrown.  C. A   NullPointerException  will be thrown.  D. The default   Cake  recipe will be printed for each   Cake .  E. The correct recipe for each   Cake  in   cakeArray  will be printed. ### Correct Answer:  E ### Explanation: ### Answer: E   This is an example of polymorphism: The correct  printRecipe  method will be selected at run time for each subclass of  Cake . Note that because you are told that the  cakeArray  is correctly initialized, you may assume that each entry is a valid concrete subclass of  Cake . Choice A is false because the enhanced  for  loop accesses each element in the array without accessing indices. Choice B is false because a  ConcurrentModificationException  is thrown if an attempt is made in an enhanced for loop to add an object to a collection. Printing the recipes doesn’t do this. Choice C is false because a  NullPointerException  would be thrown if an attempt were made to call a method with a null object, which isn’t true here. Choice D is false because you are told that the  printRecipe  method has been overridden in each of the subclasses. Therefore, during runtime the correct, overridden method for each type of  cake will be printed. ### 
#########################################################
Question: 279 ### 5.  An array of 10,000   Student  objects,   arr[0] ,   arr[1] , . . .,   arr[9999]  is to be searched for a particular   Student  whose ID number only is known. In order to do a binary search, which of the following is a necessary precondition? ### A. The array is sorted by ID number.  B. The array is in alphabetical order by name.  C. The array is sorted by ID number and alphabetically by name.  D. The ID number key is in the array.  E. No two students in the array have the same name. ### Correct Answer:  A ### Explanation: ### Answer: A    For this search, the key being searched for is an ID number. Therefore, the array must be sorted by ID number. Suppose the key being searched for was a student's name. Then the array would need to be sorted by name to use a binary search. ### 
#########################################################
Question: 280 ### 6.  Given that all sorting algorithms strive to be efficient in terms of time and memory usage, which of the following is the biggest disadvantage of merge sort? ### A. The algorithm uses recursion.  B. The algorithm uses a divide-and-conquer algorithm, which is inefficient.  C. It requires a temporary array.  D. In its worst case it is very inefficient.  E. The merge method is inefficient. ### Correct Answer:  C ### Explanation: ### Answer: C    A temporary array in a recursive method slows it down because the array is created for each recursive call. The other choices are incorrect. For choice A, without recursion merge sort would lose its elegance. For choice B, divide-and-conquer algorithms are some of the  most  efficient algorithms. For choice D, there is not much difference in the efficiency for best, average, and worst cases. For choice E, because of the divide-and-conquer aspect of merge sort, it is more efficient than selection sort or insertion sort, for example. ### 
#########################################################
Question: 281 ### 7.  Here are the private instance variables for a   BankAccount  object.  public class BankAccount
private String password;
private double balance;
private String creditRating;
...
  Which of the following methods in the   BankAccount  class is the best candidate for being a static method? ### A.  getBalance //return balance for this BankAccount   B.  getInterestRate //return interest rate for all BankAccounts   C.  checkForMinimumBalance //check that BankAccount has sufficient funds   D.  deposit //deposit some amount in this BankAccount   E.  getPassword //return password for this BankAccount ### Correct Answer:  B ### Explanation: ### Answer: B   The method  getInterestRate  is the only method that applies to more than one  BankAccount . It should therefore be static. All of the other methods relate directly to one particular  BankAccount  object. So  b.getBalance() ,  b.checkForMinimumBalance() ,  b.deposit(amt) , and  b.getPassword()  are all reasonable methods for a single instance of a  BankAccount . ### 
#########################################################
Question: 282 ### 8.  Consider these declarations.  String s1 = "love";
String s2 = new String ("love") ;
String s3 = s2;
  Which expression involving these strings evaluates to true?     s1.equals(s3)     s1.equals(s2)     s1 == s3 ### A. I only  B. II only  C. III only  D. I and II only  E. I, II, and III ### Correct Answer:  D ### Explanation: ### Answer: D   Here are the memory slots. <div> String
String
81
"love"
"love"
   Statements I and II are true because the contents of  s1  and  s3  are the same and the contents of  s1  and  s2  are the same. Statement III is false because  s1  and  s3  are not the same reference. Note that the expression  s2 == s3  would be true, since  s2  and  s3   are  the same reference. ### 
#########################################################
Question: 283 ### 9.  Consider the following matrix declaration.  did not see any text  Which of the following initializes the 3 Ã 4 matrix of strings such that each elementin the matrix is null?  I for (String[] row : mat)
for (String str : row)
str = null;
II for (int r = 0; r < mat.length; r++)
for (int c = 0; c < mat [r] . length; c++)
mat [r] [c] = null;
III for (int r = 0; r < mat. length; r++)
for (int c = 0; c < mat [r] . length; c++)
mat [r] [c] = "";
 ### A. I only  B. II only  C. III only  D. I and II only  E. I, II, and III ### Correct Answer:  B ### Explanation: ### Answer: B   Segment I fails because you can't use an enhanced  for  loop to assign replacements for array elements in this way. Segment II works-but be aware that the traversal is unnecessary because the matrix values are already set to null. Segment III is wrong because the empty string is not the same as null. ### 
#########################################################
Question: 284 ### 10.  Consider method   newArray  below.  public static int [] newArray (int []
arr1)
{
int count = 0;
for (int i = 0; i < arr1.length; i++)
if (arr1[i] != 0)
{
arr1[count] = arr1[i];
count++;
}
int [] arr2 = new int [count];
for (int i = 0; i < count; i++)
arr2[i] = arr1 [i];
arr1 = arr2;
return arr1;
  Suppose   newArray  is executed with the array   {5,0,3,0,1}  as its parameter. Which of the following represents the array that is returned by the method? ### A.  {5,3,1,0,0}   B.  {5,3,1,0,1}   C.  {5,3,1}   D.  {0,0,5,3,1}   E.  {0,0,0,5,3,1} ### Correct Answer:  C ### Explanation: ### Answer: C    Given that  arr1  originally holds the elements  5 ,  0 ,  3 ,  0 ,  0 ,  1 . After the first  for  loop,  arr1  has been changed to  5 ,  3 ,  1 ,  0 ,  0 ,  1 , and  count , which has counted the nonzero elements, equals  3 . Array  arr2  is created with 3 slots and, after execution of the second  for  loop, contains  5 ,  3 ,  1 . In the final line of code,  arr1  is reassigned to contain these same elements. The algorithm had the effect of removing all zeros from  arr1 . ### 
#########################################################
Question: 285 ### 1.  Consider the following method.  public static String mystery (String str)
String s = str;
final String BLANK = " ";
while (s.indexOf(BLANK) != - 1)
{
int index = s. indexOf (BLANK);
s= s.substring(index + 1);
return s;
1
  What is the result of the method call   mystery ("  I have a dream ")? ### A.  Ihaveadream   B.  I have a dream   C.  Ihave   D.  adream   E.  dream ### Correct Answer:  E ### Explanation: ### Answer: E   The test  s.indexOf(BLANK) != -1  is true if there’s at least one blank in  s . The loop assigns to  s  the substring following the first blank in  s . When there are no more blanks in  s , the loop test becomes false, and  s  contains the last word of the original string. ### 
#########################################################
Question: 286 ### 2.  Which of the following would be the least suitable as a Java class in this program? ### A.  Teacher   B.  Schedule   C.  Student   D.  ClassroomList   E.  Course ### Correct Answer:  C ### Explanation: ### Answer: C   While student names will feature in this program, a  Student  object isn’t useful in the program. The need for the other classes is clear. Choice A: A  Teacher  would have a name and a schedule. Choice B: A  Schedule  would have a list of courses, classrooms, and periods. Choice D: A  ClassroomList  is necessary for keeping track of classroom use. Choice E: A  Course  could have a teacher label, periods taught, and classrooms used. ### 
#########################################################
Question: 287 ### 3.  Which of the following activities, performed by the programmer, would be an example of procedural abstraction? ### A. Deciding to use methods   getCourses  and   getPeriods  to set up a   Schedule  for a   Teacher .  B. Combining the data fields   name  and   schedule  with methods needed in a   Teacher  class.  C. Using private methods in the   Teacher  class to restrict access to some information.  D. Implementing the controller class   ScheduleManager  first, followed by the lower-level subsidiary classes.  E. Writing a  Display  class first so that classes like   Teacher  and   Course  can be tested early in the development process. ### Correct Answer:  A ### Explanation: ### Answer: A   Procedural abstraction is the process of coming up with separate methods that will encapsulate each behavior in a class. Each of the other choices is incorrect. Choice B is an example of  encapsulation , the combining of data fields and methods in a class. Choice C is an example of  information hiding , using  private  to restrict access. Choice D is an example of  top-down development , implementing the main classes first, the lower-level classes later. Choice E is not an example of anything in particular. While it may be a good idea, it’s not an example of procedural abstraction. ### 
#########################################################
Question: 288 ### 4.  Consider the class  WordPrinter  below, which has a recursive method   printSomething .  public class WordPrinter
-
/ .. Prints the English equivalent of digit.
. Precondition: digit is a nonnegative int in the range 0,1, .... 9.
public static void printDigit(int digit)
(
if (digit == 0)
System.out.print("zero");
if (digit == 1)
System.out.print("one");
if (digit == 2)
System.out.print("two");
< similar code for digits 3 through 9 >
..
1
/ .* Recursive method.
· Precondition: n is a nonnegative integer.
./
public static void printSomething(int n)
if(n >= 0 k& n < 10)
printDigit(n);
else
1
printSomething(n / 10);
System.out.print(" ");
printDigit(n % 10);
1
  What will be output by the following method call?   Â Â Â Â Â printSomething(245); ### A.  five four two   B.  two hundred forty five   C.  two four five   D.  two five four   E.  four two five ### Correct Answer:  C ### Explanation: ### Answer: C   Each time a recursive call is made to  printSomething , execution goes back to the start of a new method call, but must remember to execute the pending statements for each call.  printSomething(245)  calls  printSomething(24)  and stacks  System.out.print(" ")  and  printDigit(5) . Then  printSomething(24)  calls  printSomething(2)  and stacks  System.out.print(" ")  and  printDigit(4) . The stack of pending calls can be pictured as follows: <div> System. out. print (" ") ;
printDigit(4) ;
System. out. print(" ") ;
printDigit(5) ;
   Finally,  printSomething(2)  is a base case, so  two  is printed. Now the stack is popped from the top, producing the output  two four five . ### 
#########################################################
Question: 289 ### 5.  Which of the following preconditions suggests using an insertion sort, rather than some other sorting algorithm? ### A. The elements are already sorted.  B. The elements are sorted in reverse sorted order.  C. The elements are in random order.  D. The elements are integers.  E. Best case, average case, and worst case are the same. ### Correct Answer:  A ### Explanation: ### Answer: A    Recall that in insertion sort, the first element,  a[0] , can be thought of as being sorted with respect to itself. Think of the array as consisting of two lists, a sorted list followed by an unsorted list. Each element in the unsorted list is moved into the sorted part by finding its insertion point and then shifting elements to create a slot. If the array is already sorted, then the insertion point for any element will be its current position. There will be no more than one test for each element and no shifting of elements to create a slot-the best case for insertion sort.  The worst case is the array sorted in reverse order, choice B. This is because the insertion point will always be at the front of the array, causing the maximum possible number of tests and data moves. Choice C represents an average case, where one could expect a large number of tests and data moves about half the time. Choice D is completely wrong: The type of elements in the array does not affect the efficiency of the sorting algorithm. ### 
#########################################################
Question: 290 ### 6.  Consider a matrix with the declaration  did not see any text  where   nRows  and   nCols  are positive integers.  The following code segment is intended to replace all single-character strings inthe matrix with the empty string.  for ( /* missing code 1 */ )
for ( /* missing code 2 */)
if (strMat[r] [c].length() == 1)
strMat [r] [c] = "" ;
  Which replacements for   /* missing code 1 */  and   /* missing code 2 */ , respectively, will cause the segment to work as intended?  /. missing code 1 ./
/. missing code 2 ./
| int r = 0; r < strMat[r] . length; r++
int c = 0; c < strKat[c] . length; c++
Il int r = 0; r < strKat.length; r++
int c = 0; c < strKat.length; c++
Ill int r = 0; r < strkat.length; r++
int c = 0; c < strKat [r] . length; c++
 ### A. I only  B. II only  C. III only  D. I and II only  E. I and III only ### Correct Answer:  C ### Explanation: ### Answer: C   The point of this question is that you should know that the number of rows in matrix  m  is given by  m.length  and the number of columns is  m[r].length , where  m[r]  is row  r  in the matrix.  /* missing code 1 */  traverses the rows, so you need the test  r&lt;strMat.length , while  /* missing code 2 */  traverses the columns, so you need the test  c&lt;strMat[r].length . Only segment III uses the correct test in each piece of missing code. ### 
#########################################################
Question: 291 ### 7.  Of the following pairs of methods, which should be coded and tested first to facilitate  testing and debugging the other methods? ### A. The constructor and   add  method  B. The constructor and   compareTo  method  C. The constructor and   toString  method  D. The   toString  and   compareTo  methods  E. The   toString  and one of the   add ,   subtract , or   multiply  methods ### Correct Answer:  C ### Explanation: ### Answer: C   Before manipulating  LargeInt  objects, you have to check that they've been correctly constructed, and to do that you need to output them. This means that the  toString  method must be defined in order to read the output easily. Therefore, the constructor and  toString  methods should be coded before the others. ### 
#########################################################
Question: 292 ### 8.  Consider the problem of simulating the following loop for   LargeInt  objects.  did not see any text    The following code is used. You may assume that   n  exists and is of type   LargeInt .  LargeInt i = new LargeInt (1) ;
LargeInt one = new LargeInt(1);
while (i. compareTo(n) < 0)
{
System.out.println(i);
/* statement to increment i by one */
   Which of the following should replace   /*   statement to increment i by one   */  to simulate the loop correctly? ### A.  i = i.add(one);   B.  i = i.add(1);   C.  i = one.add(n);   D.  i = n.add(one);   E.  i = i.add(n); ### Correct Answer:  A ### Explanation: ### Answer: A   You want to simulate  i++  (or  i=i+1 ). Thus, eliminate choices C and D, which don't include  i  in the method calls to  add . Choice C would be correct if its method call were  one.add(i) . Eliminate choice B because a  LargeInt  parameter must be used. Choice E is wrong because you're not adding  n  to  i , you're adding  1  to  i . ### 
#########################################################
Question: 293 ### 9.  Consider "triangles" that are formed by stacking squares, each with area 1. <div>  1   3   6   10     The area of each such triangle is a  triangular number . Note that the area of the  n th such triangle equals the area of the ( n -1)th triangle plus the area of the new base. Here is a   Triangle  class that provides code to find the area of these   Triangle  objects, given their base.  public class Triangle
private int base;
/ ** Constructor */
public Triangle(int b)
{ base = b; }
/* code to find area of triangle */
  Which of the following replacements for   /* code to find area of triangle */  will correctly find the area of a triangle with the specified base?  I public int getArea()
{
if (base == 1)
return 1;
Triangle smaller = new Triangle(base - 1);
return base + smaller.getArea();
II public int getArea()
{ return area (base) ; }
private int area(int b)
{
if (b == 1)
return 1;
return b + area(b - 1);
III public int getArea()
int sum = 0;
for (int i = 1; i <= base; i++)
sum += i;
return sum;
 ### A. I only  B. II only  C. III only  D. I and II only  E. I, II, and III ### Correct Answer:  E ### Explanation: ### Answer: E    All of the  getArea  methods should work correctly in a client program. In the recursive methods used in segments I and II, the area of the triangle is found by adding the area of the current base to the area of the base of the previous triangle:   base + area (base - 1)    Because this is done recursively, the effect is    base + (base - 1) + (base - 2) + Â· Â· Â· + 1    where 1 is the base case. Segment III, the iterative algorithm, does the same thing starting at 1:    1 + 2 + 3 + Â· Â· Â· + base ### 
#########################################################
Question: 294 ### 10.  A  perfect shuffle  is defined as one in which an array is split in half and the two halves are thenperfectly interleaved. (The process can then be repeated to shuffle the deck.) Ifthe array has an odd number of elements, the middle element is included with the firsthalf of the array, which will have one more element than the second half.  The algorithm is performed using a temporary array for the interleaving process, and     "shuffled" elements are then copied back. Consider an array of integers,Â   nums , and let   temp  be the temporary array after one pass of the perfect shuffle algorithm, before the     elements are copied back to   nums .   Example 1:  <div> 5
10
15
20
25
30
35
40
5
25
10
30
15
35
20
40
    Example 2:  <div> 9
8
7
6
5
4
3
2
1
9
4
8
3
7
2
6
1
5
   The following implementation of the perfect shuffle method does not work as intended.  public static void perfectShuffle (int[] nuns)
€
int[] temp = new int [nums.length] ;
int mid = nums.length/2;
//interleaves elemente 0. .. mid-1 with clemente mid. . . nums. length-
int tempIndex = 0;
int k = 0;
while (k < mid)
temp[tempIndex] = nums [k] ;
tempIndex += 2;
k += 1;
tempIndex = 1;
while (k < nums. length)
temp[tempIndex] = nums[x] ;
tempIndex += 2;
k += 1;
//Code to copy elements back to nums, not shown ...
  Which of the following is a problem with the given implementation of the perfect shufflemethod?    Executing   perfectShuffle  may cause an   ArrayIndexOutOfBoundsException .   The  perfectShuffle  algorithm will not work if the type of elements in the array is something other than  int .   If   nums.length  is even, one or more of   nums[0]...nums[nums.length/2]  will be copied to the wrong position in the   temp  array. ### A. I only  B. II only  C. III only  D. I and III only  E. None of I, II, or III is the problem ### Correct Answer:  A ### Explanation: ### Answer: A   An  ArrayIndexOutOfBoundsException  will be thrown when  nums.length  is odd. When  nums.length  is odd, the first loop must copy one more element than the second loop does. Thismeans that  k  in the first loop must go up to and including  (nums.length+1)/2 , and in the second loop,  k  must start at  (nums.length+1)/2 . As written, in the second half of the algorithm, there will be too many elementsto copy, and  tempIndex  will go out of range while  k  still satisfies the test<br/> while (k &lt; nums.length)   Note that statement II is false because the  perfectShuffle  algorithm is independent of the data type in the array. Statement III is false because  perfectShuffle  works as intended when  nums.length  is even. ### 
#########################################################
Question: 295 ### 1.  A student's test score can be any real number between 0 and 100. The intent of thefollowing class is to print a student's score as a letter grade.  public class TestReport
private double score;
//Constructor. Sets score to the specified value
public TestReport (double value)
{ score = value; }
//Prints grade and comment.
public void printGrade()
{
if (score >= 90.0)
System. out. println("Congratulations!");
if (score >= 80.0)
System. out. println("Good job. ");
if (score >= 70.0)
System.out. println("Average score. ");
if (score >= 60.0)
System. out. println("Barely passing. ");
if (score < 60.0)
System. out.println("Failing score.");
2
  Consider the following segment of a client program.  did not see any text  If   testScore  is 75.0, what will be output? ### A.  Average score.<br/>Barely passing.<br/>Failing score.   B.  Average score.<br/>Barely passing.   C.  Average score.   D.  Congratulations!<br/>Good job.<br/>Average score.   E. An error message will be output. ### Correct Answer:  B ### Explanation: ### Answer: B   The intent of the programmer is to output      Average score.  However, because  else  is not used, each of the  if  statements will be executed and two lines will be printed. The first is printed whenthe program passes the  if (score &gt;= 70.0)  test, the second when it passes the  if (score &gt;= 60.0)  test. The programmer can avoid this either by using a sequence of  else if  tests, thus excluding all other tests when one is found to be true, or by returningthe appropriate string (with a  return  statement) as soon as a test is true. ### 
#########################################################
Question: 296 ### 2.  Consider method  doSomething  below.  public class Earthquake
private double richter;
/ .. Constructor, Sets richter to the specified value on the Richter scale. .
public Earthquake(double value)
{ richter = value; }
/ ** Returns the effect of the earthquake im string form. * /
public String getDescription()
1
String atr;
if (richter >= 8.0)
str = "Most buildings collapse.";
if (richter >= 6.5)
str = "Many buildings damaged. Some fall.";
if (richter >= 4.5)
str = "Poorly-constructed buildings collapse.";
if (richter >= 3.0)
str = "Earth shakes. No destruction. ";
if (richter >= 0)
str = "Barely folt by people.";
return str;
  What output will a call to  doSomething  produce? ### A. <img class="grid-icon" src="https://img.crackap.com/ap/computer-science-a/br23/qn02_02a.png"/>   B. <img class="grid-icon" src="https://img.crackap.com/ap/computer-science-a/br23/qn02_02b.png"/>   C. <img class="grid-icon" src="https://img.crackap.com/ap/computer-science-a/br23/qn02_02c.png"/>   D. <img class="grid-icon" src="https://img.crackap.com/ap/computer-science-a/br23/qn02_02d.png"/>   E. <img class="grid-icon" src="https://img.crackap.com/ap/computer-science-a/br23/qn02_02e.png"/> ### Correct Answer:  C ### Explanation: ### Answer: C    When  i  is  1 ,  j  goes from  1  to  1  and prints one minus sign.<br/> Then  j  goes from  1  to  4  and prints four stars.<br/> When  i  is  2 ,  j  goes from  1  to  2  and prints two minus signs.<br/> Then  j  goes from  1  to  3  and prints three stars.<br/> This pattern continues.<br/> When  i  is  5 ,  j  goes from  1  to  5 , and prints five minus signs.<br/> Then  j  goes from  1  to  0 , which means that no stars are printed.<br/> ### 
#########################################################
Question: 297 ### 3.  Suppose   a  and   b  are boolean variables. The expression  did not see any text  will evaluate to   false  whenever      a  and   b  are both false.      a  is false and   b  is true.      a  is true and   b  is false. ### A. I only  B. II only  C. III only  D. II and III only  E. I, II, and III ### Correct Answer:  D ### Explanation: ### Answer: D    Statement I is incorrect because when  a  and  b  are both false, the expression  !a &amp;&amp; !b  is equivalent to T  &amp;&amp;  T, which is true. Statements II and III are correct because T  &amp;&amp;  F and F  &amp;&amp;  T both evaluate to false. ### 
#########################################################
Question: 298 ### 4.  Consider the following classes, where   Clown  and   Acrobat  are subclasses of   CircusPerformer . <div>  CircusPerformer
Clown
Acrobat
      Which of the following is a  true  statement about the classes shown? ### A. Each of the classes-  CircusPerformer ,   Clown , and   Acrobat -can have a method   doTrick  that has different code.  B. Both   Clown  and   Acrobat  inherit the constructors in   CircusPerformer .  C. If   CircusPerformer  has a private instance variable   routine , both   Clown  and   Acrobat  can directly access it.  D. If   CircusPerformer  has a private method   tumble , both   Clown  and   Acrobat  can access it.  E. If   Clown  has a private instance variable   jokes ,   CircusPerformer  can access it. ### Correct Answer:  A ### Explanation: ### Answer: A    Statement A is true because the  doTrick  method can be overridden in each of its subclasses. Choice B is false because constructors are never inherited. If a subclass has no constructor, the default constructor for the superclass is generated. If the superclass does not have a default constructor, a compile-time error will occur. Choice C is false because the subclasses cannot directly access private instance variables of the superclass. (What they can do is use accessor methods of the superclass.) Choice D is false because a private method in any class can only be accessed in the code of that class. Choice E is false because a superclass cannot access the private instance variables of its subclasses. ### 
#########################################################
Question: 299 ### 5.  Which is a correct   /* implementation of incrementTotal */ ? ### A.  return total + amt;   B.  return getTotal() + amt;   C.  total += amt;   D.  getTotal() += amt;   E.  total = amt; ### Correct Answer:  C ### Explanation: ### Answer: C   The private instance variable  total  must be incremented by  amt . Choices A and B are wrong because  incrementTotal  is  void  and should not return a value. Choice D is wrong because you can't use a method call as the left-hand side of an assignment. Also, in choice D the total is not being changed. Choice E  replaces    total  with  amt  instead of incrementing it. ### 
#########################################################
Question: 300 ### 6.  Which is a correct   /* implementation of changePiggyState */ ?  I if (isFull)
isFull = false;
else
isFull = true;
II isFull = ! isFull;
III if (isFull)
isFull = ! isFull;
 ### A. I only  B. II only  C. III only  D. I and II only  E. I, II, and III ### Correct Answer:  D ### Explanation: ### Answer: D   The value of the boolean instance variable  isFull  must be changed to the opposite of what it currently is. Segments I and II both achieve this. Note that  !true  has a value of  false , and  !false  has a value of  true . Segment III fails to do what is required if the current value of  isFull  is  false . ### 
#########################################################
Question: 301 ### 7.  Consider the following   PiggyBank  class:  public class PiggyBank
private double total;
private boolean isFull;
public double getTotal ()
{ return total; }
/ ** Increase total by amt. * /
public void incrementTotal (double amt)
{ /* implementation of incrementTotal */ }
/ ** Change the value of isFull:
/ ** If its current value is true, change it to false.
/ ** If its current value is false, change it to true. * /
public void changePiggyState()
{ /* implementation of changePiggyState */ }
//Constructors and other methods not shown.
  Which is a correct   /* implementation of changePiggyState */ ?  I if (isFull)
isFull = false;
else
isFull = true;
II isFull = ! isFull;
III if (isFull)
isFull = ! isFull;
 ### A. I only  B. II only  C. III only  D. I and II only  E. I, II, and III ### Correct Answer:  D ### Explanation: ### Answer: D   The value of the boolean instance variable  isFull  must be changed to the opposite of what it currently is. Segments I and II both achieve this. Note that  !true  has a value of  false , and  !false  has a value of  true . Segment III fails to do what is required if the current value of  isFull  is  false . ### 
#########################################################
Question: 302 ### 8.  Consider the following guessing game:  Consider the problem of writing a game in which a user thinks of an integer from 1 to 1,000 inclusive and the computer tries to guess that number. Each time the computer makes a guess, the user makes one of three responses:   "lower" (i.e., the number is lower than the computer's guess)  "higher" (i.e., the number is higher than the computer's guess)  "you got it in &lt;  however many  &gt; tries!"    Suppose the game is programmed so that the computer uses a binary search strategyfor making its guesses. What is the maximum number of guesses the computer could makebefore guessing the user's number? ### A. 9  B. 10  C. 100  D. 500  E. 1,000 ### Correct Answer:  B ### Explanation: ### Answer: B   The computer should find the number in no more than 10 tries. This is because the guessing interval is halved on each successive try:   (1) 1,<span class="cambria">000  Ã· 2 = 5<span class="cambria">00  numbers left to try<br/> (2)  5<span class="cambria">00  Ã· 2 = 25<span class="cambria">0  numbers left to try<br/> (3)  25<span class="cambria">0  Ã· 2 = 125   numbers left to try<br/> (4)  125 Ã· 2 =  63  numbers left to try (at most)<br/> (5)  63 Ã· 2 =  32  numbers left to try (at most)<br/> (6)  32 Ã· 2 =  16  numbers left to try<br/> (7)  16 Ã· 2 =  8  numbers left to try<br/> (8)   8 Ã· 2 =  4  numbers left to try<br/> (9)   4 Ã· 2 =  2  numbers left to try<br/> (1<span class="cambria">0 )  2 Ã· 2 =  1   number left to try<br/>   Ten iterations of the loop leaves just 1 number left to try. Alternatively, round 1,000 to the nearest higher power of 2: 1,000 ≃ 1,024 = 2 10 . The maximum number of guesses (worst case) equals the exponent, 10. ### 
#########################################################
Question: 303 ### 9.  Consider the following guessing game:  Consider the problem of writing a game in which a user thinks of an integer from 1 to 1,000 inclusive and the computer tries to guess that number. Each time the computer makes a guess, the user makes one of three responses:   "lower" (i.e., the number is lower than the computer's guess)  "higher" (i.e., the number is higher than the computer's guess)  "you got it in &lt;  however many  &gt; tries!"    Suppose the computer starts by guessing a random integer between 1 and 1,000, andthen uses a  sequential search  strategy to find the user's number. What is the maximum number of guesses the computercould make before guessing the user's number? ### A. 50  B. 250  C. 500  D. 999  E. 1,000 ### Correct Answer:  D ### Explanation: ### Answer: D   The maximum number of guesses is 999. Suppose the user's number is 1,000 and the computer's first guess happens to be 1. In a sequential search, the computer will try each successive number until it gets to 999. Therefore, in this worst case, the computer will take 999 guesses to reach the user's number. If 999 isn’t the user’s number, then the user’s number must be 1000. ### 
#########################################################
Question: 304 ### 10.  Consider this hierarchy of classes: <div> Entree
LemonChicken
BraisedBeef
RoastTurkey
.. . other Entree subclasses
   The   Entree  class has a method   printRecipe  with the following header.  did not see any text  The method is overridden in each of the subclasses shown above. A client class   RecipeBook  has a private instance variable   allRecipes  declared as follows.  did not see any text  Assuming that   allRecipes  is correctly initialized, the following piece of code is now executed to print a recipe for each subclass dish.  for (Entree e : allRecipes)
e. printRecipe () ;
  Which concept is illustrated by this code? ### A. Overloaded methods  B. Polymorphism  C. Information hiding  D. Procedural abstraction  E. Encapsulation ### Correct Answer:  B ### Explanation: ### Answer: B   Using polymorphism, the correct  printRecipe  method for a given subclass will be selected at run time. Note that the  printRecipe  method must be overridden in each of the  Entree  subclasses for this to happen correctly. Recall that:    overloaded methods are two or more methods in the same class that have the same name but different parameter lists.    information hiding is the use of  private  to restrict access.    procedural abstraction is using separate methods to encapsulate each task in a class.   encapsulation is the combining of data fields and methods in a class. ### 
#########################################################
Question: 305 ### 1.  Which is a  false  statement about static methods? ### A. A static method can use a static variable in its implementation code.  B. If a class is such that it doesn't make sense to ever create an object of the class, then all methods of that class should be static.  C. All methods in a class that has a main method and no private data fields should be static.  D. A static method should not be invoked by an object of a class.  E. Accessor methods in an object class may be static, depending on the value that's being accessed. ### Correct Answer:  E ### Explanation: ### Answer: E    It doesn't make sense to make an accessor static, because an object will then not be able to invoke that method! Note that a static method belongs to the whole class, not an instance of it. It therefore should be invoked in a client class by using the name of the class that defines the method. For example, for a  BankAccount  class one might have  BankAccount.getInterestRate().  If a specific class object is used to invoke the method (instead of the class name), a good compiler will give a warning that this usage is discouraged. ### 
#########################################################
Question: 306 ### 2.  A programmer needs to produce a random   int   n  in the range 20 â¤  n  â¤ 30. A statement that does this correctly is ### A.  int n = 10*Math.random() + 20;   B.  int n = 11*Math.random() + 20;   C.  int n = (int) (Math.random()) + 20;   D.  int n = (int) (Math.random() * 11) + 20;   E.  int n = (int) (Math.random() * 10) + 20; ### Correct Answer:  D ### Explanation: ### Answer: D    What you need is to produce a random integer in the range 0 to 10, inclusive, and then shift the range by 20. The expression       (int) (Math.random() * 11)    produces a random integer from 0 to 10, inclusive. (Note that there are 11 possible numbers.) Adding 20 gives the required range. ### 
#########################################################
Question: 307 ### 3.  Consider the following class definitions.  public class Flyer
public void fly()
{ /* implementation not shown */ }
//Private instance variables and other methods not shown.
public class Bird extends Flyer
public void fly()
{ /* implementation not shown */ }
//Private instance variables and other methods not shown.
public class Sparrow extends Bird
{
public void flyLow(Sparrow other)
{ /* implementation not shown */ }
//Private instance variables and other methods not shown.
  Assuming that both  Flyer  and   Bird   have default constructors, which is (are) valid in a client class?      Flyer f1 = new Bird();       Bird b = new Sparrow();       Flyer f2 = new Sparrow(); ### A. I only  B. II only  C. III only  D. I and II only  E. I, II, and III ### Correct Answer:  E ### Explanation: ### Answer: E   All satisfy the  is-a  test.  Bird   is-a   Flyer ;  Sparrow   is-a   Bird ;  Sparrow   is-a   Flyer . Note: Because  Sparrow   is-a   Bird , it automatically inherits the methods of  Bird , its superclass. Since  Flyer  and  Bird  have default constructors, when a new  Sparrow  is created, the compiler will slot this code into the  Sparrow  class:  public Sparrow ()
{ super () ; }
  There would be an error if the superclass did not have a default constructor. ### 
#########################################################
Question: 308 ### 4.  Consider the following class definitions.  public class Flyer
public void fly()
{ /* implementation not shown */ }
//Private instance variables and other methods not shown.
public class Bird extends Flyer
public void fly()
{ /* implementation not shown */ }
//Private instance variables and other methods not shown.
public class Sparrow extends Bird
public void flyLow(Sparrow other)
{ /* implementation not shown */ }
//Private instance variables and other methods not shown.
  Consider the following declarations in a client class.  Sparrow s = new Sparrow ();
Bird b = new Bird();
  Which method calls would be legal?      s.fly();       b.flyLow(s);       s.flyLow(b); ### A. I only  B. II only  C. III only  D. II and III only  E. I, II, and III ### Correct Answer:  A ### Explanation: ### Answer: A   Method call I works because  Sparrow  inherits all the methods of  Bird . Method call II fails because  Bird , the superclass, does not inherit the methods of  Sparrow , its subclass. Method call III uses a parameter that fails the  is-a  test:  b  is not a  Sparrow , which the parameter requires. ### 
#########################################################
Question: 309 ### 5.  Which best describes what the  printSomething  method below does?  public void printSomething(String s)
{
if (s.length() > 0)
{
System.out.print(s.substring(0, 1));
printSomething(s.substring(1));
}
 ### A. It prints string   s .  B. It prints string   s  in reverse order.  C. It prints only the first character of string   s .  D. It prints only the first two characters of string   s .  E. It prints only the last character of string   s . ### Correct Answer:  A ### Explanation: ### Answer: A    Because the recursive call is made at the end of the method, the  System.out.print...  statements are executed at the  beginning  of each method call, causing the letters of the string to be printed out in order. If the two statements in the method were interchanged, so that the recursive call is made at the beginning of the method, then the pending  print...  methods would be stacked up, causing the string to be printed in reverse order. ### 
#########################################################
Question: 310 ### 6.  Refer to the following method that finds the largest value in an array.  / ** Precondition: arr is initialized with int values.
* Postcondition: Returns the largest value in arr.
*/
public static int findMax(int [] arr)
{
int max = /* some value */;
int index = 0;
while (index < arr.length)
{
if (arr [index] > max)
max = arr [index] ;
index++;
}
return max;
  Which replacement(s) for   /* some value */  will always result in correct execution of the   findMax  method?      Integer.MIN_VALUE       Integer.MAX_VALUE       arr[0] ### A. I only  B. II only  C. III only  D. I and III only  E. II and III only ### Correct Answer:  D ### Explanation: ### Answer: D    Because the values in  arr  cannot be less than  Integer.MIN_VALUE , the test in the  while  loop will be true at least once and will lead to the largest element being stored in  max . (If  all  the elements of the array are  Integer.MIN_VALUE , the code still works.) Similarly, initializing  max  to  arr[0] , the first element in the array, ensures that all elements in  arr  will be examined and the largest will be found. Choice II,  Integer.MAX_VALUE , fails because the test in the loop will always be false! There is no array element that will be greater than the largest possible integer. The method will (incorrectly) return  Integer.MAX_VALUE . ### 
#########################################################
Question: 311 ### 7.  An opera company has a large list of donor records, sorted alphabetically by name. Each record contains the amount of money donated in the current year. Which of the following represents the most efficient way to find the name of the top donor in the current year? ### A. Insertion sort of the records  B. Selection sort of the records  C. Merge sort of the records  D. Binary search of the records  E. Sequential search of the records ### Correct Answer:  E ### Explanation: ### Answer: E    Because the records are not sorted by amount, each record must be examined to find the one with the largest amount. It therefore doesn't make sense to sort the elements, which involves both examination and movement of elements. So you can eliminate choices A, B, and C. Choice D, the binary search, is wrong because a binary search for an amount can only be done if the list is sorted on that key field. The given list of records is sorted by name, not amount. ### 
#########################################################
Question: 312 ### 8.  Refer to the following code segment.  int n = < some positive integer >
for (int i = n; i > 1; i /= 2)
process(i) ;
  In terms of   n , how many times will   process(i)  be executed? ### A.  n  if   n  is even and   n + 1  if   n  is odd  B.  2   n  if   n  is even and   2 n - 1  if   n  is odd  C.  n/2  if   n  is even and  1  +   n/2  if   n  is odd  D.  n % 2  if n is even and  1 + n % 2  if  n  is odd  E.  2 n   if   n  is even and  2 n   -  1  if   n  is odd ### Correct Answer:  C ### Explanation: ### Answer: C   If you consider a small even number like  4 , the loop will be executed when  i  is  4  and  2 , twice. This eliminates choices A, B, and E. If  n  is  8 , the loop is executed when  i  is  8 ,  6 ,  4 , and  2 , four times. Since  n % 2  is 0 this eliminates choice D. Notice that choice C also works for any odd integer,  7  say. The loop will execute when  i  is  7 ,  5 ,  3 , and  1 , four times or  7/2 + 1 . ### 
#########################################################
Question: 313 ### 9.  Consider the following classes.  public class PosInt
private int value;
/ ** Constructs a PosInt with value 1. * /
public PosInt ()
{ value = 1; }
/ .* Constructs a PosInt with the given value.
. Precondition: aValue > 0.
·/
public PosInt(int aValue)
{ value = aValue; }
public int getValue()
{ return value; }
public class EvenPosInt extends PosInt
1
/ .* Returns the next consecutive even int value that is greater
* than the value of the current EvenPosInt.
*/
public int getNextEven()
{ /* implementation */ }
  Which of the following declarations in a client class would cause an error?      PosInt p = new PosInt();       PosInt even = new EvenPosInt();       PosInt pe = new EvenPosInt(8); ### A. I only  B. II only  C. III only  D. II and III only  E. I, II, and III ### Correct Answer:  C ### Explanation: ### Answer: C   Declaration I clearly works because there is a default constructor in the  PosInt  class. The reason declaration II works is that, because the superclass  PosInt  has a default constructor, the following code will automatically be placed in the subclass  EvenPosInt :  did not see any text  This only works for a default constructor. So declaration III fails because superclass constructors are not inherited. You need to add the following constructor code to  EvenPosInt  to make declaration III work:  did not see any text ### 
#########################################################
Question: 314 ### 10.  Consider the following classes.  public class PosInt
private int value;
/ ** Constructs a PosInt with value 1. * /
public PosInt ()
{ value = 1; }
/ ** Constructs a PosInt with the given value.
* Precondition: aValue > 0.
*/
public PosInt(int aValue)
{ value = aValue; }
public int getValue()
{ return value; }
public class EvenPosInt extends PosInt
/ ** Returns the next consecutive even int value that is greater
* than the value of the current EvenPosInt.
*/
public int getNextEven()
{ /* implementation */ }
  Suppose that the following constructor is added to the  EvenPosInt  class.  did not see any text  Which of the following is a correct   /* implementation */  for the   getNextEven  method?     return value + 2;     return getValue() + 2;     return this.getValue() + 2; ### A. I only  B. II only  C. III only  D. II and III only  E. I, II, and III ### Correct Answer:  D ### Explanation: ### Answer: D   Implementation I is incorrect because a subclass cannot directly access the private data of its superclass. The accessor method  getValue  must be used, as shown in implementations II and III. The identifier  this  represents the current  EvenPosInt  object. ### 
#########################################################
Question: 315 ### 1.  Consider a   Date  class whose partial representation is shown below.  public class Date
{
private int month, day, year;
//Constructor
public Date(int aMonth, int aDay, int aYear)
{
month = aMonth;
day = aDay;
year = aYear;
//Other methods and constructors not shown.
//There is no compareTo method in the class
  Consider the following declarations.  did not see any text  Based on the given information, which of the following statements  must  be true? ### A. The test   if (d1 == d2)  is   true .  B. The test   if (d1.equals(d2))  will cause a compile-time error.  C. The test   if (d1.equals(d2))  is   true .  D. The test   if (d1.compareTo(d2) == 0)  is true.  E. The test   if (d1.compareTo(d2) == 0)  will cause a compile-time error. ### Correct Answer:  E ### Explanation: ### Answer: E   To use the  compareTo  method without a compiler error, the class should have a  compareTo  method defined, which you are told has not been done. Each of the other statements is false: for choice A, when two objects are compared using  == , the test is false if  d1  and  d2  are not the same reference. Choice B is false because every class inherits the  equals  method from the universal superclass  Object . For choice C, the test will return  true  only if the  equals  method is overridden in class  Date  in such a way that two  Date  objects are equal if their  month ,  day , and  year  data fields are equal. Because you don't know whether  equals  has been overridden, you can't state that choice C is true. For choice D, the test can't be true if it doesn't compile. Note: An alternative way to have the  compareTo  method compile without error is for the  Date  class to implement the  Comparable  interface. You are not required to know this for the AP exam. ### 
#########################################################
Question: 316 ### 2.  A square matrix is declared as  did not see any text  where   SIZE  is an appropriate integer constant. Consider the following method.  public static void sum (int [] [] mat)
{
int total = 0;
for (int r = 0; r < mat. length; r++)
for (int c = 0; c <= r; c++)
total += mat [r] [c] ;
return total;
  If   mat  is initialized to be <div class="s9-scrollable"> 2
6
3
4
5
1
7
1
2
   what value will be returned by a call to   sum(mat) ? ### A. 9  B. 15  C. 19  D. 21  E. 31 ### Correct Answer:  D ### Explanation: ### Answer: D   Here are the elements that are added to  total :  r=0; mat [ 0 ] [ 0 ]
2
r=1: mat [ 1] [ 0 ] + mat [ 1] [ 1]
4 + 5
r=2; mat [2] [ 0] + mat [2] [ 1] + mat [2] [ 2]
7 +1 + 2
Value returned = 2 + 4 + 5 + 7 + 1 + 2 = 21
 ### 
#########################################################
Question: 317 ### 3.  Consider the following declarations.  public class Performer
{
private String specialty;
public Performer()
{ specialty = ""; }
public Performer(String aSpecialty)
{ specialty = aSpecialty; }
public void doRoutine ()
{ System. out. println("Do something special. "); }
public class Dancer extends Performer
{
public Dancer ()
{ super () ; }
public Dancer(String aSpecialty)
{ /* implementation not shown */ }
public void doRoutine ()
{ System. out. println("Backflip and spin. "); }
public class BalletDancer extends Dancer
public BalletDancer ()
{ super () ; }
public BalletDancer(String aSpecialty)
{ /* implementation code */}
public void doRoutine ()
{ System. out. println ("Pirouette. ") ; }
  The purpose of the constructor  BalletDancer(String aSpecialty)  is to assign a user-provided feature to a ballet dancer when a  BalletDancer  object is constructed. Which of the following replacement(s) for  /* implementation code */  correctly achieve(s) this goal?      super();       super(aSpecialty);       specialty = aSpecialty; ### A. I only  B. II only  C. III only  D. I and II only  E. II and III only ### Correct Answer:  B ### Explanation: ### Answer: B   Segment II correctly assigns  aSpecialty  to a new  BalletDancer . Segment I will compile without error, because the superclass,  Dancer , has a default constructor. However, the specialty assigned to a new  BalletDancer  will be that in the default constructor of a  Dancer , which was not the intent of the constructor with a parameter. Segment III fails because a subclass cannot directly access the private data of its superclass. ### 
#########################################################
Question: 318 ### 4.  Consider the following declarations.  public class Performer
{
private String specialty;
public Performer()
{ specialty = ""; }
public Performer(String aSpecialty)
{ specialty = aSpecialty; }
public void doRoutine ()
{ System. out. println("Do something special. "); }
public class Dancer extends Performer
{
public Dancer ()
{ super () ; }
public Dancer(String aSpecialty)
{ /* implementation not shown */ }
public void doRoutine ()
{ System. out. println("Backflip and spin. "); }
public class BalletDancer extends Dancer
public BalletDancer ()
{ super () ; }
public BalletDancer(String aSpecialty)
{ /* implementation code */}
public void doRoutine ()
{ System. out. println ("Pirouette. ") ; }
  A client class has an   ArrayList&lt;Performer&gt; performers  that is initialized with many different objects that are subclasses of   Performer . Each subclass has an overridden   doRoutine  method, similar to those shown in the   Dancer  and   BalletDancer  classes. What is the effect of executing the following code segment?  did not see any text ### A. The unique routine for each particular   Performer  will be output.  B. The string " Do something special. " will be printed for each  p  in  performers .  C. The string " Backflip and spin. " will be printed for each  p  in  performers .  D. There will be a compile-time error with a message to the effect that there cannotbe different types in   ArrayList&lt;Performer&gt; .  E. A run-time error will occur. ### Correct Answer:  A ### Explanation: ### Answer: A   The code will work as intended; namely, at run time, the appropriate  doRoutine  method will be called, depending on the current instance of  Performer p . This is an example of polymorphism or dynamic binding. Polymorphism occurs when a superclass method has been overridden in the subclass(es). ### 
#########################################################
Question: 319 ### 5.  A class has a two-dimensional squarearray.  did not see any text  The array is initialized to have   SIZE  rows and columns. Consider the following method in the class.  private void fillArray (String str)
int i = 0;
for (int r = 0; r < SIZE; r++)
for (int c = 0; c < SIZE; c++)
if (i < str.length())
strMat[r] [c] = str.substring(i, i + 1);
else
strMat [r] [c] = "0";
i++;
1
  Which of the following could be the resulting matrix after a call to  fillArray("obtaining") , assuming that the method runs without error?     o b t aÂ    <li class="no-number"> i n i n   <li class="no-number"> g 0 0 0Â    <li class="no-number"> 0 0 0 0     o b tÂ    <li class="no-number"> a i n   <li class="no-number"> Â i n g     o bÂ    <li class="no-number"> t a ### A. I only  B. II only  C. III only  D. I and II only  E. I, II, and III ### Correct Answer:  E ### Explanation: ### Answer: E   All are correct, depending on whether  SIZE  is 4, 3, or 2. The method fills the two-dimensional square array  strMat  with single-character strings obtained with  str.substring(i, i + 1)  in row-major order-the first row is filled from left to right, then the second row, and so on. When the test  if (i &lt; str.length())  fails, the remaining matrix slots are filled with zeros, as in matrix I. Notice that if the number of slots in the matrix is less than the number of characters in  str , the method will quit without error before the entire string is processed, which is what happened for matrix III. ### 
#########################################################
Question: 320 ### 6.  Let   list  be an   ArrayList&lt;Integer&gt;  containing these elements: <pre class="monospace image_move"> 4 5 6 2 1  </pre> Which of the following statements will cause an error? (You may assume that integers added to the list will automatically be wrappedâauto-boxedâinto   Integer  objects.) ### A.  list.add(5);   B.  list.add(2, 4);   C.  Integer intOb = list.get(5);   D.  Object ob = list.add(5, 7);   E.  Integer x = list.set(3, 0); ### Correct Answer:  C ### Explanation: ### Answer: C   This statement will cause an  IndexOutOfBoundsException  because there is no slot with index  5 . Notice that choice D is correct: The size of the list will be adjusted to  6 , and the  Integer 7  will be added to the last slot, i.e., the slot with index  5 . ### 
#########################################################
Question: 321 ### 7.  Refer to following method   insert .  / ** Precondition: ArrayList list is an ArrayList that contains
Integer values sorted in decreasing order.
* Postcondition: Element inserted in its correct position in list
./
public void insert(ArrayList<Integer> list, Integer element)
{
int index = 0;
while (element < list.get(index))
index++;
list.add(index, element);
  Suppose that the element to be inserted has value   -8 . For which   list  will the method work as intended?    8 4 0 -4   -2 -4 -6 -9   -1 -2 -4 -6 ### A. I only  B. II only  C. III only  D. II and III only  E. I, II, and III ### Correct Answer:  B ### Explanation: ### Answer: B   Note that the method will  fail  whenever  element  is less than the last item in the list, because  index  will be incremented to a value that is out of bounds. This will happen in lists I and III. Because  -8  is greater than  -9  (list II), the test in the method will be false, preventing an out-of-range error. ### 
#########################################################
Question: 322 ### 8.  Refer to the following declarations.  did not see any text  Which of the following correctly assigns the elements of the   birds  array to   birdList ? The final ordering need not be the same as in the   birds  array.  I for (String b: birds)
birdList.add(b);
II for (String b: birdList)
birds.add(b);
III for (int i = birds.length - 1; i >= 0; i -- )
birdList. add(i,
1, birds [i] ) ;
 ### A. I only  B. II only  C. III only  D. I and III only  E. I, II, and III ### Correct Answer:  A ### Explanation: ### Answer: A    The declaration of the  birds  array makes the following assignments:  birds[0] = "robin" ,  birds[1] = "parrot" , and  birds[2] = "bluejay" . The loop in segment I adds these values to  birdList  in the same order. Segment II fails because  birds  is an array and therefore can't use the  get  method. The code also confuses the lists. Segment III, in its first pass through the loop, attempts to add  birds[2]  to index position  2  of the  birdList . This will cause an  IndexOutOfBoundsException  to be thrown, since index positions  0  and  1  do not yet exist. ### 
#########################################################
Question: 323 ### 9.  Consider the following   Item  and  Sale  classes:  public class Item
(
private String description;
private double price;
//constructor
public Item(String aDescription, double aPrice)
description = aDescription;
price = aPrice;
//accessors getDescription() and getPrice() not shown.
public class Sale
€
private int numItems;
private Item[] itemList;
//constructor
public Sale(int theNumItems)
numItems = theNumItems;
itemList = new Item[theNumItems] ;
String itemDescription;
double itemPrice;
for (int i = 0; i < theNumItems; i++)
<read user input for itemDescription and itemPrice >
itemList [i] = /* code to create a new Item */
//Returns total amount paid for this sale.
public double totalPaid()
double total = 0.0;
/* code to calculate amount */
return total;
  Which of the following correctly replaces   /* code to create a new Item */  in the   Sale  constructor to initialize the   itemList  array? ### A.  new Item(getDescription(), getPrice());   B.  new Item(itemDescription, itemPrice);   C.  new itemList(getDescription(), getPrice());   D.  new itemList(itemDescription, itemPrice);   E.  new itemList(theNumItems); ### Correct Answer:  B ### Explanation: ### Answer: B   For each  i ,  itemList[i]  is a new  Item  object that must be constructed using the  Item  constructor. Therefore, eliminate choices C, D, and E. Choice A is wrong because  getDescription()  and  getPrice()  are accessors for values  that already exist  for some  Item  object. ### 
#########################################################
Question: 324 ### 10.  Consider the following   Item  and  Sale  classes:  public class Item
(
private String description;
private double price;
//constructor
public Item(String aDescription, double aPrice)
description = aDescription;
price = aPrice;
//accessors getDescription() and getPrice() not shown.
public class Sale
€
private int numItems;
private Item[] itemList;
//constructor
public Sale(int theNumItems)
numItems = theNumItems;
itemList = new Item[theNumItems] ;
String itemDescription;
double itemPrice;
for (int i = 0; i < theNumItems; i++)
<read user input for itemDescription and itemPrice >
itemList [i] = /* code to create a new Item */
//Returns total amount paid for this sale.
public double totalPaid()
double total = 0.0;
/* code to calculate amount */
return total;
  Which represents correct   /* code to calculate amount */  in the   totalPaid  method? ### A. did not see any text  B. did not see any text  C. did not see any text  D. Sale thisSale;
for (Item it : thisSale)
total += it.getPrice();
  E. Sale thisSale;
for (Item it : thisSale)
total += it.price;
 ### Correct Answer:  C ### Explanation: ### Answer: C   To access the price for each  Item  in the  itemList  array, the  getPrice()  accessor in the  Item  class must be used, because  price  is private to that class. This eliminates choices A and E. Choice B uses  itemList  incorrectly: There's no  getPrice  method for an array object. Choices D and E incorrectly declare a  Sale  object. (The method  totalPaid  applies to an existing  Sale  object.) ### 
#########################################################
Question: 325 ### 1.  Consider the  insertionSort  method below, which does not always work as intended. The intention of the programmer is that the method will sort  arr , an array of integers, in descending order.  / ** Sorts array arr in descending order.
* Precondition: arr is an array of integers
*/
public static void insertionSort (int [] arr)
{
for (int i = 1; i < arr.length; i++)
{
int temp = arr [i];
int j = i - 1;
while (temp > arr[j])
{
arr[j + 1] = arr [j];
j --;
}
arr[j + 1] = temp;
  The programmer intends that after  k  passes through the outer loop, elements  arr[0], arr[1], . . . arr[k]  will be sorted with respect to each other, but not necessarily in their final sorted position. Each element in the unsorted part of the array will be moved to the left, until its insertion point is found in the sorted part of the array and then inserted into that slot.  The method doesnât work as intended in every case.  Which of the following arrays will cause an error, if passed as a parameter to the method above? ### A.  8, 2, 1, 6, 4   B.  6, 5, 4, 3, 2   C.  4, 4, 3, 4, 4   D.  2, 8, 1, 5, 3   E.  9, 7, 8, 9, 4 ### Correct Answer:  D ### Explanation: ### Answer: D   The problem will occur whenever there’s an element in the array that is larger than the element in the first slot. Because the  while  loop has no range check on  j , any element larger than  arr[0]  will sail off the left end of the array and result in an  ArrayIndexOutOfBoundsException . The problem can be fixed by changing the boolean test in the  while  loop: <pre> while (j &gt;= 0 &amp;&amp; temp &gt; arr[j]) </pre> ### 
#########################################################
Question: 326 ### 2.  The elements of array   arr  are to be sorted in increasing order. Which represents the first step of a merge sort algorithm? ### A. Find the smallest element in   arr  and swap it into   arr[0] .  B. Compare   arr[0]  with   arr[1]  and, if necessary, shift and replace elements such that   arr[0]  is less than   arr[1] .  C. Compare   arr[0]  with the middle element of   arr ,   arr[mid] , and if   arr[0]  is less than   arr[mid] , swap these elements.  D. Compare the first and last elements, and if the first is less than the last, swap these elements.  E. Break the array into roughly two equal halves. ### Correct Answer:  E ### Explanation: ### Answer: E    Here's a recursive description of how merge sort works:   If there is more than one element in the array   Break the array into roughly two equal halves.   Merge sort the left half.   Merge sort the right half.   Merge the two subarrays into a sorted array. ### 
#########################################################
Question: 327 ### 3.  Consider the  mystery  method below.  public static int mystery (int k, int n)
{
if (n == k)
return n;
else if (n > k)
return mystery (k + n, n - k) ;
else
return mystery (k - n, n);
  What will be returned by the following method call?   mystery (7, 3); ### A.  1   B.  2   C.  3   D.  5   E.  7 ### Correct Answer:  B ### Explanation: ### Answer: B    Here is the sequence of recursive calls:  did not see any text   which is a base case that returns  2,  since  n = k = 2. ### 
#########################################################
Question: 328 ### 4.  Consider the following program description.  A programmer plans to write a program that simulates a small card game (no more than four players). Each player will have a hand of ten cards, in which each card has a suit and a value. The game will involve either adding cards to a hand or discarding cards. The first player to have zero cards left in his hand is the winner. In the simulation, as the game is in progress, each player's hand is displayed on the screen.   The programmer plans to have a short class whose  main  method has just two statements: <div class="s9-scrollable"> did not see any text     The  Game  class will have several objects: a  Display , a  Deck , a  Card , and a  PlayerGroup . The  PlayerGroup  will have a list of  Player s, and each  Player  will have a  Hand  of  Card s.  The relationship between the   Player  and   Hand  classes is an example of ### A. inheritance  B. top-down design  C. information hiding  D. independent classes  E. composition ### Correct Answer:  E ### Explanation: ### Answer: E   Composition is the  has-a  relationship. A Player  has-a   Hand . Inheritance (choice A) is the  is-a  relationship, which doesn’t apply here. None of the choices B, C, or D apply here. Top-down design is a style of designing a program, not a relation between classes. Information hiding is the use of  private  to restrict access; and  Player  is  dependent  on  Hand , becasue a  Player  has a  Hand . ### 
#########################################################
Question: 329 ### 5.  Consider the following program description.  A programmer plans to write a program that simulates a small card game (no more than four players). Each player will have a hand of ten cards, in which each card has a suit and a value. The game will involve either adding cards to a hand or discarding cards. The first player to have zero cards left in his hand is the winner. In the simulation, as the game is in progress, each player's hand is displayed on the screen.  The programmer plans to have a short class whose  main  method has just two statements:  did not see any text  The  Game  class will have several objects: a  Display , a  Deck , a  Card , and a  PlayerGroup . The  PlayerGroup  will have a list of  Player s, and each  Player  will have a  Hand  of  Card s.  Which is a reasonable data structure for a   Hand  object? Each hand starts with ten cards, and the number of cards can only go down. There should be a mechanism for removing a card, displaying a card, and for detecting a winning hand (no cards left in it).  I Card[] hand;
//will initially contain 10 Cards
int numCards;
//player wins when numCards is 0
II boolean[] hand;
//will contain 52 boolean values, of which
//10 are initially true. All other values are false.
//The true values represent the cards initially in
//the Hand. A card is "removed" from the hand by
int numTrue;
//changing an array value from true to false.
//player wins when numTrue is 0
III ArrayList<Card> hand; //an ArrayList that will initially contain
//10 Cards. A Card is removed by removing it
//from the ArrayList. Player wins when hand. size() == O
 ### A. I only  B. II only  C. III only  D. I and III only  E. I, II, and III ### Correct Answer:  D ### Explanation: ### Answer: D   Data structure III conveniently stores a list of  Card s in which  Card s can easily be removed using the  remove  method of  ArrayList . The array in data structure II allows for all cards in a deck to be represented (either in the  Hand  or not); however, it doesn't provide a way to represent the suits and values of the cards themselves or to display a card. The array of  Card  in data structure I may seem unsuitable because an array has fixed length. However, when a card is removed, it is easy to represent this by replacing that card with  null  in that array slot. ### 
#########################################################
Question: 330 ### 6.  Consider the  Card  and  Deck  classes below, which are used to create a  Deck of Card  objects.  public class Card
{
private String suit;
private String value;
public Card(String aSuit, String aValue)
{
suit = aSuit;
value = aValue;
//Other methods not shown.
}
public class Deck
ArrayList<Card> deck;
public Deck()
{
getCards () ;
}
public void getCards ()
{ /* implementation not shown */ }
//Other methods not shown.
    The programmer tests the constructor of the  Deck  class with the  DeckTester  class shown below.  public class DeckTester
{
public static void main(String[] args)
{
Deck d = new Deck() ;
}
   When the code is run, a  NullPointerException  is thrown. Which of the following could be the cause of the error?    The  DeckTester  class object was not created with  new .   In the  getCards  method, an attempt was made to add a  Card  to an  ArrayList  that had not been  created with  new .   In the  getCards  method, an attempt was made to construct a  Card  object without  new . ### A. I only  B. II only  C. III only  D. I and II only  E. II and III only ### Correct Answer:  B ### Explanation: ### Answer: B    A  NullPointerException  is thrown whenever an attempt is made to call a method with an object that hasn’t been created with  new . If the  ArrayList   deck  was not created with  new , the method call  deck.add(someCard)  would cause the  NullPointerException .  Choice I is incorrect because  DeckTester  is an objectless class with a static main method, used to test objects in the program.  Choice III is wrong. No methods are called with a  null Card  object. If an attempt is made to add a  Card  to a deck without using the key word  new , the compiler will find the error before the program is run. ### 
#########################################################
Question: 331 ### 7.  Consider the  Name  class below.  public class Name
private String fullName;
private String firstName;
private String middleInitial;
private String lastName;
public static final String BLANK = " ";
public Name (String aFullName)
fullName = aFullName;
int index = fullName.indexOf(BLANK);
String s = "";
/* code to get firstName */
/* code to get lastName */
//The rest of the constructor is not shown.
//Other instance variables and methods are not shown
  A full name in the  Name  class consists of a first name, followed by a single blank, one middle initial, a period, another blank, and a last name. Some examples of full names are:  John Q. Smith ,  Camilla J. Hernandez ,  Jo-Ann P. Green , and  Zach K. Teukolsky-Adams .  Which is correct code for   /* code to get firstName */ ?      firstName = fullName - middleInitial - lastName;     firstName = fullName.substring(0, index);     for (int i = 0; i &lt; index; i++)   <li class="no-number"> Â  Â  Â  Â s += fullName.substring(i, i + 1);Â    <li class="no-number"> firstName = s; ### A. I only  B. II only  C. III only  D. I and II only  E. II and III only ### Correct Answer:  E ### Explanation: ### Answer: E   Segment I is garbage: Subtraction of strings is meaningless. Segment II works: If  fullName  is  Jan P. Smith , then the position of the first blank,  index , is  3 . For the  firstName , you want the substring of  fullName  from  0  to  2 . (Recall that the second parameter of substring is the first position you don't want.) Segment III is long-winded, but it works: For  index-1  times it appends a single character string to  s , and then sets  firstName  to contain  s . ### 
#########################################################
Question: 332 ### 8.  Consider the  Name  class below.  public class Name
private String fullName;
private String firstName;
private String middleInitial;
private String lastName;
public static final String BLANK = " ";
public Name (String aFullName)
2, 4
fullName = aFullName;
int index = fullName. indexOf(BLANK);
String s = "";
/* code to get firstName */
/* code to get lastName */
//The rest of the constructor is not shown.
//Other instance variables and methods not shown
  A full name in the  Name  class consists of a first name, followed by a single blank, one middle initial, a period, another blank, and a last name. Some examples of full names are:  John Q. Smith ,  Camilla J. Hernandez ,  Jo-Ann P. Green , and  Zach K. Teukolsky-Adams .  Which is correct code for   /* code to get lastName */ ?     lastName = fullName.substring(index + 4);     lastName = fullName.substring(index + 4, fullName.length());     lastName = fullName.substring(firstName.length() + 4); ### A. I only  B. II only  C. III only  D. I and II only  E. I, II, and III ### Correct Answer:  E ### Explanation: ### Answer: E   They are all correct! One version of  substring  has a single parameter,  startIndex . The method returns the substring that starts at  startIndex  and goes to the end of the string. Segment I uses this version, starting at the position immediately following the second blank. Another version of  substring  has two parameters,  startIndex  and  endIndex . In this case, the  substring  method returns the substring that starts at  startIndex  and goes up to  endIndex-1 . Segment II correctly uses this version. Segment III uses the single-parameter version of  substring , taking care to start at the correct position of  fullName . If the actual name were  Pat C. Clark , the last name starts at position  7 , which can be obtained by:   length of  firstName  + blanks + middle initial + period = 3 + 2 + 1 + 1 = 7 ### 
#########################################################
Question: 334 ### 10.  The selection sort algorithm sorts an array   arr  of integers in ascending order as follows. <ol class="list-decimal" style="list-style-type:decimal">  Loop from   j = 0  to   j = arr.length-2  inclusive.   In each pass, swap   arr[j]  with the largest element in   arr[j+1]  through   arr[a.length-1] .    A student writes the following code for this algorithm:  Line 1: public static void selectionSort (int [] arr)
Line 2: {
Line 3:
for (int j = 0; j < arr.length - 1; j++)
Line 4:
Line 5:
int minIndex = 0;
Line 6:
for (int k = j + 1; k < arr.length; k++)
Line 7:
Line 8:
if (arr[k] < arr [minIndex])
Line 9:
{
Line 10:
minIndex = k;
Line 11:
7
Line 12:
Line 13:
int temp = arr [j];
Line 14:
arr [j] = arr [minIndex] ;
Line 15:
arr [minIndex] = temp;
Line 16:
Line 17: }
  The code doesn't work as intended. Which change should be made to fix it? ### A. Change Line 3 to be:did not see any text  B. Change Line 6 to be:did not see any text  C. Change Line 5 to be:did not see any text  D. Change Line 10 to be:did not see any text  E. Change Line 8 to be:did not see any text ### Correct Answer:  C ### Explanation: ### Answer: C   For each pass through the loop, you want   minIndex  , the index of the smallest element, to be initialized to the first element in the piece of array still to be sorted. The first element is determined by the current value of   j  . Therefore,   minIndex   must be initialized to   j   for each pass through the outer loop. If   minIndex   is always initialized to 0, which is the mistake the student made, the algorithm after the first pass through the outer loop will never find a smaller value than  arr[0]  (which is the smallest value in the whole array). This means that the array will not get sorted. Choice A is wrong because you need  arr.length-1  passes. If the loop goes from 0 to  arr.length-1 , there will be one pass too many, and  arr[ k ]  will give an  ArrayIndexOutOfBoundsException  when  k  equals  j + 1 . Choice B fails in a similar way. If k equals  arr.length ,  arr[ k ]  will give an  ArrayIndexOutOfBoundsException . Choice D doesn't make sense. If  arr[k]  is smaller than  arr[ minIndex ] , then   minIndex   must be set equal to   k  . Choice E is wrong because you're searching for the smallest element. You therefore need to do a "less-than" test. ### 
#########################################################
